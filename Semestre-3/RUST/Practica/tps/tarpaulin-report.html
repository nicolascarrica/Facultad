<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","main.rs"],"content":"mod tp02;\r\nmod tp03;\r\nmod tp04;\r\nfn main() {\r\n\r\n}\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej01.rs"],"content":"// 1-Definir la función llamada es_par que recibe como parámetro un número entero y retorna\r\n// true si el número es par, false caso contrario\r\npub fn es_par(num: i32) -\u003e bool {\r\n  let resultado = num % 2 == 0;\r\n  resultado\r\n}\r\n\r\n\r\n#[test]\r\nfn test_es_par() {\r\n    assert_eq!(es_par(2), true);\r\n    assert_eq!(es_par(3), false);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej02.rs"],"content":"// 2- Definir la función llamada es_primo que recibe un número entero positivo mayor a 1 y\r\n// retorna true si es primo, false caso contrario.\r\n\r\npub fn es_primo(num: i32) -\u003e bool {\r\n  let mut es_primo = true;\r\n  if num \u003c= 1 {\r\n    es_primo = false;\r\n  }\r\n\r\n  for i in 2..num {\r\n    if num % i == 0 {\r\n      es_primo = false;\r\n      break;\r\n    }\r\n  }\r\n  es_primo\r\n}\r\n\r\n#[test]\r\nfn test_es_primo() {\r\n    assert_eq!(es_primo(2), true);\r\n    assert_eq!(es_primo(3), true);\r\n    assert_eq!(es_primo(4), false);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej03.rs"],"content":"// 3- Definir la función llamada suma_pares que recibe como parámetro un arreglo de\r\n// números enteros y retorna la suma de los números pares.\r\n\r\npub fn suma_pares(arr: \u0026[i32]) -\u003e i32 {\r\n  let mut suma = 0;\r\n  for elemento in arr{\r\n    if elemento % 2 == 0{\r\n      suma += elemento;\r\n    }\r\n  }\r\n  suma\r\n}\r\n\r\n#[test]\r\nfn test_suma_pares() {\r\n    let numeros = [1,2,3,4,5,6];\r\n    let suma = suma_pares(\u0026numeros);\r\n    assert_eq!(suma, 12);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej04.rs"],"content":"// 4- Definir la función llamada cantidad_impares que recibe como parámetro un arreglo de\r\n// números enteros y retorna la cantidad de números impares\r\n\r\npub fn cantidad_impares(arr: \u0026[i32]) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if elemento % 2 != 0 {\r\n      cantidad += 1;\r\n    }\r\n  }\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_impares() {\r\n  let numeros = [1, 2, 3, 4, 5, 6];\r\n  let cantidad = cantidad_impares(\u0026numeros);\r\n  assert_eq!(cantidad, 3);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej05.rs"],"content":"// 5-Defina la función llamada duplicar_valores que recibe un arreglo de números flotantes y\r\n// retorna un arreglo nuevo con los valores duplicados del parámetro\r\n\r\npub fn duplicar_valores(arr: \u0026[f32]) -\u003e [f32; 5] {\r\n  let mut nuevo_arr = [0.0;5];\r\n  for i in 0..arr.len() {\r\n    nuevo_arr[i] = arr[i]*2.00;\r\n  }\r\n  nuevo_arr\r\n}\r\n\r\n#[test]\r\nfn test_duplicar_valores() {\r\n  let numeros = [1.0, 2.0, 3.0, 4.0, 5.0];\r\n  let duplicados = duplicar_valores(\u0026numeros);\r\n  assert_eq!(duplicados, [2.0, 4.0, 6.0, 8.0, 10.0]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej06.rs"],"content":"// 6-Definir la función llamada longitud_de_cadenas que recibe un arreglo de String y retorna\r\n// un arreglo con la longitud de las cadenas del parámetro, correspondiéndose en posición del\r\n// arreglo\r\n\r\npub fn longitud_de_cadenas\u003cconst N: usize\u003e(arr: \u0026[String]) -\u003e [usize;N] {\r\n  let mut nuevo_arr = [0; N];\r\n  for i in 0..arr.len() {\r\n    nuevo_arr[i] = arr[i].len();\r\n  }\r\n  nuevo_arr\r\n}\r\n\r\n#[test]\r\nfn test_longitud_de_cadenas() {\r\n  let cadenas = [\"hola\".to_string(), \"mundo\".to_string(), \"como\".to_string(), \"estas\".to_string()];\r\n  let longitudes = longitud_de_cadenas(\u0026cadenas);\r\n  assert_eq!(longitudes, [4, 5, 4, 5]);\r\n  assert_ne!(longitudes, [4, 5, 4, 6]);\r\n}\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej07.rs"],"content":"// -Definir la función llamada cantidad_de_mayores que recibe como parámetro un arreglo\r\n// de números enteros y un número entero llamado límite. Esta función retorna la cantidad de\r\n// números mayores al límite que tiene el arreglo.\r\n\r\npub fn cantidad_de_mayores(arr: \u0026[i32], limite: i32) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if *elemento \u003e limite { // el asterisco es para desreferenciar y comparar con el limite, ya que el array es una referencia\r\n      cantidad += 1;\r\n    }\r\n  }\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_de_mayores() {\r\n  let numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n  let limite = 5;\r\n  let cantidad = cantidad_de_mayores(\u0026numeros, limite);\r\n  assert_eq!(cantidad, 5);\r\n  assert_ne!(cantidad, 4);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej08.rs"],"content":"// 8- Definir la función llamada sumar_arreglos que recibe 2 arreglos del mismo tamaño de\r\n// números flotantes y retorna un nuevo arreglo que contiene la suma de los elementos de los\r\n// arreglos pasados por parámetro, correspondiendose el resultado con cada posición de los\r\n// arreglos pasados por parámetro\r\n\r\npub fn sumar_arreglos\u003cconst N: usize\u003e(arr1: \u0026[f32], arr2: \u0026[f32]) -\u003e [f32; N] {\r\n  let mut nuevo_arr = [0.0; N];\r\n  for i in 0..arr1.len() {\r\n    nuevo_arr[i] = arr1[i] + arr2[i];\r\n  }\r\n  nuevo_arr\r\n}\r\n\r\n#[test]\r\nfn test_sumar_arreglos() {\r\n  let arr1 =[1.0, 2.0, 3.0, 4.0, 5.0];\r\n  let arr2 = [2.0, 3.0, 4.0, 5.0, 6.0];\r\n  let resultado = sumar_arreglos(\u0026arr1, \u0026arr2);\r\n  assert_eq!(resultado, [3.0, 5.0, 7.0, 9.0, 11.0]);\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej09.rs"],"content":"// 9-Definir la función llamada cantidad_en_rango que recibe 3 parámetros: 1 arreglo de\r\n// enteros, un número entero llamado inferior y otro número entero llamado superior. Esta\r\n// función retorna la cantidad de números del arreglo que están entre el rango de los\r\n// parámetros inferior y superior inclusive.\r\n\r\npub fn cantidad_en_rango(arr: \u0026[i32], inferior: i32, superior:i32) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if *elemento \u003e= inferior \u0026\u0026 *elemento \u003c=superior \r\n      {\r\n        cantidad += 1;\r\n      }\r\n  }\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_en_rango() {\r\n  let numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n  let inferior = 5;\r\n  let superior = 8;\r\n  let cantidad = cantidad_en_rango(\u0026numeros, inferior, superior);\r\n  assert_eq!(cantidad, 4);\r\n  assert_ne!(cantidad, 5);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej10.rs"],"content":"// 10-Definir la función llamada cantidad_de_cadenas_mayor_a que recibe como parámetros\r\n// un arreglo de String y un entero llamado límite. Esta función retorna la cantidad de Strings\r\n// del arreglo que son de longitud mayor al parámetro límite\r\n\r\n\r\npub fn cantidad_de_cadenas_mayor_a(arr: \u0026[String], limite: i32) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if elemento.len() \u003e limite as usize { // Convertir limite a usize para comparar con la longitud de la cadena// consultar.\r\n      cantidad += 1;\r\n    }\r\n  }\r\n\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_de_cadenas_mayor_a() {\r\n  let cadenas = [\"hola\".to_string(), \"mundo\".to_string(), \"como\".to_string(), \"estas\".to_string(), \"hoy\".to_string()];\r\n  let limite = 4;\r\n  let cantidad = cantidad_de_cadenas_mayor_a(\u0026cadenas, limite);\r\n  assert_eq!(cantidad, 2);\r\n  assert_ne!(cantidad, 3); // cambia el valor esperado para que falle el test\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej11.rs"],"content":"// 11-Definir la función llamada multiplicar_valores que recibe como parámetro un arreglo de\r\n// enteros y otro número entero llamado factor. Esta función multiplica los valores del arreglo\r\n// por el parámetro factor modificándolo.\r\n\r\npub fn multiplicar_valores(arr: \u0026mut [i32], factor: i32) {\r\n    for elemento in arr {\r\n        *elemento *= factor; // * significa que estamos desreferenciando el puntero para acceder al valor;\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_multiplicar_valores() {\r\n    let mut numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    let factor = 2;\r\n    multiplicar_valores(\u0026mut numeros, factor);\r\n    assert_eq!(numeros, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\r\n    assert_ne!(numeros, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej12.rs"],"content":"// 12-Definir una función llamada reemplazar_pares que recibe un arreglo de enteros y\r\n// reemplaza todos los números pares por -1.\r\n\r\npub fn reemplazar_pares(arr: \u0026mut [i32]) {\r\n    for elemento in arr {\r\n        if *elemento % 2 == 0 {\r\n            *elemento = -1;\r\n        }\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_reemplazar_pares() {\r\n    let mut numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    reemplazar_pares(\u0026mut numeros);\r\n    assert_eq!(numeros, [1, -1, 3, -1, 5, -1, 7, -1, 9, -1]);\r\n    assert_ne!(numeros, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej13.rs"],"content":"// 13-Definir una función llamada ordenar_nombres que recibe un arreglo de String y los\r\n// ordena en orden alfabético.\r\n\r\npub fn ordenar_nombres(arr: \u0026mut [String]) {\r\n    arr.sort();\r\n}\r\n#[test]\r\nfn test_ordenar_nombres() {\r\n    let mut nombres = [\"Juan\".to_string(), \"Ana\".to_string(), \"Pedro\".to_string(), \"Maria\".to_string(), \"Luis\".to_string()];\r\n    ordenar_nombres(\u0026mut nombres);\r\n    assert_eq!(nombres, [\"Ana\", \"Juan\", \"Luis\", \"Maria\", \"Pedro\"]);\r\n    assert_ne!(nombres, [\"Juan\", \"Ana\", \"Pedro\", \"Maria\", \"Luis\"]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej14.rs"],"content":"// 14-Definir una función llamada incrementar que recibe como parámetro un número flotante\r\n// e incrementa en 1 su valor.\r\n\r\npub fn incrementar(numero :f32 ) -\u003e f32 {\r\n    numero + 1.0\r\n}\r\n\r\n#[test]\r\nfn test_incrementar() {\r\n    let numero = 5.0;\r\n    let resultado = incrementar(numero);\r\n    assert_eq!(resultado, 6.0);\r\n    assert_ne!(resultado, 5.0);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","mod.rs"],"content":"// pub mod ej01;\r\n// pub mod ej02;\r\n// pub mod ej03;\r\n// pub mod ej04;\r\n// pub mod ej05;\r\n// pub mod ej06;\r\n// pub mod ej07;\r\n// pub mod ej08;\r\n// pub mod ej09;\r\n// pub mod ej10;\r\n// pub mod ej11;\r\n// pub mod ej12;\r\n// pub mod ej13;\r\n// pub mod ej14;","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej01.rs"],"content":"// 1- Escribir un programa que defina una estructura Persona que tenga campos para el\r\n// nombre, la edad y la dirección(que puede ser nulo al momento de la creación de una\r\n// persona). Para dicha estructura implemente los siguientes métodos:\r\n// ➢ new: que pasando los parámetros correspondientes, crea una Persona y la retorna.\r\n// ➢ to_string: que retorna un string con los datos de la persona concatenados sobre el\r\n// mensaje ejecutado por ej:\r\n// person.to_string() , donde person es una variable del tipo Persona.\r\n// ➢ obtener_edad: retorna la edad de la persona.\r\n// ➢ actualizar_direccion(nueva_direccion)\r\n\r\n\r\nstruct Persona {\r\n  nombre: String,\r\n  edad: u32,\r\n  direccion: Option\u003cString\u003e, // La dirección puede ser nula al momento de la creación de una persona.\r\n}\r\n\r\nimpl Persona {\r\n  fn new (nombre: String, edad: u32, direccion: Option\u003cString\u003e) -\u003e Persona{\r\n    Persona {\r\n      nombre,\r\n      edad,\r\n      direccion,\r\n    }\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n     let mut result: String = format!(\"nombre: {}, Edad: {}\", self.nombre, self.edad);\r\n     match \u0026self.direccion { //\u0026 es para tomar la referencia de la dirección\r\n        Some(dir) =\u003e result += \u0026format!(\", Direccion: {}\", dir),\r\n        None =\u003e result += \", Direccion: No especificada\",\r\n     }\r\n      result\r\n  }\r\n\r\n  fn obtener_edad(\u0026self) -\u003e u32 {\r\n    return self.edad\r\n  }\r\n\r\n  fn actualizar_direccion(\u0026mut self, nueva_direccion: String) {\r\n    self.direccion = Some(nueva_direccion);\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod persona_tests {\r\n  use super::Persona;\r\n  #[test]\r\n  fn test_new_persona(){\r\n    let persona = Persona::new(\r\n      \"Nicolas\".to_string(),\r\n      35,\r\n      Some(\"Calle 41 682\".to_string()),\r\n    );\r\n\r\n    assert_eq!(persona.nombre, \"Nicolas\".to_string());\r\n    assert_eq!(persona.edad, 35);\r\n    assert_eq!(persona.direccion, Some(\"Calle 41 682\".to_string()));\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_new_persona_sin_direccion() {\r\n    let persona = Persona::new(\r\n      \"Nicolas Carrica\".to_string(),\r\n      35,\r\n      None,\r\n    );\r\n    \r\n    assert_eq!(persona.nombre, \"Nicolas Carrica\");\r\n    assert_eq!(persona.edad, 35);\r\n    assert_eq!(persona.direccion, None);\r\n  }\r\n  #[test]\r\n  fn test_to_string_con_direccion() {\r\n    let persona = Persona::new(\r\n      \"Nico Carrica\".to_string(),\r\n      34,\r\n      Some(\"Calle 119 43\".to_string()),\r\n    );\r\n      \r\n    let salida = \"nombre: Nico Carrica, Edad: 34, Direccion: Calle 119 43\";\r\n    assert_eq!(persona.to_string(), salida);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_edad(){\r\n    let persona = Persona {\r\n      nombre: \"Nicolas\".to_string(),\r\n      edad: 34,\r\n      direccion: None,\r\n    };\r\n\r\n    let edad = persona.obtener_edad();\r\n    assert_eq!(edad,34)\r\n  }\r\n  #[test]\r\n  fn test_actualizar_direccion_none(){\r\n    let mut persona = Persona {\r\n      nombre: \"Nicolas\".to_string(),\r\n      edad: 34,\r\n      direccion: None,\r\n    };\r\n    persona.actualizar_direccion(\"Calle 119\".to_string());\r\n\r\n    assert_eq!(persona.direccion, Some(\"Calle 119\".to_string()));\r\n  }\r\n\r\n  #[test]\r\n  fn test_actualizar_direccion_existente(){\r\n    let mut persona = Persona {\r\n      nombre: \"Nicolas\".to_string(),\r\n      edad:34,\r\n      direccion: Some(\"Calle 41\".to_string()),\r\n    };\r\n\r\n    persona.actualizar_direccion(\"Calle 119\".to_string());\r\n    assert_eq!(persona.direccion, Some(\"Calle 119\".to_string()));\r\n  }\r\n\r\n\r\n \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej02.rs"],"content":"// 2- Escribir un programa que defina la estructura Rectángulo que tenga campos para la \r\n// longitud y el ancho. Para dicha estructura implemente los siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Rectángulo y lo \r\n// retorna. \r\n// ➢  calcular_area: calcular el área y la retorna. \r\n// ➢  calcular_perimetro: calcula el perímetro y lo retorna. \r\n// ➢  es_cuadrado: retorna true si es cuadrado, false caso contrario\r\n#[derive(Clone, Debug)]\r\nstruct Rectangulo {\r\n  longitud: f32,\r\n  ancho: f32,\r\n}\r\n\r\nimpl Rectangulo {\r\n  fn new (longitud: f32, ancho: f32) -\u003e Rectangulo{\r\n    Rectangulo { longitud, ancho}\r\n  }\r\n\r\n  fn calcular_area(\u0026self) -\u003e f32 {\r\n    return self.ancho*self.longitud;\r\n  }\r\n\r\n  fn calcular_perimetro(\u0026self) -\u003e f32 {\r\n    return (self.ancho*2.0) + (self.longitud*2.0);\r\n  }\r\n\r\n  fn es_cuadrado(\u0026self) -\u003e bool {\r\n    return self.ancho == self.longitud;\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_rectangulo{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new(){\r\n    let rect = Rectangulo::new(5.0, 3.0);\r\n    assert_eq!(rect.longitud, 5.0);\r\n    assert_eq!(rect.ancho, 3.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_area(){\r\n    let rect = Rectangulo::new(5.0,3.0);\r\n    assert_eq!(rect.calcular_area(),15.0);\r\n  }\r\n\r\n  //test para un triangulo sin lados, debe dar error\r\n  #[test]\r\n  fn test_calcular_area_sin_lados(){\r\n    let rect = Rectangulo::new(0.0,0.0);\r\n    assert_eq!(rect.calcular_area(),0.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_perimetro(){\r\n    let rect = Rectangulo::new(5.0, 3.0);\r\n    assert_eq!(rect.calcular_perimetro(), 16.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_es_cuadrado(){\r\n    let rect1 = Rectangulo::new(4.0,4.0);\r\n    let rect2 = Rectangulo::new(2.0,5.0);\r\n    assert_eq!(rect1.es_cuadrado(), true);\r\n    assert_eq!(rect2.es_cuadrado(), false);\r\n  }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej03.rs"],"content":"// 3- Escribir un programa que defina una estructura Fecha que tenga campos para el día, el \r\n// mes y el año. Para dicha estructura implemente los siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea una Fecha y la retorna. \r\n// ➢  es_fecha_valida: retorna true si es una fecha válida, false caso contrario.//tenga en \r\n// cuenta los años bisiestos también. \r\n// ➢  es_bisiesto: retorna true si el año de la fecha pertenece a un año bisiesto. \r\n// ➢  sumar_dias(dias): suma la cantidad de días a la fecha, modificándose \r\n// ➢  restar_dias(dias): resta la cantidad de días a la fecha, modificándose \r\n// ➢  es_mayor(una_fecha): que retorna true si la fecha que recibe el mensaje es mayor a \r\n// la fecha pasada por parámetro. \r\n\r\n#[derive(Debug, Clone)]\r\npub struct Fecha {\r\n    dia: u32,\r\n    mes: u32,\r\n    anio: u32,\r\n}\r\n\r\nimpl Fecha {\r\n  pub fn new(dia: u32, mes: u32, anio: u32) -\u003e Fecha {\r\n    Fecha { dia, mes, anio }\r\n  }\r\n\r\n  fn es_bisiesto(\u0026self) -\u003e bool {\r\n    let estado: bool = (self.anio % 4 == 0) \u0026\u0026 (self.anio % 100 != 0) || (self.anio % 400 == 0);\r\n    return estado;\r\n  }\r\n\r\n  //helper para contar los dias que tiene el mes;\r\n  fn cantidad_de_dias(\u0026self, mes:u32) -\u003e u32 {\r\n    let dias_del_mes: u32 = match mes {\r\n      1 | 3 | 5 | 7 | 8 | 10 | 12 =\u003e 31,\r\n      4 | 6 | 9 | 11 =\u003e 30,\r\n      2 =\u003e {\r\n        if self.es_bisiesto() {\r\n          29\r\n        } else {\r\n          28\r\n        }\r\n      }\r\n      _=\u003e 0,\r\n    };\r\n\r\n    dias_del_mes\r\n  }\r\n\r\n  pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n    let mut estado: bool = false;\r\n    if self.mes \u003e 0 \u0026\u0026 self.mes \u003c 13 \u0026\u0026 self.anio \u003e 0 {\r\n      let dias_del_mes: u32 = self.cantidad_de_dias(self.mes);\r\n      estado = dias_del_mes !=0 \u0026\u0026 (self.dia \u003e= 1 \u0026\u0026 self.dia \u003c= dias_del_mes);\r\n    }\r\n    estado\r\n  }\r\n\r\n  pub fn sumar_dias(\u0026mut self, dias: u32){\r\n    let mut dias_del_mes = self.cantidad_de_dias(self.mes);\r\n    self.dia += dias;\r\n\r\n     // Mientras el dia actual sea mayor que la cantidad de dias en el mes actual\r\n    while self.dia \u003e dias_del_mes{\r\n      // Se le restan la cantidad de dias al mes actual\r\n      self.dia -= dias_del_mes;\r\n      // avanza al siguiente mes\r\n      self.mes+=1;\r\n      // si pasamos el mes doce, se incrementa el año y se pasa al mes 1\r\n      if self.mes \u003e 12{\r\n        self.mes=1;\r\n        self.anio+=1;\r\n      }\r\n      // se actualizan los dias del nuevo mes\r\n      dias_del_mes = self.cantidad_de_dias(self.mes);\r\n    } \r\n  }\r\n\r\n  pub fn restar_dias(\u0026mut self, mut dias: u32){\r\n    // Mientras haya días para restar\r\n    while dias !=0 {\r\n      // Si la cantidad de dias a restar es mayor o igual que el dia actual\r\n      if dias \u003e= self.dia {\r\n        dias -= self.dia;\r\n        // Retrocedemos al mes anterior\r\n        self.mes -= 1;\r\n        // Si el mes es menor que 1, retrocedemos al año anterior\r\n        if self.mes \u003c 1{\r\n          self.mes = 12;\r\n          self.anio -= 1;\r\n        }\r\n        // Actualizamos la cantidad de dias en el nuevo mes\r\n        self.dia = self.cantidad_de_dias(self.mes);\r\n      } else {\r\n        // Si la cantidad de dias a restar es menor que el dia actual,\r\n        // simplemente restamos esa cantidad de días\r\n        self.dia -= dias;\r\n        dias = 0; // Ya no quedan dias por restar\r\n      }\r\n    }\r\n  }\r\n\r\n  pub fn es_mayor(\u0026self, otra_fecha: \u0026Fecha) -\u003e bool {\r\n    let mut mayor: bool = false;\r\n    if self.anio \u003e otra_fecha.anio {\r\n        mayor = true;\r\n    } else if self.anio == otra_fecha.anio \u0026\u0026 self.mes \u003e otra_fecha.mes {\r\n        mayor = true;\r\n    } else if self.anio == otra_fecha.anio\r\n        \u0026\u0026 self.mes == otra_fecha.mes\r\n        \u0026\u0026 self.dia \u003e otra_fecha.dia\r\n    {\r\n        mayor = true;\r\n    }\r\n    mayor\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  pub fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_fecha{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new(){\r\n    let fecha = Fecha::new(17,12,1990);\r\n    assert_eq!(fecha.dia, 17);\r\n    assert_eq!(fecha.mes, 12);\r\n    assert_eq!(fecha.anio, 1990);\r\n  }\r\n\r\n  #[test]\r\n  fn test_es_biciesto(){\r\n    let fecha1 = Fecha::new(1, 1, 2020); //divisible x4 y no por 100\r\n    assert_eq!(fecha1.es_bisiesto(), true);\r\n\r\n    let fecha2 = Fecha::new(1, 1, 1900); //divisible x 100, no por 400. No bisiesto.\r\n    assert_eq!(fecha2.es_bisiesto(), false);\r\n\r\n    let fecha3 = Fecha::new(1, 1, 2000); // divisible x 400. biciesto.\r\n    assert_eq!(fecha3.es_bisiesto(), true);\r\n\r\n    let fecha4 = Fecha::new(1, 1, 2023); // no divisible x4. No biciesto.\r\n    assert_eq!(fecha4.es_bisiesto(), false);\r\n  }\r\n\r\n  #[test]\r\n  fn test_cantidad_dias(){\r\n    let fecha = Fecha::new(1, 1, 2023);\r\n    assert_eq!(fecha.cantidad_de_dias(1), 31); // enero\r\n    assert_eq!(fecha.cantidad_de_dias(3), 31); // Marzo\r\n    assert_eq!(fecha.cantidad_de_dias(5), 31); // Mayo\r\n    assert_eq!(fecha.cantidad_de_dias(7), 31); // Julio\r\n    assert_eq!(fecha.cantidad_de_dias(8), 31); // Agosto\r\n    assert_eq!(fecha.cantidad_de_dias(10), 31); // Octubre\r\n    assert_eq!(fecha.cantidad_de_dias(12), 31); // Diciembre\r\n\r\n    assert_eq!(fecha.cantidad_de_dias(4), 30); // abril\r\n    assert_eq!(fecha.cantidad_de_dias(6), 30); // Junio\r\n    assert_eq!(fecha.cantidad_de_dias(9), 30); // Septiembre\r\n    assert_eq!(fecha.cantidad_de_dias(11), 30); // Noviembre\r\n\r\n    assert_eq!(fecha.cantidad_de_dias(2), 28); // Febrero\r\n\r\n    // Febrero en año bisiesto\r\n    let fecha3 = Fecha::new(1, 2, 2020);\r\n    assert_eq!(fecha3.cantidad_de_dias(2), 29);\r\n\r\n    // Mes inválido\r\n    assert_eq!(fecha.cantidad_de_dias(13), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_es_fecha_valida(){\r\n    let fecha1 = Fecha::new(15, 10, 2023);\r\n    assert_eq!(fecha1.es_fecha_valida(), true);\r\n\r\n    let fecha2 = Fecha::new(32, 1, 2023);\r\n    assert_eq!(fecha2.es_fecha_valida(), false);\r\n\r\n    let fecha3 = Fecha::new(1, 0, 2022);\r\n    assert!(!fecha3.es_fecha_valida());\r\n  }\r\n\r\n  #[test]\r\n  fn test_sumar_dias(){\r\n    let mut fecha1 = Fecha::new(15, 10, 2023);\r\n    fecha1.sumar_dias(5);\r\n    assert_eq!(fecha1.dia,20);\r\n    assert_eq!(fecha1.mes, 10);\r\n    assert_eq!(fecha1.anio, 2023);\r\n\r\n    // Sumar días para cambiar de mes\r\n    let mut fecha2 = Fecha::new(28, 2, 2023);\r\n    fecha2.sumar_dias(5);\r\n    assert_eq!(fecha2.dia, 5);\r\n    assert_eq!(fecha2.mes, 3);\r\n    assert_eq!(fecha2.anio, 2023);\r\n\r\n    // Sumar días para cambiar de año\r\n    let mut fecha3 = Fecha::new(30, 12, 2023);\r\n    fecha3.sumar_dias(5);\r\n    assert_eq!(fecha3.dia, 4);\r\n    assert_eq!(fecha3.mes, 1);\r\n    assert_eq!(fecha3.anio, 2024);\r\n\r\n    // Sumar muchos días (cruzando varios meses y años)\r\n    let mut fecha4 = Fecha::new(1, 1, 2023);\r\n    fecha4.sumar_dias(365 + 31 + 29);  // 1 año + enero y febrero de 2024 (año bisiesto)\r\n    assert_eq!(fecha4.dia, 1);\r\n    assert_eq!(fecha4.mes, 3);\r\n    assert_eq!(fecha4.anio, 2024);\r\n  }\r\n  \r\n  #[test]\r\n  fn test_restar_dias() {\r\n    // Restar días dentro del mismo mes\r\n    let mut fecha1 = Fecha::new(15, 10, 2023);\r\n    fecha1.restar_dias(5);\r\n    assert_eq!(fecha1.dia, 10);\r\n    assert_eq!(fecha1.mes, 10);\r\n    assert_eq!(fecha1.anio, 2023);\r\n\r\n    // Restar días para cambiar de mes\r\n    let mut fecha2 = Fecha::new(3, 3, 2023);\r\n    fecha2.restar_dias(5);\r\n    assert_eq!(fecha2.dia, 26);\r\n    assert_eq!(fecha2.mes, 2);\r\n    assert_eq!(fecha2.anio, 2023);\r\n\r\n    // Restar días para cambiar de año\r\n    let mut fecha3 = Fecha::new(2, 1, 2023);\r\n    fecha3.restar_dias(5);\r\n    assert_eq!(fecha3.dia, 28);\r\n    assert_eq!(fecha3.mes, 12);\r\n    assert_eq!(fecha3.anio, 2022);\r\n\r\n    // Restar muchos días (cruzando varios meses y años)\r\n    let mut fecha4 = Fecha::new(1, 3, 2024);  // 1 de marzo de 2024 (año bisiesto)\r\n    fecha4.restar_dias(365 + 31 + 29);  // 1 año + enero y febrero de 2024\r\n    assert_eq!(fecha4.dia, 1);\r\n    assert_eq!(fecha4.mes, 1);\r\n    assert_eq!(fecha4.anio, 2023);\r\n  }\r\n\r\n  #[test]\r\n    fn test_es_mayor() {\r\n      // Fechas con años diferentes\r\n      let fecha1 = Fecha::new(1, 1, 2023);\r\n      let fecha2 = Fecha::new(1, 1, 2022);\r\n      assert!(fecha1.es_mayor(\u0026fecha2));\r\n      assert!(!fecha2.es_mayor(\u0026fecha1));\r\n\r\n      // Fechas con mismo año pero diferentes meses\r\n      let fecha3 = Fecha::new(1, 2, 2023);\r\n      let fecha4 = Fecha::new(1, 1, 2023);\r\n      assert!(fecha3.es_mayor(\u0026fecha4));\r\n      assert!(!fecha4.es_mayor(\u0026fecha3));\r\n\r\n      // Fechas con mismo año y mes pero diferentes días\r\n      let fecha5 = Fecha::new(2, 1, 2023);\r\n      let fecha6 = Fecha::new(1, 1, 2023);\r\n      assert!(fecha5.es_mayor(\u0026fecha6));\r\n      assert!(!fecha6.es_mayor(\u0026fecha5));\r\n\r\n      // Fechas iguales\r\n      let fecha7 = Fecha::new(1, 1, 2023);\r\n      let fecha8 = Fecha::new(1, 1, 2023);\r\n      assert!(!fecha7.es_mayor(\u0026fecha8));\r\n      assert!(!fecha8.es_mayor(\u0026fecha7));\r\n    }\r\n\r\n\r\n}","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":25,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":26,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":31,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":32,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":33,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":34,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":36,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":39,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":48,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":49,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":50,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":54,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":57,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":64,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":66,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":68,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":79,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":81,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":82,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":84,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":86,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":91,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":95,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":96,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":101,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":102,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":103,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}}],"covered":50,"coverable":54},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej04.rs"],"content":"// 4- Escribir un programa que defina la estructura Triángulo que tenga campos para las \r\n// longitudes de sus tres lados. Para dicha estructura implemente los siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Triángulo y lo retorna. \r\n// ➢  determinar_tipo: retorna el tipo del triángulo, los tipos pueden ser equilátero, \r\n// isósceles o escaleno. \r\n// ➢  calcular_area: calcular el área y la retorna. \r\n// ➢  calcular_perimetro: calcula el perímetro y lo retorna.\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nenum Tipo {\r\n  Equilatero,\r\n  Isosceles,\r\n  Escaleno,\r\n}\r\n\r\nstruct Triangulo{\r\n  lado1: f32,\r\n  lado2: f32,\r\n  lado3: f32,\r\n}\r\n\r\nimpl Triangulo {\r\n  fn new(lado1: f32, lado2: f32, lado3:f32)-\u003e Triangulo {\r\n    Triangulo { lado1, lado2, lado3 }\r\n  }\r\n\r\n  \r\n  fn determinar_tipo(\u0026self) -\u003e Tipo {\r\n    if self.lado1==self.lado2 \u0026\u0026 self.lado2==self.lado3{\r\n      Tipo::Equilatero\r\n    }\r\n    else if self.lado1 == self.lado2 || self.lado1==self.lado3 || self.lado2==self.lado3{\r\n      Tipo::Isosceles\r\n    }\r\n    else {\r\n      Tipo::Escaleno\r\n    }\r\n  }\r\n\r\n  fn calcular_area(\u0026self) -\u003e f32 {\r\n    let semi_perimetro = (self.lado1 + self.lado2 + self.lado3) / 2.0;\r\n\r\n    let area = (semi_perimetro * (semi_perimetro - self.lado1) * (semi_perimetro - self.lado2) * (semi_perimetro - self.lado3)).sqrt();\r\n\r\n    return area;\r\n  }\r\n\r\n  fn calcular_perimetro(\u0026self) -\u003e f32 {\r\n    return self.lado1 + self.lado2 + self.lado3;\r\n  }\r\n}\r\n\r\n\r\n\r\n#[cfg(test)]\r\nmod test_triangulo {\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let triangulo = Triangulo::new(3.0, 4.0, 5.0);\r\n    assert_eq!(triangulo.lado1, 3.0);\r\n    assert_eq!(triangulo.lado2, 4.0);\r\n    assert_eq!(triangulo.lado3, 5.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_determinar_tipo(){\r\n    let triangulo1 = Triangulo::new(5.0, 5.0, 5.0);\r\n     assert!(matches!(triangulo1.determinar_tipo(), Tipo::Equilatero));\r\n\r\n    let triangulo2 = Triangulo::new(5.0, 5.0, 8.0);\r\n    assert!(matches!(triangulo2.determinar_tipo(), Tipo::Isosceles));\r\n\r\n    let triangulo3 = Triangulo::new(5.0, 3.0, 8.0);\r\n    assert!(matches!(triangulo3.determinar_tipo(), Tipo::Escaleno));\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_area(){\r\n    let triangulo = Triangulo::new(3.0, 4.0, 5.0);\r\n    assert_eq!(triangulo.calcular_area(), 6.0)\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_perimetro(){\r\n    let triangulo = Triangulo::new(3.0, 4.0, 5.0);\r\n    assert_eq!(triangulo.calcular_perimetro(), 12.0);\r\n  }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej05.rs"],"content":"// 5- Escribir un programa que defina una estructura Producto que tenga campos para el \r\n// nombre, el precio bruto y un número identificatorio. Para dicha estructura implemente los \r\n// siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Producto y lo retorna. \r\n// ➢  calcular_impuestos(porcentaje_de_impuestos): retorna el valor de impuestos sobre \r\n// el precio bruto \r\n// ➢  aplicar_descuento(porcentaje_de_descuento): retorna el valor del porcentaje de \r\n// descuento sobre el precio bruto \r\n// ➢  calcular_precio_total(porcentaje_de_impuestos, porcentaje_descuento): retorna el \r\n// precio total a pagar aplicando impuesto y descuento. Tenga en cuenta que los \r\n// parámetros son opcionales.\r\n\r\nstruct Producto {\r\n  nombre: String,\r\n  precio: f32,\r\n  id: u32,\r\n}\r\n\r\nimpl Producto {\r\n  fn new(nombre: String, precio: f32, id: u32) -\u003e Producto {\r\n    Producto{\r\n      nombre,\r\n      precio,\r\n      id\r\n    }\r\n  }\r\n\r\n  fn calcular_impuestos(\u0026self, porcentaje_de_impuestos: f32) -\u003e f32 {\r\n    let valor_impuestos: f32 = (self.precio * porcentaje_de_impuestos)/100.0;\r\n    valor_impuestos\r\n  }\r\n\r\n  fn aplicar_descuento(\u0026self, porcentaje_de_descuento: f32) -\u003e f32 {\r\n    return (self.precio * porcentaje_de_descuento)/100.0;\r\n  }\r\n\r\n  fn calcular_precio_total(\r\n    \u0026self, \r\n    porcentaje_de_impuestos: Option\u003cf32\u003e, \r\n    porcentaje_de_descuento: Option\u003cf32\u003e\r\n  ) -\u003e f32 {\r\n    let mut precio_total: f32 = self.precio;\r\n    if let Some(porcentaje) = porcentaje_de_impuestos {\r\n      precio_total += self.calcular_impuestos(porcentaje);\r\n    } \r\n    if let Some(porcentaje) = porcentaje_de_descuento {\r\n      precio_total-= self.aplicar_descuento(porcentaje);\r\n    }\r\n\r\n    return precio_total;\r\n  }\r\n\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod producto_tests {\r\n  use super::*;\r\n  #[test]\r\n  fn test_new() {\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n    assert_eq!(producto.nombre, \"Laptop\");\r\n    assert_eq!(producto.precio, 1000.0);\r\n    assert_eq!(producto.id, 12345);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_impuestos(){\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n\r\n    let impuestos = producto.calcular_impuestos(21.0);\r\n    assert_eq!(impuestos, 210.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_aplicar_descuento(){\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n\r\n    let descuento = producto.aplicar_descuento(10.0);\r\n    assert_eq!(descuento, 100.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_precio_total(){\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n\r\n    let precio_total = producto.calcular_precio_total(Some(21.0), Some(10.0));\r\n    assert_eq!(precio_total, 1110.0);\r\n\r\n    let precio_solo_impuesto = producto.calcular_precio_total(Some(21.0), None);\r\n    assert_eq!(precio_solo_impuesto, 1210.0);\r\n  }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej06 - copia.rs"],"content":"// Escribir un programa que defina una estructura Estudiante que tenga campos para el \r\n// nombre, el número de identificación y las calificaciones de exámenes. De cada Examen se \r\n// conoce el nombre de la materia y la nota. Para dichas estructuras implemente los siguientes \r\n// métodos: \r\n \r\n// ❖  Examen: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Examen y lo \r\n// retorna. \r\n// ❖  Estudiante: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Estudiante y lo \r\n// retorna. \r\n// ➢  obtener_promedio: retorna el promedio de las notas. \r\n// ➢  obtener_calificacion_mas_alta: retorna la nota más alta. \r\n// ➢  obtener_calificacion_mas_baja: retorna la nota más baja. \r\n \r\n// Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n\r\nstruct Examen {\r\n  nombre_de_materia: String,\r\n  nota: f32,\r\n}\r\n\r\nimpl Examen {\r\n  fn new (nombre_de_materia: String, nota: f32) -\u003e Examen{\r\n    Examen {\r\n      nombre_de_materia,\r\n      nota,\r\n    }\r\n  }\r\n} \r\nstruct Estudiante{\r\n  nombre_estudiante: String,\r\n  id: u32,\r\n  calificaciones: Vec\u003cExamen\u003e\r\n}\r\n\r\nstruct Informe {\r\n  nombre_estudiante: String,\r\n  examenes_rendidos: u32,\r\n  promedio_notas: f32,\r\n  nota_mas_alta: f32,\r\n  materia_mas_alta: String,\r\n  nota_mas_baja: f32,\r\n  materia_mas_baja: String,\r\n}\r\n\r\nimpl Informe {\r\n  fn new(nombre_estudiante: String, examenes_rendidos: u32, promedio_notas: f32, nota_mas_alta: f32, materia_mas_alta: String, nota_mas_baja: f32, materia_mas_baja: String) -\u003e Informe{\r\n    Informe {\r\n      nombre_estudiante,\r\n      examenes_rendidos,\r\n      promedio_notas,\r\n      nota_mas_alta,\r\n      materia_mas_alta,\r\n      nota_mas_baja,\r\n      materia_mas_baja\r\n    }\r\n\r\n  }\r\n}\r\n\r\nimpl Estudiante{\r\n  fn new(nombre_estudiante: String, id: u32, calificaciones: Vec\u003cExamen\u003e)-\u003e Estudiante {\r\n    Estudiante{\r\n      nombre_estudiante,\r\n      id,\r\n      calificaciones,\r\n    }\r\n  }\r\n\r\n  fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut suma: f32 = 0.0;\r\n    for examen in \u0026self.calificaciones{\r\n      suma+=examen.nota;\r\n    }\r\n    let dim_f = self.calificaciones.len();\r\n    Some(suma/dim_f as f32)\r\n  }\r\n\r\n  fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    \r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut max:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e max {\r\n        max = examen.nota;\r\n      }\r\n    }\r\n    return Some(max);\r\n  }\r\n\r\n  fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut min:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003c min {\r\n        min = examen.nota;\r\n      }\r\n    }\r\n    return Some(min);\r\n  }\r\n  \r\n  fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None\r\n    }\r\n    let mut nota_min: f32 = self.calificaciones[0].nota;\r\n    let mut nota_max: f32 = self.calificaciones[0].nota;\r\n    \r\n    let mut informe_est = Informe::new(\"\".to_string(), 0, 0.0, 0.0, \"\".to_string(), 0.0, \"\".to_string());\r\n    informe_est.nombre_estudiante = self.nombre_estudiante.clone();\r\n    informe_est.examenes_rendidos = self.calificaciones.len() as u32;\r\n    match {\r\n      self.obtener_promedio()\r\n    } {\r\n      Some(promedio) =\u003e informe_est.promedio_notas = promedio,\r\n      None =\u003e return None\r\n    }\r\n\r\n      for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e nota_max {\r\n        nota_max = examen.nota;\r\n        informe_est.nota_mas_alta = examen.nota;\r\n        informe_est.materia_mas_alta = examen.nombre_de_materia.clone()\r\n      }\r\n      if examen.nota \u003c nota_min {\r\n        nota_min = examen.nota;\r\n        informe_est.nota_mas_baja = examen.nota;\r\n        informe_est.materia_mas_baja = examen.nombre_de_materia.clone()\r\n      }\r\n    }\r\n\r\n    return Some(informe_est);\r\n\r\n    // In\r\n\r\n  }\r\n    \r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod estudiante_tests{\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones,\r\n    );\r\n\r\n    assert_eq!(estudiante.nombre_estudiante, \"Nicolas\");\r\n    assert_eq!(estudiante.id, 25458);\r\n    assert_eq!(estudiante.calificaciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_promedio(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_promedio(), Some(7.0));\r\n\r\n    //caso vector vacio\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_promedio(),None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_alta(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 8.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(8.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_alta(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_baja(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 5.0),\r\n      Examen::new(\"Programcion\".to_string(), 9.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(5.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_baja(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    let informe = estudiante.generar_informe();\r\n    \r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej06.rs"],"content":"// Escribir un programa que defina una estructura Estudiante que tenga campos para el \r\n// nombre, el número de identificación y las calificaciones de exámenes. De cada Examen se \r\n// conoce el nombre de la materia y la nota. Para dichas estructuras implemente los siguientes \r\n// métodos: \r\n \r\n// ❖  Examen: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Examen y lo \r\n// retorna. \r\n// ❖  Estudiante: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Estudiante y lo \r\n// retorna. \r\n// ➢  obtener_promedio: retorna el promedio de las notas. \r\n// ➢  obtener_calificacion_mas_alta: retorna la nota más alta. \r\n// ➢  obtener_calificacion_mas_baja: retorna la nota más baja. \r\n \r\n// Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n\r\nstruct Examen {\r\n  nombre_de_materia: String,\r\n  nota: f32,\r\n}\r\n\r\nimpl Examen {\r\n  fn new (nombre_de_materia: String, nota: f32) -\u003e Examen{\r\n    Examen {\r\n      nombre_de_materia,\r\n      nota,\r\n    }\r\n  }\r\n} \r\nstruct Estudiante{\r\n  nombre_estudiante: String,\r\n  id: u32,\r\n  calificaciones: Vec\u003cExamen\u003e\r\n}\r\n\r\nstruct Informe {\r\n  nombre_estudiante: String,\r\n  examenes_rendidos: u32,\r\n  promedio_notas: f32,\r\n  nota_mas_alta: f32,\r\n  materia_mas_alta: String,\r\n  nota_mas_baja: f32,\r\n  materia_mas_baja: String,\r\n}\r\n\r\nimpl Informe {\r\n  fn new(nombre_estudiante: String, examenes_rendidos: u32, promedio_notas: f32, nota_mas_alta: f32, materia_mas_alta: String, nota_mas_baja: f32, materia_mas_baja: String) -\u003e Informe{\r\n    Informe {\r\n      nombre_estudiante,\r\n      examenes_rendidos,\r\n      promedio_notas,\r\n      nota_mas_alta,\r\n      materia_mas_alta,\r\n      nota_mas_baja,\r\n      materia_mas_baja\r\n    }\r\n\r\n  }\r\n}\r\n\r\nimpl Estudiante{\r\n  fn new(nombre_estudiante: String, id: u32, calificaciones: Vec\u003cExamen\u003e)-\u003e Estudiante {\r\n    Estudiante{\r\n      nombre_estudiante,\r\n      id,\r\n      calificaciones,\r\n    }\r\n  }\r\n\r\n  fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut suma: f32 = 0.0;\r\n    for examen in \u0026self.calificaciones{\r\n      suma+=examen.nota;\r\n    }\r\n    let dim_f = self.calificaciones.len();\r\n    Some(suma/dim_f as f32)\r\n  }\r\n\r\n  fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    \r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut max:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e max {\r\n        max = examen.nota;\r\n      }\r\n    }\r\n    return Some(max);\r\n  }\r\n\r\n  fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut min:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003c min {\r\n        min = examen.nota;\r\n      }\r\n    }\r\n    return Some(min);\r\n  }\r\n  \r\n  fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None\r\n    }\r\n    let mut nota_min: f32 = self.calificaciones[0].nota;\r\n    let mut nota_max: f32 = self.calificaciones[0].nota;\r\n    \r\n    let mut informe_est = Informe::new(\"\".to_string(), 0, 0.0, 0.0, \"\".to_string(), 0.0, \"\".to_string());\r\n    informe_est.nombre_estudiante = self.nombre_estudiante.clone();\r\n    informe_est.examenes_rendidos = self.calificaciones.len() as u32;\r\n    match {\r\n      self.obtener_promedio()\r\n    } {\r\n      Some(promedio) =\u003e informe_est.promedio_notas = promedio,\r\n      None =\u003e return None\r\n    }\r\n\r\n      for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e nota_max {\r\n        nota_max = examen.nota;\r\n        informe_est.nota_mas_alta = examen.nota;\r\n        informe_est.materia_mas_alta = examen.nombre_de_materia.clone()\r\n      }\r\n      if examen.nota \u003c nota_min {\r\n        nota_min = examen.nota;\r\n        informe_est.nota_mas_baja = examen.nota;\r\n        informe_est.materia_mas_baja = examen.nombre_de_materia.clone()\r\n      }\r\n    }\r\n\r\n    return Some(informe_est);\r\n\r\n    // In\r\n\r\n  }\r\n    \r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod estudiante_tests{\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones,\r\n    );\r\n\r\n    assert_eq!(estudiante.nombre_estudiante, \"Nicolas\");\r\n    assert_eq!(estudiante.id, 25458);\r\n    assert_eq!(estudiante.calificaciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_promedio(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_promedio(), Some(7.0));\r\n\r\n    //caso vector vacio\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_promedio(),None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_alta(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 8.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(8.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_alta(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_baja(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 5.0),\r\n      Examen::new(\"Programcion\".to_string(), 9.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(5.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_baja(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    let informe = estudiante.generar_informe();\r\n\r\n    assert!(informe.is_some());\r\n    \r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej07.rs"],"content":"// 7- Defina una estructura llamada ConcesionarioAuto donde se conoce el nombre, la \r\n// dirección y tiene una capacidad máxima para albergar X cantidad de autos. De los autos se \r\n// conocen los campos de la marca, modelo, año, precio bruto y  color que pueden ser:rojo, \r\n// verde, azul, amarillo, blanco o negro. \r\n \r\n// Para dichas estructuras implemente los siguientes métodos: \r\n// ❖      ConcesionarioAuto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un \r\n// ConcesionarioAuto y lo retorna. \r\n// ➢  agregar_auto(auto): agrega un auto a la lista de autos que tiene sin superar \r\n// la máxima cantidad para albergarlos y retorna true, en caso de que lo supere \r\n// no lo agrega y retorna false. \r\n// ➢  eliminar_auto(auto): elimina un auto de la lista de autos. \r\n// ➢  buscar_auto(auto): busca un auto y si lo encuentra lo retorna. \r\n// ❖      Auto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Auto y lo \r\n// retorna. \r\n// ➢  calcular_precio: retorna el precio del auto aplicando los siguientes criterios: \r\n// ■  si es de color primario le aplica un recargo del 25%, sino le aplica un \r\n// descuento del 10%. \r\n// ■  si la marca es BMW le aplica un recargo del 15%- \r\n// ■  si el año es menor a 2000 le aplica un descuento del 5%.\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Auto{\r\n  marca: String,\r\n  modelo: String,\r\n  anio: u32,\r\n  precio: f32,\r\n  color: Color,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum Color {\r\n  Rojo,\r\n  Verde,\r\n  Azul,\r\n  Amarillo,\r\n  Blanco,\r\n  Negro,\r\n\r\n }\r\nstruct ConcesionarioAuto {\r\n  nombre: String,\r\n  direccion: String,\r\n  autos: Vec\u003cAuto\u003e,\r\n  capacidad_maxima: usize,\r\n}\r\n\r\nimpl Auto {\r\n  fn new(marca: String, modelo: String, anio: u32, precio: f32, color: Color) -\u003e Auto{\r\n    Auto {\r\n      marca,\r\n      modelo,\r\n      anio,\r\n      precio,\r\n      color\r\n    }\r\n  }\r\n\r\n  fn calcular_precio(\u0026self) -\u003e f32 {\r\n    let mut precio_adcional = match self.color {\r\n      Color::Rojo =\u003e self.precio *1.25,\r\n      Color::Amarillo =\u003e self.precio *1.25,\r\n      Color::Azul =\u003e self.precio *1.25,\r\n      _ =\u003e self.precio *0.9,\r\n        \r\n    };\r\n\r\n    if self.marca == \"BMW\".to_string() {\r\n      precio_adcional+=self.precio*0.15;\r\n    }\r\n\r\n    if self.anio \u003c 2000 {\r\n      precio_adcional-=self.precio*0.05;\r\n    }\r\n\r\n    return precio_adcional;\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl ConcesionarioAuto {\r\n  fn new(nombre: String, direccion: String, capacidad_maxima: usize) -\u003e ConcesionarioAuto{\r\n    ConcesionarioAuto { \r\n      nombre, \r\n      direccion, \r\n      capacidad_maxima,\r\n      //autos: Vec::new(),\r\n      autos:Vec::with_capacity(capacidad_maxima as usize),\r\n      \r\n    }\r\n  }\r\n\r\n  fn agregar_auto(\u0026mut self, auto: Auto) -\u003e bool {\r\n    if self.autos.len() \u003c self.capacidad_maxima {\r\n      self.autos.push(auto);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn eliminar_auto(\u0026mut self, auto: \u0026Auto) -\u003e bool {\r\n    // Usamos una referencia (\u0026Auto) en lugar del valor completo para no copiar todo el Auto\r\n    let posicion = self.autos.iter().position(|a| a.eq(auto)); // |a| a == auto: Es una closure \r\n\r\n    //position devuelve un option/ entonces debo verificar si hay un some \r\n    //si posicion contiene un valor (Some), extrae ese valor y llámalo indice\r\n    if let Some(indice) = posicion {\r\n      self.autos.remove(indice);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\r\n    self.autos.iter().find(|\u0026a| a.eq(auto))\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new_auto(){\r\n    let auto = Auto::new(\r\n      \"Toyota\".to_string(), \r\n      \"Corolla\".to_string(), \r\n      2023, \r\n      10000.0,\r\n      Color::Rojo,\r\n    );\r\n    assert_eq!(auto.marca, \"Toyota\");\r\n    assert_eq!(auto.modelo, \"Corolla\");\r\n    assert_eq!(auto.anio, 2023);\r\n    assert_eq!(auto.precio, 10000.0);\r\n    assert!(matches!(\u0026auto.color, Color::Rojo));\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_precio(){\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n    // Precio inicial: 10000.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final esperado: 12500.0\r\n    assert_eq!(auto1.calcular_precio(),12500.0);\r\n\r\n    // Auto BMW, color no primario (Blanco), año antiguo\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n  \r\n    // Precio inicial: 20000.0\r\n    // Recargo por BMW: 20000.0 * 0.15 = 3000.0\r\n    // Descuento por año \u003c 2000: 20000.0 * 0.05 = 1000.0\r\n    // Descuento por color no primario: 20000.0 * 0.10 = 2000.0\r\n    // Precio final esperado: 20000.0 + 3000.0 - 1000.0 - 2000.0 = 20000.0\r\n    assert_eq!(auto2.calcular_precio(), 20000.0);\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_calculo_precio_incorrecto() {\r\n    // Auto BMW de color primario (Azul) y año 1990\r\n    let auto = Auto::new(\r\n      String::from(\"BMW\"),\r\n      String::from(\"Serie 3\"),\r\n      1990,\r\n      10000.0,\r\n      Color::Azul\r\n    );\r\n  \r\n    // Precio base: 10000.0\r\n    // Recargo por BMW: 10000.0 * 0.15 = 1500.0\r\n    // Descuento por año \u003c 2000: 10000.0 * 0.05 = 500.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final correcto: 10000.0 + 1500.0 - 500.0 + 2500.0 = 13500.0\r\n  \r\n    // Este test fallará porque el valor esperado es incorrecto\r\n    assert_eq!(auto.calcular_precio(), 12000.0); // Valor incorrecto\r\n  }\r\n\r\n  #[test]\r\n  fn test_new_concesionario(){\r\n    let concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    assert_eq!(concesionario.nombre, \"Mi Concesionario\");\r\n    assert_eq!(concesionario.direccion, \"Calle Falsa 123\");\r\n    assert_eq!(concesionario.capacidad_maxima, 10);\r\n    assert_eq!(concesionario.autos.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_consecionario(){\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n    assert_eq!(concesionario.agregar_auto(auto1.clone()), true); // para evitar el owner ship\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert_eq!(concesionario.agregar_auto(auto2.clone()), true);\r\n    assert_eq!(concesionario.autos.len(), 2);\r\n\r\n    assert_eq!(concesionario.eliminar_auto(\u0026auto1), true);\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert!(concesionario.buscar_auto(\u0026auto1).is_none()); // devuelve un option la funcion, entonces usamos is_none()\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_acceso_fuera_de_indice() {\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"AutoMundo\"),\r\n      String::from(\"Av. Principal 123\"),\r\n      2\r\n    );\r\n        \r\n    let auto = Auto::new(\r\n      String::from(\"Ford\"),\r\n      String::from(\"Focus\"),\r\n      2020,\r\n      15000.0,\r\n      Color::Azul\r\n    );\r\n        \r\n    concesionario.agregar_auto(auto);\r\n    let _auto_inexistente = \u0026concesionario.autos[5]; // Índice fuera de rango\r\n    }\r\n\r\n    \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej07v2.rs"],"content":"// 7- Defina una estructura llamada ConcesionarioAuto donde se conoce el nombre, la \r\n// dirección y tiene una capacidad máxima para albergar X cantidad de autos. De los autos se \r\n// conocen los campos de la marca, modelo, año, precio bruto y  color que pueden ser:rojo, \r\n// verde, azul, amarillo, blanco o negro. \r\n \r\n// Para dichas estructuras implemente los siguientes métodos: \r\n// ❖      ConcesionarioAuto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un \r\n// ConcesionarioAuto y lo retorna. \r\n// ➢  agregar_auto(auto): agrega un auto a la lista de autos que tiene sin superar \r\n// la máxima cantidad para albergarlos y retorna true, en caso de que lo supere \r\n// no lo agrega y retorna false. \r\n// ➢  eliminar_auto(auto): elimina un auto de la lista de autos. \r\n// ➢  buscar_auto(auto): busca un auto y si lo encuentra lo retorna. \r\n// ❖      Auto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Auto y lo \r\n// retorna. \r\n// ➢  calcular_precio: retorna el precio del auto aplicando los siguientes criterios: \r\n// ■  si es de color primario le aplica un recargo del 25%, sino le aplica un \r\n// descuento del 10%. \r\n// ■  si la marca es BMW le aplica un recargo del 15%- \r\n// ■  si el año es menor a 2000 le aplica un descuento del 5%.\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Auto{\r\n  marca: String,\r\n  modelo: String,\r\n  anio: u32,\r\n  precio: f32,\r\n  color: Color,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum Color {\r\n  Rojo,\r\n  Verde,\r\n  Azul,\r\n  Amarillo,\r\n  Blanco,\r\n  Negro,\r\n\r\n }\r\nstruct ConcesionarioAuto {\r\n  nombre: String,\r\n  direccion: String,\r\n  autos: Vec\u003cAuto\u003e,\r\n  capacidad_maxima: usize,\r\n}\r\n\r\nimpl Auto {\r\n  fn new(marca: String, modelo: String, anio: u32, precio: f32, color: Color) -\u003e Auto{\r\n    Auto {\r\n      marca,\r\n      modelo,\r\n      anio,\r\n      precio,\r\n      color\r\n    }\r\n  }\r\n\r\n\r\n  fn calcular_precio(\u0026self) -\u003e f32 {\r\n    let mut precio_adcional = match self.color {\r\n      Color::Rojo =\u003e self.precio *1.25,\r\n      Color::Amarillo =\u003e self.precio *1.25,\r\n      Color::Azul =\u003e self.precio *1.25,\r\n      _ =\u003e self.precio *0.9,\r\n        \r\n    };\r\n\r\n    if self.marca == \"BMW\".to_string() {\r\n      precio_adcional+=self.precio*0.15;\r\n    }\r\n\r\n    if self.anio \u003c 2000 {\r\n      precio_adcional-=self.precio*0.05;\r\n    }\r\n\r\n    return precio_adcional;\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl ConcesionarioAuto {\r\n  fn new(nombre: String, direccion: String, capacidad_maxima: usize) -\u003e ConcesionarioAuto{\r\n    ConcesionarioAuto { \r\n      nombre, \r\n      direccion, \r\n      autos: Vec::new(),\r\n      capacidad_maxima,\r\n    }\r\n  }\r\n\r\n  fn agregar_auto(\u0026mut self, auto: Auto) -\u003e bool {\r\n    if self.autos.len() \u003c self.capacidad_maxima {\r\n      self.autos.push(auto);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn eliminar_auto(\u0026mut self, auto: \u0026Auto) -\u003e bool {\r\n    // Usamos una referencia (\u0026Auto) en lugar del valor completo para no copiar todo el Auto\r\n    let mut posicion = 0;\r\n    for i in 0..self.autos.len() {\r\n      if self.autos[i].eq(auto) {\r\n        posicion = i;\r\n        break;\r\n      }\r\n    }\r\n    if posicion \u003c self.autos.len() {\r\n      self.autos.remove(posicion);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\r\n    //self.autos.iter().find(|\u0026a| a== auto)\r\n    for i in 0..self.autos.len() {\r\n      if self.autos[i].eq(auto) {\r\n        return Some(\u0026self.autos[i]);\r\n      }\r\n    }\r\n    None\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new_auto(){\r\n    let auto = Auto::new(\r\n      \"Toyota\".to_string(), \r\n      \"Corolla\".to_string(), \r\n      2023, \r\n      10000.0,\r\n      Color::Rojo,\r\n    );\r\n    assert_eq!(auto.marca, \"Toyota\");\r\n    assert_eq!(auto.modelo, \"Corolla\");\r\n    assert_eq!(auto.anio, 2023);\r\n    assert_eq!(auto.precio, 10000.0);\r\n    assert!(matches!(\u0026auto.color, Color::Rojo));\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_precio(){\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n    // Precio inicial: 10000.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final esperado: 12500.0\r\n    assert_eq!(auto1.calcular_precio(),12500.0);\r\n\r\n    // Auto BMW, color no primario (Blanco), año antiguo\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n  \r\n    // Precio inicial: 20000.0\r\n    // Recargo por BMW: 20000.0 * 0.15 = 3000.0\r\n    // Descuento por año \u003c 2000: 20000.0 * 0.05 = 1000.0\r\n    // Descuento por color no primario: 20000.0 * 0.10 = 2000.0\r\n    // Precio final esperado: 20000.0 + 3000.0 - 1000.0 - 2000.0 = 20000.0\r\n    assert_eq!(auto2.calcular_precio(), 20000.0);\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_calculo_precio_incorrecto() {\r\n    // Auto BMW de color primario (Azul) y año 1990\r\n    let auto = Auto::new(\r\n      String::from(\"BMW\"),\r\n      String::from(\"Serie 3\"),\r\n      1990,\r\n      10000.0,\r\n      Color::Azul\r\n    );\r\n  \r\n    // Precio base: 10000.0\r\n    // Recargo por BMW: 10000.0 * 0.15 = 1500.0\r\n    // Descuento por año \u003c 2000: 10000.0 * 0.05 = 500.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final correcto: 10000.0 + 1500.0 - 500.0 + 2500.0 = 13500.0\r\n  \r\n    // Este test fallará porque el valor esperado es incorrecto\r\n    assert_eq!(auto.calcular_precio(), 12000.0); // Valor incorrecto\r\n  }\r\n\r\n  #[test]\r\n  fn test_new_concesionario(){\r\n    let concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    assert_eq!(concesionario.nombre, \"Mi Concesionario\");\r\n    assert_eq!(concesionario.direccion, \"Calle Falsa 123\");\r\n    assert_eq!(concesionario.capacidad_maxima, 10);\r\n    assert_eq!(concesionario.autos.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_consecionario(){\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n    assert_eq!(concesionario.agregar_auto(auto1.clone()), true); // para evitar el owner ship\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert_eq!(concesionario.agregar_auto(auto2.clone()), true);\r\n    assert_eq!(concesionario.autos.len(), 2);\r\n\r\n    assert_eq!(concesionario.eliminar_auto(\u0026auto1), true);\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert!(concesionario.buscar_auto(\u0026auto1).is_none()); // devuelve un option la funcion, entonces usamos is_none()\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_acceso_fuera_de_indice() {\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"AutoMundo\"),\r\n      String::from(\"Av. Principal 123\"),\r\n      2\r\n    );\r\n        \r\n    let auto = Auto::new(\r\n      String::from(\"Ford\"),\r\n      String::from(\"Focus\"),\r\n      2020,\r\n      15000.0,\r\n      Color::Azul\r\n    );\r\n        \r\n    concesionario.agregar_auto(auto);\r\n    let _auto_inexistente = \u0026concesionario.autos[5]; // Índice fuera de rango\r\n    }\r\n\r\n    \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej08.rs"],"content":"// 8- Defina la estructura Cancion con campos para el título, el artista y el género. El género \r\n// puede ser rock, pop, rap,  jazz, otros. Luego modele una playlist. La playlist está compuesta \r\n// por una lista de canciones y un nombre, y se permiten hacer las siguientes acciones sobre \r\n// ella: \r\n// ➔  agregar canción. \r\n// ➔  eliminar canción. \r\n// ➔  mover canción // mueve la canción a una determinada posición de la playlist. \r\n// ➔  buscar canción por nombre. \r\n// ➔  obtener las canciones de un determinado género. \r\n// ➔  obtener las canciones de un determinado artista. \r\n// ➔  modificar título de la playlist. \r\n// ➔  eliminar todas las canciones\r\n\r\n#[derive(Debug, Clone)]\r\nenum Genero {\r\n  Rock,\r\n  Pop,\r\n  Rap,\r\n  Jazz,\r\n  Otros,\r\n}\r\n\r\n// impl Genero {\r\n//   fn to_string(\u0026self) -\u003e String {\r\n//     match self {\r\n//       Genero::Rock =\u003e \"Rock\".to_string(),\r\n//       Genero::Pop =\u003e \"Pop\".to_string(),\r\n//       Genero::Rap =\u003e \"Rap\".to_string(),\r\n//       Genero::Jazz =\u003e \"Jazz\".to_string(),\r\n//       Genero::Otros =\u003e \"Otros\".to_string(),\r\n//     }\r\n//   }\r\n// }\r\nimpl Genero {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Cancion {\r\n  titulo: String,\r\n  artista: String,\r\n  genero: Genero,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct Playlist {\r\n  canciones: Vec\u003cCancion\u003e,\r\n  nombre: String,\r\n}\r\n\r\n\r\n\r\nimpl Cancion {\r\n  fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\r\n    Cancion {\r\n      titulo,\r\n      artista,\r\n      genero,\r\n    }\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl Playlist {\r\n  fn new(nombre: String) -\u003e Playlist {\r\n    Playlist {\r\n      canciones: Vec::new(),\r\n      nombre,\r\n    }\r\n  }\r\n\r\n  fn agregar_cancion(\u0026mut self, cancion: Cancion) {\r\n    self.canciones.push(cancion);\r\n  }\r\n\r\n  fn eliminar_cancion(\u0026mut self, titulo: \u0026str) -\u003e bool {\r\n    let posicion = self.encontrar_pos_cancion(titulo);\r\n    if let Some(pos) = posicion {\r\n      self.canciones.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_pos_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003cusize\u003e {\r\n    self.canciones.iter().position(|c| c.titulo.to_lowercase() == titulo.to_lowercase())\r\n  }\r\n\r\n  fn mover_cancion(\u0026mut self, titulo: \u0026str, nueva_posicion: usize) -\u003e bool {\r\n    if nueva_posicion \u003e= self.canciones.len() {\r\n      return false;\r\n    }\r\n\r\n    let posicion_actual = self.encontrar_pos_cancion(titulo);\r\n    if let Some (pos) = posicion_actual {\r\n      if pos == nueva_posicion {\r\n        return true; // no hacer nada\r\n      }\r\n\r\n      let cancion = self.canciones.remove(pos);\r\n      self.canciones.insert(nueva_posicion, cancion);\r\n      return true;\r\n    } else {\r\n      return false\r\n    }  \r\n  }\r\n\r\n  fn buscar_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003c\u0026Cancion\u003e {\r\n    self.canciones.iter().find(|\u0026c| c.titulo.to_lowercase() == titulo.to_lowercase())\r\n  }\r\n\r\n  fn obtener_canciones_por_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e { //\u0026Cancion para no tomar la propiedad\r\n    self.canciones.iter()\r\n    .filter(|c| c.genero.eq(genero)) // filter coleccion las canciones\r\n    .collect()// collect convierte el iterator en un vector\r\n  }\r\n\r\n  fn obtener_canciones_por_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n    self.canciones.iter()\r\n    .filter(|c| c.artista.to_lowercase() == artista.to_lowercase())\r\n    .collect()\r\n  }\r\n\r\n  fn modificar_titulo(\u0026mut self, nuevo_titulo: \u0026str) {\r\n    self.nombre = nuevo_titulo.to_string();\r\n  }\r\n\r\n  fn eliminar_todas_las_canciones(\u0026mut self) {\r\n    self.canciones.clear();\r\n  }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n\r\nuse super::*;\r\n\r\n  fn crear_playlist_test() -\u003e Playlist {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Champangne Supernova\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Blank Space\".to_string(),\r\n      \"Taylor Swift\".to_string(),\r\n      Genero::Pop\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Stand by me\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_crear_playlist() {\r\n    let playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    assert_eq!(playlist.nombre, \"Mi Playlist\");\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_agregar_cancion() {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    let cancion = Cancion::new(\r\n      \"Live forever\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    );\r\n\r\n    playlist.agregar_cancion(cancion.clone());\r\n    assert_eq!(playlist.canciones.len(), 1);\r\n    assert!(playlist.canciones[0].eq(\u0026cancion));\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_existente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Blank Space\");\r\n    assert_eq!(resultado, true);\r\n    assert_eq!(playlist.canciones.len(), 2);\r\n    assert!(playlist.buscar_cancion(\"Blank Space\").is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Cancion Inexistente\");\r\n    assert_eq!(resultado, false);\r\n    assert_eq!(playlist.canciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_caso_normal() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n    // Mover \"Stand by me\" (índice 2) a la posición 0\r\n    let result = playlist.mover_cancion(\"Stand by me\", 0);\r\n        \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Stand by me\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_misma_posicion() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Mover \"Blank Space\" (índice 1) a la posición 1 (no debería cambiar)\r\n    let result = playlist.mover_cancion(\"Blank Space\", 1);\r\n    \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Stand by me\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_posicion_invalida() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Intentar mover a una posición fuera de rango\r\n    let result = playlist.mover_cancion(\"Blank Space\", 10);\r\n    \r\n    assert!(!result);\r\n    // Verificar que el orden no cambió\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    let result = playlist.mover_cancion(\"Canción Inexistente\", 0);\r\n    \r\n    assert!(!result);\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_existente_case_insensitive() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    // Buscar con diferente capitalización\r\n    let cancion = playlist.buscar_cancion(\"blank Space\");\r\n      \r\n    assert!(cancion.is_some());\r\n    assert_eq!(cancion.unwrap().titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_inexistente() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    let cancion = playlist.buscar_cancion(\"Canción Inexistente\");\r\n      \r\n    assert!(cancion.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_genero() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n     // Agregamos otra canción de rock\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"We Will Rock You\".to_string(),\r\n      \"Queen\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n        \r\n    let canciones_rock = playlist.obtener_canciones_por_genero(\u0026Genero::Rock);\r\n        \r\n    assert_eq!(canciones_rock.len(), 3);\r\n    assert_eq!(canciones_rock[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_rock[1].titulo, \"Stand by me\");\r\n    assert_eq!(canciones_rock[2].titulo, \"We Will Rock You\");\r\n        \r\n    // Género sin canciones\r\n    let canciones_jazz = playlist.obtener_canciones_por_genero(\u0026Genero::Jazz);\r\n    assert_eq!(canciones_jazz.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_artista() {\r\n    let playlist = crear_playlist_test();\r\n        \r\n    let canciones_oasis = playlist.obtener_canciones_por_artista(\"Oasis\");\r\n        \r\n    assert_eq!(canciones_oasis.len(), 2);\r\n    assert_eq!(canciones_oasis[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_oasis[1].titulo, \"Stand by me\");\r\n\r\n    // Artista sin Canciones\r\n    let canciones_lipa = playlist.obtener_canciones_por_artista(\"Dua Lipa\");\r\n    assert_eq!(canciones_lipa.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_titulo() {\r\n    let mut playlist = crear_playlist_test();\r\n    playlist.modificar_titulo(\"Mi Playlist Modificada\");\r\n    assert_eq!(playlist.nombre, \"Mi Playlist Modificada\");\r\n  }\r\n\r\n  // Tests para playlist vacía\r\n  #[test]\r\n  fn test_operaciones_en_playlist_vacia() {\r\n    let mut playlist = Playlist::new(\"Playlist Vacía\".to_string());\r\n      \r\n    // Intentar eliminar de una playlist vacía\r\n    let result = playlist.eliminar_cancion(\"Cualquier Canción\");\r\n    assert!(!result);\r\n      \r\n      // Intentar mover en una playlist vacía\r\n    let result = playlist.mover_cancion(\"Cualquier Canción\", 0);\r\n    assert!(!result);\r\n      \r\n    // Buscar en una playlist vacía\r\n    assert!(playlist.buscar_cancion(\"Cualquier Canción\").is_none());\r\n      \r\n    // Filtrar por género en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_genero(\u0026Genero::Rock).len(), 0);\r\n      \r\n    // Filtrar por artista en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_artista(\"Cualquier Artista\").len(), 0);\r\n      \r\n    // Eliminar todas las canciones de una playlist vacía\r\n    playlist.eliminar_todas_las_canciones();\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej08v2.rs"],"content":"// 8- Defina la estructura Cancion con campos para el título, el artista y el género. El género \r\n// puede ser rock, pop, rap,  jazz, otros. Luego modele una playlist. La playlist está compuesta \r\n// por una lista de canciones y un nombre, y se permiten hacer las siguientes acciones sobre \r\n// ella: \r\n// ➔  agregar canción. \r\n// ➔  eliminar canción. \r\n// ➔  mover canción // mueve la canción a una determinada posición de la playlist. \r\n// ➔  buscar canción por nombre. \r\n// ➔  obtener las canciones de un determinado género. \r\n// ➔  obtener las canciones de un determinado artista. \r\n// ➔  modificar título de la playlist. \r\n// ➔  eliminar todas las canciones\r\n\r\n#[derive(Debug, Clone)]\r\nenum Genero {\r\n  Rock,\r\n  Pop,\r\n  Rap,\r\n  Jazz,\r\n  Otros,\r\n}\r\n\r\nimpl Genero {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Cancion {\r\n  titulo: String,\r\n  artista: String,\r\n  genero: Genero,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct Playlist {\r\n  canciones: Vec\u003cCancion\u003e,\r\n  nombre: String,\r\n}\r\n\r\nimpl Cancion {\r\n  fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\r\n    Cancion {\r\n      titulo,\r\n      artista,\r\n      genero,\r\n    }\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl Playlist {\r\n  fn new(nombre: String) -\u003e Playlist {\r\n    Playlist {\r\n      canciones: Vec::new(),\r\n      nombre,\r\n    }\r\n  }\r\n\r\n  fn agregar_cancion(\u0026mut self, cancion: Cancion) {\r\n    self.canciones.push(cancion);\r\n  }\r\n\r\n  fn eliminar_cancion(\u0026mut self, titulo: \u0026str) -\u003e bool {\r\n    let posicion = self.encontrar_pos_cancion(titulo);\r\n    if let Some(pos) = posicion {\r\n      self.canciones.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_pos_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003cusize\u003e {\r\n    for i in 0..self.canciones.len() {\r\n      if self.canciones[i].titulo.to_lowercase() == titulo.to_lowercase() {\r\n        return Some(i);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn mover_cancion(\u0026mut self, titulo: \u0026str, nueva_posicion: usize) -\u003e bool {\r\n    if nueva_posicion \u003e= self.canciones.len() {\r\n      return false;\r\n    }\r\n\r\n    let posicion_actual = self.encontrar_pos_cancion(titulo);\r\n    if let Some (pos) = posicion_actual {\r\n      if pos == nueva_posicion {\r\n        return true; // no hacer nada\r\n      }\r\n\r\n      let cancion = self.canciones.remove(pos);\r\n      self.canciones.insert(nueva_posicion, cancion);\r\n      return true;\r\n    } else {\r\n      return false\r\n    }  \r\n  }\r\n\r\n  fn buscar_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003c\u0026Cancion\u003e {\r\n    for i in 0..self.canciones.len() {\r\n      if self.canciones[i].titulo.to_lowercase() == titulo.to_lowercase() {\r\n        return Some(\u0026self.canciones[i]);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn obtener_canciones_por_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e { //\u0026Cancion para no tomar la propiedad\r\n    let mut canciones_filtradas = Vec::new();\r\n    \r\n    for cancion in \u0026self.canciones {\r\n      if cancion.genero.eq(genero) {\r\n        canciones_filtradas.push(cancion);\r\n      }\r\n    }\r\n    \r\n    canciones_filtradas\r\n  }\r\n\r\n  fn obtener_canciones_por_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n    let mut canciones_filtradas = Vec::new();\r\n    \r\n    for cancion in \u0026self.canciones {\r\n      if cancion.artista.to_lowercase() == artista.to_lowercase() {\r\n        canciones_filtradas.push(cancion);\r\n      }\r\n    }\r\n    \r\n    canciones_filtradas\r\n  }\r\n\r\n  fn modificar_titulo(\u0026mut self, nuevo_titulo: \u0026str) {\r\n    self.nombre = nuevo_titulo.to_string();\r\n  }\r\n\r\n  fn eliminar_todas_las_canciones(\u0026mut self) {\r\n    self.canciones.clear();\r\n  }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\nuse super::*;\r\n\r\n  fn crear_playlist_test() -\u003e Playlist {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Champangne Supernova\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Blank Space\".to_string(),\r\n      \"Taylor Swift\".to_string(),\r\n      Genero::Pop\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Stand by me\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_crear_playlist() {\r\n    let playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    assert_eq!(playlist.nombre, \"Mi Playlist\");\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_agregar_cancion() {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    let cancion = Cancion::new(\r\n      \"Live forever\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    );\r\n\r\n    playlist.agregar_cancion(cancion.clone());\r\n    assert_eq!(playlist.canciones.len(), 1);\r\n    assert!(playlist.canciones[0].eq(\u0026cancion));\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_existente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Blank Space\");\r\n    assert_eq!(resultado, true);\r\n    assert_eq!(playlist.canciones.len(), 2);\r\n    assert!(playlist.buscar_cancion(\"Blank Space\").is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Cancion Inexistente\");\r\n    assert_eq!(resultado, false);\r\n    assert_eq!(playlist.canciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_caso_normal() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n    // Mover \"Stand by me\" (índice 2) a la posición 0\r\n    let result = playlist.mover_cancion(\"Stand by me\", 0);\r\n        \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Stand by me\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_misma_posicion() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Mover \"Blank Space\" (índice 1) a la posición 1 (no debería cambiar)\r\n    let result = playlist.mover_cancion(\"Blank Space\", 1);\r\n    \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Stand by me\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_posicion_invalida() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Intentar mover a una posición fuera de rango\r\n    let result = playlist.mover_cancion(\"Blank Space\", 10);\r\n    \r\n    assert!(!result);\r\n    // Verificar que el orden no cambió\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    let result = playlist.mover_cancion(\"Canción Inexistente\", 0);\r\n    \r\n    assert!(!result);\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_existente_case_insensitive() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    // Buscar con diferente capitalización\r\n    let cancion = playlist.buscar_cancion(\"blank Space\");\r\n      \r\n    assert!(cancion.is_some());\r\n    assert_eq!(cancion.unwrap().titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_inexistente() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    let cancion = playlist.buscar_cancion(\"Canción Inexistente\");\r\n      \r\n    assert!(cancion.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_genero() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n     // Agregamos otra canción de rock\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"We Will Rock You\".to_string(),\r\n      \"Queen\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n        \r\n    let canciones_rock = playlist.obtener_canciones_por_genero(\u0026Genero::Rock);\r\n        \r\n    assert_eq!(canciones_rock.len(), 3);\r\n    assert_eq!(canciones_rock[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_rock[1].titulo, \"Stand by me\");\r\n    assert_eq!(canciones_rock[2].titulo, \"We Will Rock You\");\r\n        \r\n    // Género sin canciones\r\n    let canciones_jazz = playlist.obtener_canciones_por_genero(\u0026Genero::Jazz);\r\n    assert_eq!(canciones_jazz.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_artista() {\r\n    let playlist = crear_playlist_test();\r\n        \r\n    let canciones_oasis = playlist.obtener_canciones_por_artista(\"Oasis\");\r\n        \r\n    assert_eq!(canciones_oasis.len(), 2);\r\n    assert_eq!(canciones_oasis[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_oasis[1].titulo, \"Stand by me\");\r\n\r\n    // Artista sin Canciones\r\n    let canciones_lipa = playlist.obtener_canciones_por_artista(\"Dua Lipa\");\r\n    assert_eq!(canciones_lipa.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_titulo() {\r\n    let mut playlist = crear_playlist_test();\r\n    playlist.modificar_titulo(\"Mi Playlist Modificada\");\r\n    assert_eq!(playlist.nombre, \"Mi Playlist Modificada\");\r\n  }\r\n\r\n  // Tests para playlist vacía\r\n  #[test]\r\n  fn test_operaciones_en_playlist_vacia() {\r\n    let mut playlist = Playlist::new(\"Playlist Vacía\".to_string());\r\n      \r\n    // Intentar eliminar de una playlist vacía\r\n    let result = playlist.eliminar_cancion(\"Cualquier Canción\");\r\n    assert!(!result);\r\n      \r\n      // Intentar mover en una playlist vacía\r\n    let result = playlist.mover_cancion(\"Cualquier Canción\", 0);\r\n    assert!(!result);\r\n      \r\n    // Buscar en una playlist vacía\r\n    assert!(playlist.buscar_cancion(\"Cualquier Canción\").is_none());\r\n      \r\n    // Filtrar por género en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_genero(\u0026Genero::Rock).len(), 0);\r\n      \r\n    // Filtrar por artista en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_artista(\"Cualquier Artista\").len(), 0);\r\n      \r\n    // Eliminar todas las canciones de una playlist vacía\r\n    playlist.eliminar_todas_las_canciones();\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej09.rs"],"content":"use std::collections::VecDeque;\r\n\r\n// 9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de \r\n// pacientes para cada veterinaria, de la veterinaria se conoce el nombre, la dirección y un id. \r\n// Para la atención de mascotas se requiere administrar una cola de atención. De la mascota \r\n// se conoce el nombre, la edad, el tipo de animal(perro, gato, caballo, otros) y su dueño. Del \r\n// dueño se conoce el nombre, la dirección y un teléfono de contacto. Luego de la atención se \r\n// desea tener un registro de las atenciones realizadas guardando los datos de la mascota, el \r\n// diagnóstico final, tratamiento y fecha de la próxima visita si es que se requiere. \r\n// Dado todo lo mencionado anteriormente implemente los métodos para realizar las \r\n// siguientes acciones: \r\n// ➔  crear una veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención de la veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención pero que sea la siguiente \r\n// en atender porque tiene la máxima prioridad. \r\n// ➔  atender la próxima mascota de la cola. \r\n// ➔  eliminar una mascota específica de la cola de atención dado que se retira. \r\n// ➔  registrar una atención. \r\n// ➔  buscar una atención dado el nombre de la mascota, el nombre del dueño y el \r\n// teléfono. \r\n// ➔  modificar el diagnóstico de una determinada atención. \r\n// ➔  modificar la fecha de la próxima visita de una determinada atención. \r\n// ➔  eliminar una determinada atención. \r\n \r\n// Nota: para la fecha utilice lo implementado en el punto 3\r\nuse crate::tp03::ej03::Fecha;\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nenum TipoAnimal {\r\n  Perro,\r\n  Gato,\r\n  Caballo,\r\n  Otros(String),\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Duenio {\r\n  nombre: String,\r\n  direccion: String,\r\n  telefono: u32,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Mascota {\r\n  nombre: String,\r\n  edad: u32,\r\n  tipo: TipoAnimal,\r\n  duenio: Duenio,\r\n}\r\n\r\nimpl Mascota {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Atencion {\r\n  mascota: Mascota,\r\n  diagnostico: String,\r\n  tratamiento: String,\r\n  proxima_visita:Option\u003cFecha\u003e,\r\n}\r\nstruct Veterinaria {\r\n  nombre_vet: String,\r\n  direccion: String,\r\n  id: u32,\r\n  cola: VecDeque\u003cMascota\u003e,\r\n  atenciones : Vec\u003cAtencion\u003e\r\n}\r\n\r\nimpl Veterinaria {\r\n  fn new(nombre_vet: String, direccion: String, id: u32)-\u003e Self{\r\n    Veterinaria {\r\n      nombre_vet,\r\n      direccion,\r\n      id,\r\n      cola: VecDeque::new(),\r\n      atenciones: Vec::new()\r\n    }\r\n  }\r\n\r\n  fn agregar_mascota(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_back(mascota);\r\n  }\r\n\r\n  fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_front(mascota);\r\n  }\r\n\r\n  fn atender_proxima_mascota(\u0026mut self)-\u003e Option\u003cMascota\u003e{\r\n    self.cola.pop_front()\r\n  }\r\n\r\n  fn eliminar_mascota(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e bool{\r\n\r\n    let posicion = self.encontrar_mascota(nombre_mascota, nombre_duenio);\r\n    if let Some(pos) = posicion {\r\n      self.cola.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_mascota(\u0026self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e Option\u003cusize\u003e{\r\n    self.cola.iter().position(|m| m.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 m.nombre.to_lowercase() == nombre_mascota.to_lowercase())\r\n  }\r\n\r\n  fn registrar_atencion(\u0026mut self, atencion: Atencion){\r\n    self.atenciones.push(atencion);\r\n  }\r\n\r\n  fn buscar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32)-\u003e Option\u003c\u0026mut Atencion\u003e{\r\n    self.atenciones.iter_mut().find(|a| a.mascota.duenio.telefono == telefono_duenio \u0026\u0026 a.mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 a.mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase())\r\n  }\r\n\r\n  fn modificar_diagnostico(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, diagnostico: \u0026str){\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio){\r\n      atencion.diagnostico = diagnostico.to_string();\r\n    }\r\n  }\r\n  \r\n  fn modificar_fecha_proxima_visita(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, nueva_fecha: Option\u003cFecha\u003e) {\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio) {\r\n        if let Some(f) =\u0026nueva_fecha{\r\n          if f.es_fecha_valida(){\r\n            atencion.proxima_visita =Some(f.clone());\r\n          }\r\n        } else {\r\n          atencion.proxima_visita = None;\r\n        }\r\n    }\r\n  }\r\n\r\n  fn eliminar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32) -\u003e bool {\r\n    if let Some(pos) = self.atenciones.iter().position(|a|  //podria haber hecho esto con una funcion auxiliar que busque la pos de la atencion como lo hice con la mascota.\r\n        a.mascota.duenio.telefono == telefono_duenio \u0026\u0026\r\n        a.mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026\r\n        a.mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase()\r\n    ) {\r\n        self.atenciones.remove(pos);\r\n        true\r\n    } else {\r\n        false\r\n    }\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\nuse super::*;\r\n  use crate::tp03::ej03::Fecha;\r\n\r\n  fn crear_mascota(nombre: \u0026str,nombre_duenio: \u0026str, telefono_duenio:u32 )-\u003e Mascota{\r\n    Mascota {\r\n      nombre: nombre.to_string(),\r\n      edad: 3,\r\n      tipo: TipoAnimal::Perro,\r\n      duenio : Duenio {\r\n        nombre: nombre_duenio.to_string(),\r\n        direccion: \"Una direccion\".to_string(),\r\n        telefono: telefono_duenio\r\n      }\r\n    }\r\n  }\r\n\r\n  fn crear_atencion(mascota: Mascota) -\u003e Atencion{\r\n    Atencion {\r\n      mascota,\r\n      diagnostico: \"Un diagnostico\".to_string(),\r\n      tratamiento: \"Un tratamiento\".to_string(),\r\n      proxima_visita: Some(Fecha::new(17,12,2023))\r\n    }\r\n  }\r\n\r\n  fn crear_veterinaria() -\u003e Veterinaria{\r\n    Veterinaria::new(\"Mi veterinaria\".to_string(), \"Mi direccion\".to_string(), 1)\r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    \r\n    let atendida = vet.atender_proxima_mascota();\r\n\r\n    // Verificar que atendida sea Some y luego comparar el contenido manualmente\r\n    assert!(atendida.is_some());\r\n    if let Some(m) = atendida {\r\n      assert!(m.eq(\u0026mascota));\r\n    }\r\n    \r\n    assert_eq!(vet.cola.len(), 0);\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota_prioridad(){\r\n    let mut vet = crear_veterinaria();\r\n    let normal = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    let prioridad = crear_mascota(\"Tato\", \"Florencia\", 12556);\r\n    vet.agregar_mascota_prioridad(prioridad.clone());\r\n    vet.agregar_mascota(normal.clone());\r\n    \r\n    let primero = vet.atender_proxima_mascota();\r\n\r\n    assert!(primero.is_some());\r\n    if let Some(m) = primero {\r\n      assert!(m.eq(\u0026prioridad));\r\n      assert!(!m.eq(\u0026normal));\r\n    }\r\n\r\n    assert_eq!(vet.cola.len(), 1);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota_no_existente(){\r\n    let mut vet = crear_veterinaria(); // veterina con 0 mascotas\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, false);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_registrar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone()); // se pone clone para que no se borre la mascota\r\n    vet.registrar_atencion(atencion);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    let encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert!(encontrada.is_some());\r\n\r\n    //atencion que no existe\r\n    let no_encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 123456);\r\n    assert!(no_encontrada.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_diagnostico(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n    vet.modificar_diagnostico(\"Sombra\", \"Carlos\", 4585, \"Curado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n\r\n    // se pasan mal los nombres en la funcion y debe fallar\r\n    vet.modificar_diagnostico(\"Sombraaaa\", \"Carlos\", 4585, \"Diagnóstico mal aplicado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_fecha_proxima_visita(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(15,01,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_some());\r\n  \r\n\r\n    // Suponiendo que no se pasa fecha  \r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, None);\r\n    assert!(vet.atenciones[0].proxima_visita.is_none());\r\n\r\n    //suponiendo fecha invalida\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(32,13,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_none()); // debería fallar\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let mascota2 = crear_mascota(\"Apo\", \"Nicolas\", 458555);\r\n    \r\n    let atencion = crear_atencion(mascota.clone());\r\n    let atencion2 = crear_atencion(mascota2.clone());\r\n   \r\n    vet.registrar_atencion(atencion);\r\n    vet.registrar_atencion(atencion2);\r\n\r\n    let eliminada = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    let eliminada_inexistente = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada_inexistente, false);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej09v2.rs"],"content":"use std::collections::VecDeque;\r\n\r\n// 9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de \r\n// pacientes para cada veterinaria, de la veterinaria se conoce el nombre, la dirección y un id. \r\n// Para la atención de mascotas se requiere administrar una cola de atención. De la mascota \r\n// se conoce el nombre, la edad, el tipo de animal(perro, gato, caballo, otros) y su dueño. Del \r\n// dueño se conoce el nombre, la dirección y un teléfono de contacto. Luego de la atención se \r\n// desea tener un registro de las atenciones realizadas guardando los datos de la mascota, el \r\n// diagnóstico final, tratamiento y fecha de la próxima visita si es que se requiere. \r\n// Dado todo lo mencionado anteriormente implemente los métodos para realizar las \r\n// siguientes acciones: \r\n// ➔  crear una veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención de la veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención pero que sea la siguiente \r\n// en atender porque tiene la máxima prioridad. \r\n// ➔  atender la próxima mascota de la cola. \r\n// ➔  eliminar una mascota específica de la cola de atención dado que se retira. \r\n// ➔  registrar una atención. \r\n// ➔  buscar una atención dado el nombre de la mascota, el nombre del dueño y el \r\n// teléfono. \r\n// ➔  modificar el diagnóstico de una determinada atención. \r\n// ➔  modificar la fecha de la próxima visita de una determinada atención. \r\n// ➔  eliminar una determinada atención. \r\n \r\n// Nota: para la fecha utilice lo implementado en el punto 3\r\nuse crate::tp03::ej03::Fecha;\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nenum TipoAnimal {\r\n  Perro,\r\n  Gato,\r\n  Caballo,\r\n  Otros(String),\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Duenio {\r\n  nombre: String,\r\n  direccion: String,\r\n  telefono: u32,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Mascota {\r\n  nombre: String,\r\n  edad: u32,\r\n  tipo: TipoAnimal,\r\n  duenio: Duenio,\r\n}\r\n\r\nimpl Mascota {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Atencion {\r\n  mascota: Mascota,\r\n  diagnostico: String,\r\n  tratamiento: String,\r\n  proxima_visita:Option\u003cFecha\u003e,\r\n}\r\nstruct Veterinaria {\r\n  nombre_vet: String,\r\n  direccion: String,\r\n  id: u32,\r\n  cola: VecDeque\u003cMascota\u003e,\r\n  atenciones : Vec\u003cAtencion\u003e\r\n}\r\n\r\nimpl Veterinaria {\r\n  fn new(nombre_vet: String, direccion: String, id: u32)-\u003e Self{\r\n    Veterinaria {\r\n      nombre_vet,\r\n      direccion,\r\n      id,\r\n      cola: VecDeque::new(),\r\n      atenciones: Vec::new()\r\n    }\r\n  }\r\n\r\n  fn agregar_mascota(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_back(mascota);\r\n  }\r\n\r\n  fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_front(mascota);\r\n  }\r\n\r\n  fn atender_proxima_mascota(\u0026mut self)-\u003e Option\u003cMascota\u003e{\r\n    self.cola.pop_front()\r\n  }\r\n\r\n  fn eliminar_mascota(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e bool{\r\n\r\n    let posicion = self.encontrar_mascota(nombre_mascota, nombre_duenio);\r\n    if let Some(pos) = posicion {\r\n      self.cola.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_mascota(\u0026self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e Option\u003cusize\u003e{\r\n    for i in 0..self.cola.len() {\r\n      if self.cola[i].duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 self.cola[i].nombre.to_lowercase() == nombre_mascota.to_lowercase() {\r\n        return Some(i);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn registrar_atencion(\u0026mut self, atencion: Atencion){\r\n    self.atenciones.push(atencion);\r\n  }\r\n\r\n  fn buscar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32)-\u003e Option\u003c\u0026mut Atencion\u003e{\r\n    for i in 0..self.atenciones.len() {\r\n      if self.atenciones[i].mascota.duenio.telefono == telefono_duenio \u0026\u0026\r\n        self.atenciones[i].mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026\r\n        self.atenciones[i].mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase() {\r\n          return Some(\u0026mut self.atenciones[i]);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn modificar_diagnostico(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, diagnostico: \u0026str){\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio){\r\n      atencion.diagnostico = diagnostico.to_string();\r\n    }\r\n  }\r\n  \r\n  fn modificar_fecha_proxima_visita(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, nueva_fecha: Option\u003cFecha\u003e) {\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio) {\r\n        if let Some(f) =\u0026nueva_fecha{\r\n          if f.es_fecha_valida(){\r\n            atencion.proxima_visita =Some(f.clone());\r\n          }\r\n        } else {\r\n          atencion.proxima_visita = None;\r\n        }\r\n    }\r\n  }\r\n\r\n  fn eliminar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32) -\u003e bool {\r\n    for i in 0..self.atenciones.len() {\r\n      if self.atenciones[i].mascota.duenio.telefono == telefono_duenio \u0026\u0026\r\n        self.atenciones[i].mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 \r\n        self.atenciones[i].mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase(){\r\n        self.atenciones.remove(i);\r\n          return true\r\n      }\r\n    } \r\n    false\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n\r\nuse super::*;\r\n  use crate::tp03::ej03::Fecha;\r\n\r\n  fn crear_mascota(nombre: \u0026str,nombre_duenio: \u0026str, telefono_duenio:u32 )-\u003e Mascota{\r\n    Mascota {\r\n      nombre: nombre.to_string(),\r\n      edad: 3,\r\n      tipo: TipoAnimal::Perro,\r\n      duenio : Duenio {\r\n        nombre: nombre_duenio.to_string(),\r\n        direccion: \"Una direccion\".to_string(),\r\n        telefono: telefono_duenio\r\n      }\r\n    }\r\n  }\r\n\r\n  fn crear_atencion(mascota: Mascota) -\u003e Atencion{\r\n    Atencion {\r\n      mascota,\r\n      diagnostico: \"Un diagnostico\".to_string(),\r\n      tratamiento: \"Un tratamiento\".to_string(),\r\n      proxima_visita: Some(Fecha::new(17,12,2023))\r\n    }\r\n  }\r\n\r\n  fn crear_veterinaria() -\u003e Veterinaria{\r\n    Veterinaria::new(\"Mi veterinaria\".to_string(), \"Mi direccion\".to_string(), 1)\r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    \r\n    let atendida = vet.atender_proxima_mascota();\r\n\r\n    // Verificar que atendida sea Some y luego comparar el contenido manualmente\r\n    assert!(atendida.is_some());\r\n    if let Some(m) = atendida {\r\n      assert!(m.eq(\u0026mascota));\r\n    }\r\n    \r\n    assert_eq!(vet.cola.len(), 0);\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota_prioridad(){\r\n    let mut vet = crear_veterinaria();\r\n    let normal = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    let prioridad = crear_mascota(\"Tato\", \"Florencia\", 12556);\r\n    vet.agregar_mascota_prioridad(prioridad.clone());\r\n    vet.agregar_mascota(normal.clone());\r\n    \r\n    let primero = vet.atender_proxima_mascota();\r\n\r\n    assert!(primero.is_some());\r\n    if let Some(m) = primero {\r\n      assert!(m.eq(\u0026prioridad));\r\n      assert!(!m.eq(\u0026normal));\r\n    }\r\n\r\n    assert_eq!(vet.cola.len(), 1);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota_no_existente(){\r\n    let mut vet = crear_veterinaria(); // veterina con 0 mascotas\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, false);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_registrar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone()); // se pone clone para que no se borre la mascota\r\n    vet.registrar_atencion(atencion);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    let encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert!(encontrada.is_some());\r\n\r\n    //atencion que no existe\r\n    let no_encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 123456);\r\n    assert!(no_encontrada.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_diagnostico(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n    vet.modificar_diagnostico(\"Sombra\", \"Carlos\", 4585, \"Curado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n\r\n    // se pasan mal los nombres en la funcion y debe fallar\r\n    vet.modificar_diagnostico(\"Sombraaaa\", \"Carlos\", 4585, \"Diagnóstico mal aplicado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_fecha_proxima_visita(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(15,01,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_some());\r\n\r\n    // Suponiendo que no se pasa fecha  \r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, None);\r\n    assert!(vet.atenciones[0].proxima_visita.is_none());\r\n\r\n    //suponiendo fecha invalida\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(32,13,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_none());\r\n    \r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let mascota2 = crear_mascota(\"Apo\", \"Nicolas\", 458555);\r\n    \r\n    let atencion = crear_atencion(mascota.clone());\r\n    let atencion2 = crear_atencion(mascota2.clone());\r\n   \r\n    vet.registrar_atencion(atencion);\r\n    vet.registrar_atencion(atencion2);\r\n\r\n    let eliminada = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    let eliminada_inexistente = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada_inexistente, false);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej10.rs"],"content":"// 10-Para una biblioteca se desea implementar un sistema de préstamos de libros. De la \r\n// biblioteca se conoce el nombre y la dirección, las copias de los libros a disposición para \r\n// prestar y los préstamos efectuados. Los libros a disposición es un registro donde se indica \r\n// la cantidad de ejemplares que tiene a disposición para prestar de determinado libro. De \r\n// cada libro se conoce el isbn, el título, autor, número de páginas, género(novela, infantil, \r\n// técnico, otros). Para registrar un préstamo se requiere el libro, el cliente, la fecha de \r\n// vencimiento del préstamo, la fecha de devolución y el estado que puede ser devuelto o en \r\n// préstamo. Del cliente se conoce el nombre, teléfono y dirección de correo electrónico. \r\n// Implemente los métodos necesarios para realizar las siguientes acciones\r\n// ➔  obtener cantidad de copias: dado un determinado libro retorna la cantidad de \r\n// copias a disposición que hay para prestar de dicho libro. \r\n// ➔  decrementar cantidad de copias a disposición; dado un libro decrementa en 1 \r\n// la cantidad de copias de libros a disposición para prestar. \r\n// ➔  incrementar cantidad de copias a disposición: dado un libro incrementa en 1 \r\n// la cantidad de copias del libro a disposición para ser prestado. \r\n// ➔  contar préstamos de un cliente: devuelve la cantidad de préstamos en estado \r\n// “en préstamo” de un determinado cliente. \r\n// ➔  realizar un préstamo de un libro para un cliente: crea un préstamo de un libro \r\n// para un determinado cliente cumpliendo con lo siguiente  \r\n// ◆  el cliente no tenga más de 5 préstamos en el estado “en préstamo” \r\n// ◆   haya al menos una copia disponible en el registro de copias a \r\n// disposición. \r\n//  De ser así descuenta 1 en el registro de “copias a disposición” y \r\n// retorna true, si no cumple con alguna de las condiciones retorna false. \r\n// ➔  ver préstamos a vencer el los próximos días: retorna una lista de préstamos a \r\n// vencer el los próximos días, el valor de días es pasado por parámetro. \r\n// ➔  ver los préstamos vencidos: retorna una lista de préstamos en el estado “en \r\n// préstamos” donde la fecha de vencimiento es menor a la fecha actual. \r\n// ➔  buscar préstamo: dado un libro y un cliente busca un préstamo y lo retorna si \r\n// existe. \r\n// ➔  devolver libro: dado un libro y un cliente se busca el préstamo y se cambia al \r\n// estado “devuelto”, se registra la fecha de devolución y se incrementa la \r\n// cantidad de libros en 1 del libro devuelto en el registro de copias a \r\n// disposición. \r\n \r\n// Nota: para la fecha utilice lo implementado en el punto 3. \r\n\r\nuse super::ej03::Fecha;\r\nuse chrono::prelude::*;\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Cliente {\r\n  nombre: String,\r\n  telefono: u32,\r\n  correo_electronico: String,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum Genero {\r\n  Novela,\r\n  Infantil,\r\n  Tecnico,\r\n  Otros(String),\r\n}\r\n    \r\n#[derive(Debug, Clone)]\r\nstruct Libro {\r\n  isbn: u32,\r\n  titulo: String,\r\n  autor: String,\r\n  num_paginas: u32,\r\n  genero: Genero,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum EstadoPrestamo {\r\n  EnPrestamo,\r\n  Devuelto,\r\n}\r\n\r\nimpl EstadoPrestamo{ // clase 3 pag 23\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn es_igual(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct CopiaDisponible {\r\n    libro: Libro,\r\n    cantidad: u32,\r\n}\r\n#[derive(Debug, Clone)]\r\nstruct Prestamo {\r\n  libro: Libro,\r\n  cliente: Cliente,\r\n  fecha_vencimiento: Fecha,\r\n  fecha_devolucion: Option\u003cFecha\u003e,\r\n  estado: EstadoPrestamo,\r\n}\r\n\r\nimpl Prestamo {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn es_igual(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Biblioteca {\r\n  nombre: String,\r\n  direccion: String,\r\n  copias_disponibles: Vec\u003cCopiaDisponible\u003e,\r\n  prestamos: Vec\u003cPrestamo\u003e,\r\n}\r\n\r\nimpl Biblioteca {\r\n  fn new(nombre: String, direccion: String) -\u003e Self {\r\n    Biblioteca {\r\n      nombre,\r\n      direccion,\r\n      copias_disponibles: Vec::new(),\r\n      prestamos: Vec::new(),\r\n    }\r\n  }\r\n\r\n  fn obtener_cantidad_copias(\u0026self, libro: \u0026Libro) -\u003e Option\u003cu32\u003e {\r\n    if self.copias_disponibles.is_empty() {\r\n      return None;\r\n    }\r\n    let mut cantidad: u32 = 0;\r\n    for copia_disponible in \u0026self.copias_disponibles {\r\n      if copia_disponible.libro.isbn == libro.isbn {\r\n        cantidad += copia_disponible.cantidad;\r\n      }\r\n    }\r\n    Some(cantidad)\r\n  }\r\n\r\n  fn decrementar_cantidad_copias(\u0026mut self, libro: \u0026Libro)-\u003e Option\u003cbool\u003e{\r\n    if self.copias_disponibles.is_empty() {\r\n      return None;\r\n    }\r\n\r\n    for copia_disponible in \u0026mut self.copias_disponibles {\r\n      if copia_disponible.libro.isbn == libro.isbn {\r\n        if copia_disponible.cantidad == 0 {\r\n          return None;\r\n        }\r\n        else {\r\n          copia_disponible.cantidad -= 1;\r\n          return Some(true);\r\n        }        \r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn incrementar_cantidad_copias(\u0026mut self, libro: \u0026Libro)-\u003e Option\u003cbool\u003e{\r\n    if self.copias_disponibles.is_empty() {\r\n      return None;\r\n    }\r\n\r\n    for copia_disponible in \u0026mut self.copias_disponibles {\r\n      if copia_disponible.libro.isbn == libro.isbn {\r\n        copia_disponible.cantidad += 1;\r\n        return Some(true);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn contar_prestamos_cliente(\u0026mut self, cliente: \u0026Cliente) -\u003e Option\u003cu32\u003e {\r\n    if self.prestamos.is_empty() {\r\n      return None;\r\n    }\r\n    let mut cantidad: u32 = 0;\r\n    for prestamo in \u0026self.prestamos {\r\n      if (prestamo.cliente.nombre == cliente.nombre) \u0026\u0026 (prestamo.estado.es_igual(\u0026EstadoPrestamo::EnPrestamo)) {\r\n        cantidad += 1;\r\n      }\r\n    }\r\n    Some(cantidad)\r\n  }\r\n\r\n  fn realizar_prestamo(\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente, fecha_vencimiento: Fecha) -\u003e bool {\r\n    // si tiene menos de 5 prestamos y hay al menos una copia disponible se puede realizar el prestamo\r\n    if self.contar_prestamos_cliente(cliente) \u003e= Some(5) || self.obtener_cantidad_copias(libro) \u003c Some(1) {\r\n      return false\r\n    }\r\n    else {\r\n      self.prestamos.push(Prestamo {\r\n        libro: libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_vencimiento,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo\r\n      });\r\n      self.decrementar_cantidad_copias(libro);\r\n      return true\r\n    }\r\n  }\r\n\r\n  fn ver_prestamos_a_vencer(\u0026self, dias: u32) -\u003e Vec\u003cPrestamo\u003e {\r\n    let mut prestamos_a_vencer: Vec\u003cPrestamo\u003e = Vec::new();\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32); // fecha actual usando la libreria chrono\r\n    for prestamo in \u0026self.prestamos {\r\n      let mut fecha_vencimiento = prestamo.fecha_vencimiento.clone();\r\n      fecha_vencimiento.sumar_dias(dias);\r\n      if prestamo.fecha_vencimiento.es_mayor(\u0026hoy) \u0026\u0026 prestamo.estado.es_igual(\u0026EstadoPrestamo::EnPrestamo) {\r\n        prestamos_a_vencer.push(prestamo.clone());\r\n      }\r\n    }\r\n    return prestamos_a_vencer;\r\n  }\r\n\r\n  fn ver_prestamos_vencidos(\u0026self) -\u003e Vec\u003cPrestamo\u003e {\r\n    let mut prestamos_vencidos: Vec\u003cPrestamo\u003e = Vec::new();\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32); // fecha actual usando la libreria chrono\r\n    for prestamo in \u0026self.prestamos {\r\n      if !(prestamo.fecha_vencimiento.es_mayor(\u0026hoy)) \u0026\u0026 prestamo.estado.es_igual(\u0026EstadoPrestamo::EnPrestamo) {\r\n        prestamos_vencidos.push(prestamo.clone());\r\n      }\r\n    }\r\n    return prestamos_vencidos;\r\n  }\r\n\r\n  fn buscar_prestamo(\u0026self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Option\u003cPrestamo\u003e { \r\n    for prestamo in \u0026 self.prestamos {\r\n      if prestamo.libro.isbn == libro.isbn \u0026\u0026 prestamo.cliente.nombre == cliente.nombre {\r\n        return Some(prestamo.clone());\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn devolver_prestamo(\u0026mut self, libro:\u0026Libro, cliente:\u0026Cliente) -\u003e bool {\r\n    for prestamo in \u0026mut self.prestamos {\r\n      if prestamo.libro.isbn == libro.isbn \u0026\u0026 prestamo.cliente.nombre == cliente.nombre {\r\n        prestamo.estado = EstadoPrestamo::Devuelto;\r\n        let now = Local::now();\r\n        let hoy = Fecha::new(now.day(), now.month(), now.year() as u32); // fecha actual usando la libreria chrono\r\n        prestamo.fecha_devolucion = Some(hoy);\r\n        self.incrementar_cantidad_copias(\u0026libro);\r\n        return true;\r\n      }\r\n    }\r\n    false\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n  use super::*;\r\n  use crate::tp03::ej03::Fecha;\r\n\r\n  fn crear_bibioteca_prueba() -\u003e Biblioteca {\r\n    let mut biblioteca = Biblioteca::new(\r\n      \"Bilioteca PrUeba\".to_string(),\r\n      \"calle Prueba 112\".to_string()\r\n    );\r\n\r\n    let libro1 = Libro {\r\n      isbn: 1234,\r\n      titulo:\"El Pricipito\".to_string(),\r\n      autor:\"Antoine de Saint-Exupery\".to_string(),\r\n      num_paginas: 100,\r\n      genero: Genero::Infantil\r\n    };\r\n\r\n    let libro2 = Libro {\r\n      isbn: 4567,\r\n      titulo:\"100 anios de soledad\".to_string(),\r\n      autor:\"Gabriel Garcia Marquez\".to_string(),\r\n      num_paginas: 350,\r\n      genero: Genero::Novela\r\n    };\r\n\r\n    let libro3 = Libro {\r\n      isbn: 7890,\r\n      titulo:\"Harry Potter\".to_string(),\r\n      autor:\"J.K. Rowling\".to_string(),\r\n      num_paginas: 450,\r\n      genero: Genero::Novela\r\n    };\r\n\r\n    biblioteca.copias_disponibles.push(CopiaDisponible { \r\n      libro: libro1,\r\n      cantidad: 3\r\n    });\r\n\r\n    biblioteca.copias_disponibles.push(CopiaDisponible { \r\n      libro: libro2,\r\n      cantidad: 5\r\n    });\r\n\r\n    biblioteca.copias_disponibles.push(CopiaDisponible { \r\n      libro: libro3,\r\n      cantidad: 0 //un libro sin copias\r\n    });\r\n\r\n    return biblioteca;\r\n\r\n  }\r\n\r\n\r\n  fn crear_cliente_prueba(nombre:\u0026str) -\u003e Cliente {\r\n    Cliente {\r\n      nombre: nombre.to_string(),\r\n      telefono: 1522215,\r\n      correo_electronico: format!(\"{}@example.com\", nombre.to_lowercase()),\r\n    }\r\n  }\r\n\r\n  #[test]\r\n  fn obtener_cantidad_copias_test(){\r\n    let biblioteca = crear_bibioteca_prueba();\r\n\r\n    //libro con copias\r\n    let cantidad = biblioteca.obtener_cantidad_copias(\u0026biblioteca.copias_disponibles[0].libro);\r\n    assert_eq!(cantidad, Some(3));\r\n\r\n    //libro sin copias\r\n    let cantidad2 = biblioteca.obtener_cantidad_copias(\u0026biblioteca.copias_disponibles[2].libro);\r\n    assert_eq!(cantidad2, Some(0));\r\n\r\n    // libro que no existe\r\n    let libro_inexistente = Libro {\r\n      isbn: 0001,\r\n      titulo: String::from(\"Un Libro\"),\r\n      autor: \"Un Autor\".to_string(),\r\n      num_paginas: 0,\r\n      genero: Genero::Otros(\"Desconocido\".to_string())\r\n    };\r\n\r\n    let cantidad3 = biblioteca.obtener_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(cantidad3, Some(0));\r\n\r\n    // caso para una biblioteca vacia\r\n\r\n    let biblioteca_vacia = Biblioteca::new(\"Vacia\".to_string(), \"Mi casa\".to_string());\r\n    let cantidad4 = biblioteca_vacia.obtener_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(cantidad4, None);\r\n  }\r\n\r\n  #[test]\r\n  fn decrementar_cantidad_copias_test(){\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n\r\n    // caso normal, con unlibro que tiene copias\r\n    let libro = \u0026biblioteca.copias_disponibles[0].libro.clone();\r\n    let result = biblioteca.decrementar_cantidad_copias(libro);\r\n    assert_eq!(result, Some(true));\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, 2);\r\n\r\n    // caso libro sin copias;\r\n    let libro2 = \u0026biblioteca.copias_disponibles[2].libro.clone();\r\n    let result = biblioteca.decrementar_cantidad_copias(libro2);\r\n    assert_eq!(result, None);\r\n    assert_eq!(biblioteca.copias_disponibles[2].cantidad, 0);\r\n\r\n    // prueba con un libro que no existe;\r\n    let libro_inexistente: Libro = Libro {\r\n      isbn: 0001,\r\n      titulo: String::from(\"Un Libro\"),\r\n      autor: \"Un Autor\".to_string(),\r\n      num_paginas: 0,\r\n      genero: Genero::Otros(\"Desconocido\".to_string())\r\n    };\r\n\r\n    let result = biblioteca.decrementar_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(result, None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_incrementar_cantidad_copias(){\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    // caso normal, con unlibro que tiene copias\r\n    let libro = \u0026biblioteca.copias_disponibles[0].libro.clone();\r\n    let result = biblioteca.incrementar_cantidad_copias(libro);\r\n    assert_eq!(result, Some(true));\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, 4);\r\n\r\n    // caso libro sin copuas\r\n    let libro2 = \u0026biblioteca.copias_disponibles[2].libro.clone();\r\n    let result = biblioteca.incrementar_cantidad_copias(libro2);\r\n    assert_eq!(result, Some(true));\r\n    assert_eq!(biblioteca.copias_disponibles[2].cantidad, 1);\r\n\r\n    // prueba con un libro que no existe;\r\n    let libro_inexistente: Libro = Libro {\r\n      isbn: 0001,\r\n      titulo: String::from(\"Un Libro\"),\r\n      autor: \"Un Autor\".to_string(),\r\n      num_paginas: 0,\r\n      genero: Genero::Otros(\"Desconocido\".to_string())\r\n    };\r\n\r\n    let result = biblioteca.incrementar_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(result, None);\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_contar_prestamos_cliente() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Roman\");\r\n    let cliente2 = crear_cliente_prueba(\"Flor\");\r\n        \r\n    // Caso de biblioteca sin préstamos\r\n    let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\r\n    assert_eq!(cantidad, None);\r\n        \r\n    // Preparar algunos prestamos\r\n    let prestamo1 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    let prestamo2 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[1].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(20, 5, 2025),\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n      \r\n    let prestamo3 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(10, 5, 2025),\r\n      fecha_devolucion: Some(Fecha::new(5, 5, 2025)),\r\n      estado: EstadoPrestamo::Devuelto, // Este no deberia contarse\r\n    };\r\n      \r\n    biblioteca.prestamos.push(prestamo1);\r\n    biblioteca.prestamos.push(prestamo2);\r\n    biblioteca.prestamos.push(prestamo3);\r\n      \r\n    // Caso normal: cliente con pretamos\r\n    let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\r\n    assert_eq!(cantidad, Some(2));\r\n      \r\n    // Caso de cliente sin prestamos\r\n    let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente2);\r\n    assert_eq!(cantidad, Some(0));\r\n  }\r\n\r\n  #[test]\r\n  fn test_realizar_prestamo() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Juan\");\r\n        \r\n    // Caso normal: realizar prestamo exitoso\r\n    let fecha_vencimiento = Fecha::new(15, 5, 2025);\r\n    let resultado = biblioteca.realizar_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente, fecha_vencimiento.clone());\r\n    assert_eq!(resultado, true);\r\n    assert_eq!(biblioteca.prestamos.len(), 1);\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, 2); \r\n        \r\n    // Caso de error: intentar prestar libro sin copias disponibles\r\n    let resultado = biblioteca.realizar_prestamo(\u0026biblioteca.copias_disponibles[2].libro.clone(), \u0026cliente, fecha_vencimiento.clone());\r\n    assert_eq!(resultado, false); \r\n        \r\n    // Caso limite: cliente con 5 préstamos activos\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Pedro\");\r\n        \r\n    // Crear 5 préstamos activos\r\n    for _ in 0..5 {\r\n      let prestamo = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n       };\r\n      biblioteca.prestamos.push(prestamo);\r\n    }\r\n        \r\n    // Intentar hacer el sexto préstamo\r\n    let resultado = biblioteca.realizar_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente, fecha_vencimiento);\r\n    assert_eq!(resultado, false); // Debería fallar, pero con la lógica actual sería true\r\n  }\r\n\r\n  #[test]\r\n  fn test_ver_prestamos_a_vencer() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Juan\");\r\n        \r\n    // FECHA\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32);\r\n\r\n    let mut fecha1 = hoy.clone();\r\n    fecha1.sumar_dias(1);\r\n    \r\n    let mut fecha2 =hoy.clone();\r\n    fecha2.sumar_dias(10);\r\n        \r\n    // Crear préstamos con diferentes fechas de vencimiento\r\n    let prestamo1 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: fecha1,\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    let prestamo2 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[1].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: fecha2,\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    biblioteca.prestamos.push(prestamo1);\r\n    biblioteca.prestamos.push(prestamo2);\r\n        \r\n    // Caso normal: prestamos a vencer\r\n    let prestamos_a_vencer = biblioteca.ver_prestamos_a_vencer(5);\r\n    assert_eq!(prestamos_a_vencer.len(), 2);\r\n  }\r\n    \r\n  #[test]\r\n  fn test_ver_prestamos_vencidos() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Pedro\");\r\n\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32);\r\n\r\n    // Préstamo vencido ayer\r\n    let mut fecha_ayer = hoy.clone();\r\n    fecha_ayer.restar_dias(1);\r\n\r\n    let prestamo_vencido = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_ayer,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n\r\n    // Préstamo vencido ayer PERO SE DEVOLVIO\r\n    let mut fecha_ayer = hoy.clone();\r\n    fecha_ayer.restar_dias(1);\r\n\r\n    let prestamo_vencido_devuelto = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_ayer,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::Devuelto,\r\n    };\r\n\r\n    // Préstamo que vence mañana (todavía no vencido)\r\n    let mut fecha_manana = hoy.clone();\r\n    fecha_manana.sumar_dias(1);\r\n\r\n    let prestamo_a_vencer = Prestamo {\r\n        libro: biblioteca.copias_disponibles[2].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_manana,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n\r\n    biblioteca.prestamos.push(prestamo_vencido);\r\n    biblioteca.prestamos.push(prestamo_a_vencer);\r\n    biblioteca.prestamos.push(prestamo_vencido_devuelto);\r\n\r\n    let resultado = biblioteca.ver_prestamos_vencidos();\r\n    assert_eq!(resultado.len(), 1);\r\n    \r\n  }\r\n    \r\n  #[test]\r\n  fn test_buscar_prestamo() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente1 = crear_cliente_prueba(\"Juan\");\r\n    let cliente2 = crear_cliente_prueba(\"Ana\");\r\n        \r\n    // Crear algunos préstamos\r\n    let prestamo1 = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente1.clone(),\r\n        fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    let prestamo2 = Prestamo {\r\n        libro: biblioteca.copias_disponibles[1].libro.clone(),\r\n        cliente: cliente1.clone(),\r\n        fecha_vencimiento: Fecha::new(20, 5, 2025),\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    biblioteca.prestamos.push(prestamo1.clone());\r\n    biblioteca.prestamos.push(prestamo2.clone());\r\n        \r\n    // Caso normal: buscar préstamo existente\r\n    let resultado = biblioteca.buscar_prestamo(\u0026biblioteca.copias_disponibles[0].libro, \u0026cliente1);\r\n    assert!(resultado.is_some());\r\n    assert!(resultado.unwrap().es_igual(\u0026prestamo1));\r\n        \r\n    // Caso de error: buscar préstamo con libro existente pero cliente diferente\r\n    let resultado = biblioteca.buscar_prestamo(\u0026biblioteca.copias_disponibles[0].libro, \u0026cliente2);\r\n    assert!(resultado.is_none());\r\n        \r\n    // Caso de error: buscar préstamo con libro inexistente\r\n    let libro_inexistente = Libro {\r\n        isbn: 1111111111,\r\n        titulo: String::from(\"Libro Inexistente\"),\r\n        autor: String::from(\"Autor Desconocido\"),\r\n        num_paginas: 100,\r\n        genero: Genero::Otros(String::from(\"Desconocido\")),\r\n    };\r\n    let resultado = biblioteca.buscar_prestamo(\u0026libro_inexistente, \u0026cliente1);\r\n    assert!(resultado.is_none());\r\n  }\r\n    \r\n\r\n  #[test]\r\n  fn test_devolver_prestamo() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Juan\");\r\n    \r\n    // Preparar el estado inicial\r\n    let cantidad_inicial = biblioteca.copias_disponibles[0].cantidad;\r\n        \r\n    // Crear un prestamo\r\n    let prestamo = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    biblioteca.prestamos.push(prestamo);\r\n        \r\n    // Caso normal: devolver préstamo exitosamente\r\n    let resultado = biblioteca.devolver_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente);\r\n    assert_eq!(resultado, true);\r\n        \r\n    // Verificar que la cantidad de copias disponibles aumentó\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, cantidad_inicial + 1);\r\n    \r\n    // Verificar que el estado del préstamo cambió a Devuelto\r\n    if let Some(prestamo_actualizado) = biblioteca.buscar_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente) { \r\n      assert!(prestamo_actualizado.estado.es_igual(\u0026EstadoPrestamo::Devuelto));\r\n      assert!(prestamo_actualizado.fecha_devolucion.is_some());\r\n    } else {\r\n      panic!(\"No se encontró el préstamo después de devolverlo\");\r\n    }\r\n        \r\n    // Caso de error: intentar devolver un préstamo ya devuelto\r\n    let resultado = biblioteca.devolver_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente);\r\n    assert_eq!(resultado, true); // Debería ser false si se comprueba que ya está devuelto\r\n        \r\n    // Caso de error: intentar devolver un préstamo inexistente\r\n    let libro_inexistente = Libro {\r\n        isbn: 1111111111,\r\n        titulo: String::from(\"Libro Inexistente\"),\r\n        autor: String::from(\"Autor Desconocido\"),\r\n        num_paginas: 100,\r\n        genero: Genero::Otros(String::from(\"Desconocido\")),\r\n    };\r\n    let resultado = biblioteca.devolver_prestamo(\u0026libro_inexistente, \u0026cliente);\r\n    assert_eq!(resultado, false);\r\n        \r\n    let cliente_inexistente = crear_cliente_prueba(\"Inexistente\");\r\n    let resultado = biblioteca.devolver_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente_inexistente);\r\n    assert_eq!(resultado, false);\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","mod.rs"],"content":"// pub mod ej01;\r\n// pub mod ej02;\r\n pub mod ej03;\r\n// pub mod ej04;\r\n// pub mod ej05;\r\n// pub mod ej06;\r\n// pub mod nicolas_carrica_v2;\r\n// pub mod ej07;\r\n// pub mod ej07v2;\r\n// //pub mod ej08;\r\n// pub mod ej08v2;\r\n// //pub mod ej09;\r\n// pub mod ej09v2;\r\n// pub mod ej10;","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","nicolas_carrica_v2.rs"],"content":"// Escribir un programa que defina una estructura Estudiante que tenga campos para el \r\n// nombre, el número de identificación y las calificaciones de exámenes. De cada Examen se \r\n// conoce el nombre de la materia y la nota. Para dichas estructuras implemente los siguientes \r\n// métodos: \r\n \r\n// ❖  Examen: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Examen y lo \r\n// retorna. \r\n// ❖  Estudiante: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Estudiante y lo \r\n// retorna. \r\n// ➢  obtener_promedio: retorna el promedio de las notas. \r\n// ➢  obtener_calificacion_mas_alta: retorna la nota más alta. \r\n// ➢  obtener_calificacion_mas_baja: retorna la nota más baja. \r\n \r\n// Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n\r\nstruct Examen {\r\n  nombre_de_materia: String,\r\n  nota: f32,\r\n}\r\n\r\nimpl Examen {\r\n  fn new (nombre_de_materia: String, nota: f32) -\u003e Examen{\r\n    Examen {\r\n      nombre_de_materia,\r\n      nota,\r\n    }\r\n  }\r\n} \r\nstruct Estudiante{\r\n  nombre_estudiante: String,\r\n  id: u32,\r\n  calificaciones: Vec\u003cExamen\u003e\r\n}\r\n\r\nstruct Informe {\r\n  id_estudiante: u32,\r\n  nombre_estudiante: String,\r\n  examenes_rendidos: u32,\r\n  promedio_notas: f32,\r\n  nota_mas_alta: f32,\r\n  materia_mas_alta: String,\r\n  nota_mas_baja: f32,\r\n  materia_mas_baja: String,\r\n}\r\n\r\nimpl Informe {\r\n  fn new(id_estudiante: u32, nombre_estudiante: String, examenes_rendidos: u32, promedio_notas: f32, nota_mas_alta: f32, materia_mas_alta: String, nota_mas_baja: f32, materia_mas_baja: String) -\u003e Informe{\r\n    Informe {\r\n      id_estudiante,\r\n      nombre_estudiante,\r\n      examenes_rendidos,\r\n      promedio_notas,\r\n      nota_mas_alta,\r\n      materia_mas_alta,\r\n      nota_mas_baja,\r\n      materia_mas_baja\r\n    }\r\n\r\n  }\r\n}\r\n\r\nimpl Estudiante{\r\n  fn new(nombre_estudiante: String, id: u32, calificaciones: Vec\u003cExamen\u003e)-\u003e Estudiante {\r\n    Estudiante{\r\n      nombre_estudiante,\r\n      id,\r\n      calificaciones,\r\n    }\r\n  }\r\n\r\n  fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut suma: f32 = 0.0;\r\n    for examen in \u0026self.calificaciones{\r\n      suma+=examen.nota;\r\n    }\r\n    let dim_f = self.calificaciones.len();\r\n    Some(suma/dim_f as f32)\r\n  }\r\n\r\n  fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    \r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut max:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e max {\r\n        max = examen.nota;\r\n      }\r\n    }\r\n    return Some(max);\r\n  }\r\n\r\n  fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut min:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003c min {\r\n        min = examen.nota;\r\n      }\r\n    }\r\n    return Some(min);\r\n  }\r\n  \r\n  fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None\r\n    }\r\n\r\n    let promedio = match self.obtener_promedio() {\r\n      Some(valor) =\u003e valor,\r\n      None =\u003e return None\r\n    };\r\n\r\n    \r\n    let mut nota_min: f32 = self.calificaciones[0].nota;\r\n    let mut nota_max: f32 = self.calificaciones[0].nota;\r\n\r\n    let mut nombre_materia_max = self.calificaciones[0].nombre_de_materia.clone();\r\n    let mut nombre_materia_min = self.calificaciones[0].nombre_de_materia.clone();\r\n  \r\n\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e nota_max {\r\n        nota_max = examen.nota;\r\n        nombre_materia_max = examen.nombre_de_materia.clone();\r\n      }\r\n      if examen.nota \u003c nota_min {\r\n        nota_min = examen.nota;\r\n        nombre_materia_min = examen.nombre_de_materia.clone();\r\n      }\r\n    }\r\n\r\n    let informe_est = Informe::new(\r\n      self.id,\r\n      self.nombre_estudiante.clone(),\r\n      self.calificaciones.len() as u32,\r\n      promedio,\r\n      nota_max,\r\n      nombre_materia_max,\r\n      nota_min,\r\n      nombre_materia_min\r\n    );\r\n    \r\n\r\n    return Some(informe_est);\r\n    // Agegue el id del estsudiante al informe, me lo habia comido en el examen.\r\n    // en lugar de iniciar el informe con datos vacios y luego asignarlos, inicie el informe con los datos correspondientes luego de obtenerlos.\r\n    // termine de agregar los test al final\r\n  }\r\n    \r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod estudiante_tests{\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones,\r\n    );\r\n\r\n    assert_eq!(estudiante.nombre_estudiante, \"Nicolas\");\r\n    assert_eq!(estudiante.id, 25458);\r\n    assert_eq!(estudiante.calificaciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_promedio(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_promedio(), Some(7.0));\r\n\r\n    //caso vector vacio\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_promedio(),None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_alta(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 8.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(8.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_alta(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_baja(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 5.0),\r\n      Examen::new(\"Programcion\".to_string(), 9.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(5.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_baja(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0),\r\n      Examen::new(\"Seminario Rust\".to_string(), 6.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    match estudiante.generar_informe(){\r\n      Some(informe) =\u003e {\r\n        assert_eq!(informe.nota_mas_alta, 8.0);\r\n        assert_eq!(informe.nota_mas_baja, 6.0);\r\n        assert_eq!(informe.nombre_estudiante, \"Nicolas\");\r\n        assert_eq!(informe.id_estudiante, 25458);\r\n        assert_eq!(informe.materia_mas_alta, \"Programcion\");\r\n        assert_eq!(informe.materia_mas_baja, \"Seminario Rust\");\r\n        assert_eq!(informe.promedio_notas, 7.0);\r\n        assert_eq!(informe.examenes_rendidos, 4);\r\n      }\r\n      None =\u003e panic!(\"Este informe debería ser None\")\r\n    }\r\n     \r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe_vacio(){\r\n    let calificaciones = Vec::new();\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    let informe_vacio = estudiante.generar_informe();\r\n    assert!(informe_vacio.is_none());\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej01.rs"],"content":"// 1- Escriba una función que reciba un vector de números enteros y retorna la cantidad de \r\n// números primos. Cree un trait para la determinación del número primo e impleméntelo \r\n// según corresponda. Utilice la función iter sobre el vector y aplique un closure para \r\n// resolverlo.\r\n\r\ntrait EsPrimo {\r\n    fn es_primo(\u0026self) -\u003e bool;\r\n}\r\n\r\nimpl EsPrimo for i32 {\r\n    fn es_primo(\u0026self) -\u003e bool {\r\n        if *self \u003c= 1 {\r\n            return false\r\n        }\r\n\r\n        for n in 2..(self/2) + 1 {\r\n            if self % n == 0 {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        true\r\n    }\r\n}\r\n\r\nfn cantidad_primos\u003cT\u003e(numeros: \u0026Vec\u003cT\u003e) -\u003e i32 where T: EsPrimo {\r\n    let mut cantidad = 0;\r\n    numeros.iter().for_each(|n| {\r\n        if n.es_primo() {\r\n            cantidad += 1;\r\n        }\r\n    });\r\n\r\n    cantidad\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_cantidad_primos_vacia() {\r\n        let vector: Vec\u003ci32\u003e = Vec::new();\r\n        assert_eq!(cantidad_primos(\u0026vector), 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_cantidad_primos_mixto() {\r\n        let vector = vec![1, 2, 4, 6, 7, 9];\r\n        assert_eq!(cantidad_primos(\u0026vector), 2);\r\n    }\r\n}","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":12,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":17,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":29,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":13,"coverable":13},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej02.rs"],"content":"// 2- Dado el siguiente struct: \r\n \r\n// struct Persona\u003c'a\u003e{ \r\n//     nombre:\u0026'a str, \r\n//     apellido:\u0026'a str, \r\n//     direccion:\u0026'a str, \r\n//     ciudad:\u0026'a str, \r\n//     salario:f64, \r\n//     edad:u8,  \r\n// } \r\n \r\n// a- Escriba una función que reciba un vector de personas y otro parámetro que indica un \r\n// salario y retorna un listado de personas donde el salario es mayor al parámetro recibido. \r\n \r\n// b- Escriba una función que reciba un vector de personas, edad y el nombre de una  ciudad, \r\n// y retorna las personas mayores al parámetro edad y que viven en el valor del parámetro \r\n// ciudad. \r\n \r\n// c- Escriba una función que reciba un vector de personas y un nombre de una ciudad y \r\n// retorna true si todas las personas viven en la ciudad pasada por parámetro, false caso \r\n// contrario. \r\n \r\n// d- Escriba una función que reciba un vector de personas y un nombre de una ciudad y \r\n// retorna true si al menos vive una persona en la ciudad pasada por parámetro,, false caso \r\n// contrario.\r\n\r\n// e- Escriba una función que reciba un arreglo de personas y una persona y retorna true si la \r\n// persona existe en el arreglo, false caso contrario \r\n \r\n \r\n// f -Escriba una función que reciba un arreglo de personas y retorna un arreglo con las \r\n// edades de las personas. \r\n \r\n// g - Escriba una función que reciba un arreglo de personas y retorna la persona con el menor \r\n// salario y la persona con el mayor salario, en caso de que haya más de una persona en cada \r\n// categoría desempatar por la edad más grande. \r\n \r\n// Nota: Implemente todos los métodos y traits que considere para resolver los ejercicios. \r\n// Todos los ejercicios deben resolverse con iterator y closure. \r\n#[derive(Debug, PartialEq, Clone)]\r\nstruct Persona\u003c'a\u003e {\r\n    nombre: \u0026'a str,\r\n    apellido: \u0026'a str,\r\n    direccion: \u0026'a str,\r\n    ciudad: \u0026'a str,\r\n    salario: f64,\r\n    edad: u8,\r\n}\r\n\r\nimpl\u003c'a\u003e Persona\u003c'a\u003e {\r\n    fn new(\r\n        nombre: \u0026'a str,\r\n        apellido: \u0026'a str,\r\n        direccion: \u0026'a str,\r\n        ciudad: \u0026'a str,\r\n        salario: f64,\r\n        edad: u8,\r\n    ) -\u003e Persona\u003c'a\u003e {\r\n        Persona {\r\n            nombre,\r\n            apellido,\r\n            direccion,\r\n            ciudad,\r\n            salario,\r\n            edad,\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nfn personas_salario_mayor\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, salario: f64) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e {\r\n    personas\r\n        .iter()\r\n        .filter(|persona| persona.salario \u003e salario)\r\n        .collect()\r\n}\r\n\r\nfn personas_mayor_edad_ciudad\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, edad: u8, ciudad: \u0026'a str) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e {\r\n    personas\r\n        .iter()\r\n        .filter(|persona| persona.edad \u003e edad \u0026\u0026 persona.ciudad == ciudad)\r\n        .collect()\r\n}\r\n\r\nfn personas_en_ciudad\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, ciudad: \u0026'a str) -\u003e bool {\r\n    personas.iter().all(|persona| persona.ciudad == ciudad)\r\n}\r\n\r\nfn alguna_persona_en_ciudad\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, ciudad: \u0026'a str) -\u003e bool {\r\n    personas.iter().any(|persona| persona.ciudad == ciudad)\r\n}\r\n\r\nfn existe_persona\u003c'a\u003e(personas: \u0026'a [Persona\u003c'a\u003e], persona: \u0026Persona\u003c'a\u003e) -\u003e bool {\r\n    personas.iter().any(|p| p == persona)\r\n}\r\n\r\nfn edades_personas\u003cconst N: usize\u003e(personas: \u0026[Persona; N]) -\u003e Option\u003c[u8; N]\u003e {\r\n    personas\r\n        .iter()\r\n        .map(|persona| persona.edad)\r\n        .collect::\u003cVec\u003cu8\u003e\u003e()\r\n        .try_into()\r\n        .ok()\r\n}\r\n\r\nfn persona_mayor_y_menor_salario\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e) -\u003e Option\u003c[\u0026'a Persona\u003c'a\u003e; 2]\u003e {\r\n    let minimo = personas.iter().min_by(|per1, per2|{\r\n        per1.salario\r\n        .partial_cmp(\u0026per2.salario)\r\n        .expect(\"Comparacion no posible\")// si es none paniquea\r\n        .then_with(|| {\r\n            per2.edad\r\n            .partial_cmp(\u0026per1.edad)// desempata por edad;\r\n            .expect(\"Comparacion de edad no fue posible\")\r\n        })        \r\n    });\r\n\r\n    let maximo = personas.iter().max_by(|per1, per2|{\r\n        per1.salario\r\n        .partial_cmp(\u0026per2.salario)\r\n        .expect(\"Comparacion no posible\")// si es none paniquea\r\n        .then_with(|| {\r\n            per1.edad\r\n            .partial_cmp(\u0026per2.edad)// desempata por edad;\r\n            .expect(\"Comparacion de edad no fue posible\")\r\n        })        \r\n    });\r\n\r\n    if let (Some(min), Some(max)) = (minimo, maximo) {\r\n        Some([min, max])\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    fn crear_persona\u003c'a\u003e(\r\n    nombre: \u0026'a str,\r\n    apellido: \u0026'a str,\r\n    direccion: \u0026'a str,\r\n    ciudad: \u0026'a str,\r\n    salario: f64,\r\n    edad: u8,\r\n    ) -\u003e Persona\u003c'a\u003e {\r\n        Persona::new(nombre, apellido, direccion, ciudad, salario, edad)\r\n    }\r\n\r\n    #[test]\r\n    fn test_persona_mayor_y_menor_salario() {\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n            crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28),\r\n        ];\r\n        let personas_mayor_y_menor = persona_mayor_y_menor_salario(\u0026personas);\r\n        assert_eq!(personas_mayor_y_menor, Some([\u0026personas[2], \u0026personas[1]]));\r\n\r\n        // vector personas vacio:\r\n        personas.clear();\r\n        assert_eq!(persona_mayor_y_menor_salario(\u0026personas), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_personas_salario_mayor(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n            crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28),\r\n        ];\r\n        let personas_mayor = personas_salario_mayor(\u0026personas, 5000.0);\r\n        assert_eq!(personas_mayor, vec![\u0026personas[1], \u0026personas[3]]);\r\n\r\n        // vector personas vacio:\r\n        personas.clear();\r\n        assert_eq!(personas_salario_mayor(\u0026personas, 0.0).len(),0);\r\n\r\n\r\n    }\r\n\r\n    #[test]\r\n    fn test_persona_mayor_y_menor_salario_con_empate() {\r\n        let personas = vec![\r\n            crear_persona(\"Nico\", \"Carri\", \"Calle 8\", \"La Plata\", 4000.0, 30), // menor salario, edad mayor\r\n            crear_persona(\"Flori\", \"Ore\", \"Calle 3\", \"La Plata\", 4000.0, 20), // menor salario, edad menor\r\n            crear_persona(\"Marce\", \"Pin\", \"Calle 119\", \"La Plata\", 7000.0, 28), // mayor salario, edad menor\r\n            crear_persona(\"Sanchez\", \"Kunfu\", \"Calle 154\", \"La Plata\", 7000.0, 35), // mayor salario, edad mayor\r\n        ];\r\n\r\n        let resultado = persona_mayor_y_menor_salario(\u0026personas);\r\n\r\n        // Menor salario: Nico vs Flori -\u003e Nico (edad mayor)\r\n        // Mayor salario: Marce vs Sanchez -\u003e Sanchez (edad mayor)\r\n        assert_eq!(resultado, Some([\u0026personas[0], \u0026personas[3]]));\r\n    }\r\n\r\n    #[test]\r\n    fn tes_personas_mayor_edad(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n            crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28),\r\n        ];\r\n        let vector = personas_mayor_edad_ciudad(\u0026personas, 25, \"Ciudad A\");\r\n        \r\n        assert_eq!(vector.len(),1);\r\n        assert_eq!(vector, vec![\u0026personas[1]]);\r\n\r\n        // vector personas vacio:\r\n        personas.clear();\r\n        assert_eq!(personas_mayor_edad_ciudad(\u0026personas, 0, \"Ciudad A\").len(),0);\r\n    }\r\n\r\n    \r\n\r\n    #[test]\r\n    fn test_personas_en_ciudad(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n        ];\r\n        let mut existe = personas_en_ciudad(\u0026personas, \"Ciudad A\");\r\n        assert_eq!(existe, true);\r\n\r\n        let p1 = crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20);\r\n        let p2 =  crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28);\r\n\r\n        personas.push(p1);\r\n        personas.push(p2);\r\n\r\n        existe = personas_en_ciudad(\u0026personas, \"Ciudad A\");\r\n        assert_eq!(existe, false);\r\n\r\n    }\r\n\r\n    #[test]\r\n    fn test_alguna_persona_en_ciudad(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n        ];\r\n        let mut existe = alguna_persona_en_ciudad(\u0026personas, \"Ciudad A\");\r\n        assert_eq!(existe, true);\r\n\r\n        let p1 = crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20);\r\n        let p2 =  crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28);\r\n\r\n        personas.push(p1);\r\n        personas.push(p2);\r\n\r\n        existe = alguna_persona_en_ciudad(\u0026personas, \"Ciudad B\");\r\n        assert_eq!(existe, true);\r\n\r\n        personas.clear();\r\n        existe = alguna_persona_en_ciudad(\u0026personas, \"Ciudad B\");\r\n        assert_eq!(existe, false);\r\n    }\r\n\r\n    #[test]\r\n    fn test_existe_persona(){\r\n        let p1 = crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25);\r\n        let p2 =  crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 5500.0, 28);\r\n        let p3 =  crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20);\r\n        let p4 =  crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28);\r\n        let personas = vec![p1.clone(),p2.clone(),p3.clone(),p4.clone()];\r\n\r\n        let existe = existe_persona(\u0026personas, \u0026p1);\r\n        assert_eq!(existe, true);\r\n\r\n        let personas_vacias: Vec\u003cPersona\u003e = vec![];\r\n        let existe2 = existe_persona(\u0026personas_vacias, \u0026p1);\r\n        assert_eq!(existe2, false);\r\n    }\r\n\r\n    #[test]\r\n    fn test_edades_personas(){\r\n        let personas = [\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n        ];\r\n        let edades = edades_personas(\u0026personas);\r\n        assert_eq!(edades, Some([25, 30, 20]));();\r\n\r\n        let personas_vacias:[Persona; 0] = [];\r\n        let edades2 = edades_personas(\u0026personas_vacias);\r\n        assert_eq!(edades2, Some([]));\r\n\r\n    }\r\n\r\n\r\n}\r\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":74,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":81,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":86,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":89,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":90,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":100,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":106,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":107,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":108,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":110,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":111,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":119,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":120,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":121,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":122,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":123,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":129,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":35,"coverable":36},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej03.rs"],"content":"// 3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones \r\n// (Basic, Clasic, Super) a sus usuarios. Cada suscripción tiene un costo mensual y una \r\n// duración de meses y una fecha de inicio, además los usuarios pueden pagar por sus \r\n// suscripciones con distintos medios de pago que son Efectivo, MercadoPago, Tarjeta de \r\n// Crédito, Transferencia Bancaria, Cripto. Cada medio de pago tiene sus datos \r\n// correspondientes a excepción de Efectivo. \r\n// Los usuarios solo pueden tener una suscripción activa a la vez. \r\n \r\n// Implemente las estructuras, funciones asociadas y traits necesarios para resolver las \r\n// siguientes acciones: \r\n \r\n// ➢  Crear un usuario con una determinada suscripción y medio de pago. \r\n// ➢  Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic \r\n// pasa a Clasic y si está en Clasic pasa a Super. \r\n// ➢  Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la \r\n// suscripción es del tipo Basic al hacerlo se cancelará la suscripción. \r\n// ➢  Dado un usuario cancelar la suscripción. \r\n// ➢  Saber el medio de pago que es más utilizado por los usuarios sobre las \r\n// suscripciones activas \r\n// ➢  Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones \r\n// activas. \r\n// ➢  Saber cuál fue el medio de pago más utilizado. \r\n// ➢  Saber cuál fue la suscripción más contratada.\r\nuse std::collections::HashMap;\r\n\r\nuse crate::tp03::ej03::Fecha;\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\r\nenum MedioDePago {\r\n    Efectivo,\r\n    MercadoPago {cvu: String},\r\n    TarjetaDeCredito {numero: String, cvv: String},\r\n    TransferenciaBancaria {cbu: String},\r\n    Cripto {direccion: String},\r\n}\r\n\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\r\nenum TipoSuscripcion {\r\n    Basic,\r\n    Clasic,\r\n    Super,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Suscripcion {\r\n    tipo: TipoSuscripcion,\r\n    costo_mensual: f32,\r\n    meses: u8,\r\n    inicio: Fecha,\r\n}\r\nstruct Usuario {\r\n    id: u32,\r\n    suscripcion: Option\u003cSuscripcion\u003e,\r\n    pago: MedioDePago,\r\n}\r\n\r\nimpl Usuario { // preferi implementar esto en un struc de usuario, luego desde la plataforma al llamar al usuario aplicarle los metedos corresponditnes.\r\n    fn new(id: u32, suscripcion: Option\u003cSuscripcion\u003e, pago: MedioDePago) -\u003e Self {\r\n        Usuario {\r\n            id,\r\n            suscripcion,\r\n            pago,\r\n        }\r\n    }\r\n\r\n    fn upgrade(\u0026mut self) {\r\n        if let Some(ref mut susc) = self.suscripcion {\r\n            susc.tipo = match susc.tipo {\r\n                TipoSuscripcion::Basic =\u003e TipoSuscripcion::Clasic,\r\n                TipoSuscripcion::Clasic =\u003e TipoSuscripcion::Super,\r\n                TipoSuscripcion::Super =\u003e TipoSuscripcion::Super,\r\n            };\r\n        }\r\n    }\r\n\r\n    fn downgrade(\u0026mut self) {\r\n        if let Some(ref mut susc) = self.suscripcion {\r\n            susc.tipo = match susc.tipo {\r\n                TipoSuscripcion::Super =\u003e TipoSuscripcion::Clasic,\r\n                TipoSuscripcion::Clasic =\u003e TipoSuscripcion::Basic,\r\n                TipoSuscripcion::Basic =\u003e {\r\n                    self.suscripcion = None;\r\n                    return;\r\n                },\r\n            };\r\n        }    \r\n    }\r\n\r\n    fn cancelar_suscripcion(\u0026mut self) {\r\n        self.suscripcion = None;\r\n    }\r\n}\r\n\r\nstruct Plataforma {\r\n    usuarios: Vec\u003cUsuario\u003e,\r\n}\r\n\r\n\r\nimpl Plataforma {\r\n    fn new() -\u003e Self {\r\n        Plataforma {\r\n            usuarios: Vec::new(),\r\n        }\r\n    }\r\n// el uso de hashmap es para poder contar la cantidad de veces que aparece un elemento en un vector.\r\n    fn medio_pago_mas_usado_activo(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        let mut contador = HashMap::new();\r\n        for usuario in \u0026self.usuarios {\r\n            if usuario.suscripcion.is_some() {\r\n                *contador.entry(usuario.pago.clone()).or_insert(0) += 1;\r\n            }\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n    fn suscripcion_activa_mas_contradada(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        let mut contador = HashMap::new();\r\n        for usuario in \u0026self.usuarios {\r\n            if let Some(susc) = \u0026usuario.suscripcion {\r\n                *contador.entry(susc.tipo.clone()).or_insert(0) += 1;\r\n            }\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n    fn medio_pago_mas_usado_total(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        let mut contador = HashMap::new();\r\n        for user in \u0026self.usuarios {\r\n            *contador.entry(user.pago.clone()).or_insert(0) += 1;\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n    fn suscripcion_mas_contratada_total(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        let mut contador = HashMap::new();\r\n        for user in \u0026self.usuarios {\r\n            if let Some(s) = \u0026user.suscripcion {\r\n                *contador.entry(s.tipo.clone()).or_insert(0) += 1;\r\n            }\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    fn suscripcion_basic() -\u003e Suscripcion {\r\n        Suscripcion {\r\n            tipo: TipoSuscripcion::Basic,\r\n            costo_mensual: 1000.0,\r\n            meses: 3,\r\n            inicio: Fecha::new(22, 05, 2025),\r\n        }\r\n    }\r\n\r\n    fn suscripcion_clasic() -\u003e Suscripcion {\r\n        Suscripcion {\r\n            tipo: TipoSuscripcion::Clasic,\r\n            costo_mensual: 2000.0,\r\n            meses: 6,\r\n            inicio: Fecha::new(22, 05, 2025),\r\n        }\r\n    }\r\n\r\n    fn suscripcion_super() -\u003e Suscripcion {\r\n        Suscripcion {\r\n            tipo: TipoSuscripcion::Super,\r\n            costo_mensual: 3000.0,\r\n            meses: 12,\r\n            inicio: Fecha::new(22, 05, 2025),\r\n        }\r\n    }\r\n\r\n    fn crear_usuario(id: u32, suscripcion: Option\u003cSuscripcion\u003e, pago: MedioDePago) -\u003e Usuario {\r\n        Usuario::new(id, suscripcion, pago)\r\n    }\r\n\r\n    #[test]\r\n    fn test_upgrade() {\r\n        let mut usuario = crear_usuario(1, Some(suscripcion_basic()), MedioDePago::Efectivo);\r\n        usuario.upgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Clasic);\r\n        }\r\n\r\n        usuario.upgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Super);\r\n        }\r\n\r\n        usuario.upgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Super);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_downgrade() {\r\n        let mut usuario = crear_usuario(1, Some(suscripcion_super()), MedioDePago::Efectivo);\r\n        usuario.downgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Clasic);\r\n        }\r\n\r\n        usuario.downgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Basic);\r\n        }\r\n\r\n        usuario.downgrade();\r\n        \r\n        assert!(usuario.suscripcion.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cancelar_suscripcion() {\r\n        let mut usuario = crear_usuario(1, Some(suscripcion_super()), MedioDePago::Efectivo);\r\n        usuario.cancelar_suscripcion();\r\n        \r\n        assert!(usuario.suscripcion.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn testar_plataforma(){\r\n        let mut plataforma = Plataforma::new();\r\n        plataforma.usuarios.push(crear_usuario(1, Some(suscripcion_basic()), MedioDePago::Efectivo));\r\n        plataforma.usuarios.push(crear_usuario(2, Some(suscripcion_clasic()), MedioDePago::TarjetaDeCredito { numero: \"123\".into(), cvv: \"123\".into() }));\r\n        plataforma.usuarios.push(crear_usuario(3, Some(suscripcion_super()), MedioDePago::Efectivo));\r\n        plataforma.usuarios.push(crear_usuario(4, Some(suscripcion_basic()), MedioDePago::Efectivo));\r\n        plataforma.usuarios.push(crear_usuario(5, Some(suscripcion_basic()), MedioDePago::MercadoPago { cvu: \"123\".into() }));\r\n\r\n        plataforma.usuarios[4].cancelar_suscripcion();\r\n\r\n        if let Some(mpago) = plataforma.medio_pago_mas_usado_activo() {\r\n            assert_eq!(mpago, MedioDePago::Efectivo);\r\n        }\r\n\r\n        if let Some(tipo) = plataforma.suscripcion_activa_mas_contradada(){\r\n            assert_eq!(tipo, TipoSuscripcion::Basic);\r\n        }\r\n\r\n        if let Some(mpago) = plataforma.medio_pago_mas_usado_total() {\r\n            assert_eq!(mpago, MedioDePago::Efectivo);\r\n        }\r\n\r\n        if let Some(tipo) = plataforma.suscripcion_mas_contratada_total(){\r\n            assert_eq!(tipo, TipoSuscripcion::Basic);\r\n        }\r\n\r\n    }\r\n\r\n    #[test]\r\n    fn test_plataforma_vacia(){\r\n        let plataforma = Plataforma::new();\r\n\r\n        assert!(plataforma.medio_pago_mas_usado_activo().is_none());\r\n        assert!(plataforma.suscripcion_activa_mas_contradada().is_none());\r\n        assert!(plataforma.medio_pago_mas_usado_total().is_none());\r\n        assert!(plataforma.suscripcion_mas_contratada_total().is_none());\r\n    }\r\n\r\n\r\n}\r\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":66,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":107,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":112,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":115,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":116,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":117,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":122,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":130,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":133,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":135,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":136,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":720575940379279360}}],"covered":36,"coverable":36},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej04.rs"],"content":"// 4 -Se requiere implementar un sistema de ventas de productos. De cada producto se \r\n// conoce el nombre, una categoría y un precio base, y algunos productos pueden tener \r\n// descuentos aplicables dependiendo de la categoría. Además, se debe registrar al vendedor \r\n// que realizó la venta y al cliente. De ellos se conoce nombre, apellido, dirección, dni y del \r\n// vendedor nro de legajo, antigüedad y salario. Los clientes pueden tener un beneficio de \r\n// descuento si tienen suscripción al newsletter, de ser así se tiene el correo electrónico del \r\n// mismo. \r\n \r\n// El sistema debe permitir registrar las ventas realizadas y asociar el medio de pago utilizado. \r\n// Los medios de pago aceptados son: tarjeta de crédito, tarjeta de débito, transferencia \r\n// bancaria y efectivo. \r\n \r\n \r\n// Implemente las estructuras, funciones asociadas y traits necesarios para resolver las \r\n// siguientes acciones: \r\n \r\n// ➢   Crear una venta con: fecha, cliente, vendedor, medio de pago y un listado de \r\n// productos con sus cantidades. \r\n// ➢   Calcular el precio final de una venta en base a los productos que hay en ella. Para \r\n// calcularlo tenga en cuenta que pueden haber determinados productos de alguna \r\n// categoría donde debería aplicarse un descuento. Tanto la categoría como el \r\n// porcentaje de descuento a aplicar son datos que le brinda el sistema. Es decir el \r\n// sistema tiene una lista de las categorías con el descuento a aplicar. Además se debe \r\n// aplicar un porcentaje de descuento general si el cliente tiene suscripción al \r\n// newsletter. \r\n// ➢  Para llevar un control de las ventas realizadas, se debe implementar un reporte que \r\n// permita visualizar las ventas totales por categoría de producto y otro por vendedor.","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","mod.rs"],"content":"pub mod ej01;\r\npub mod ej02;\r\npub mod ej03;","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","target","debug","build","mime_guess-e755a22b2c113b22","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","target","debug","build","mime_guess-f48582c81a56f999","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","main.rs"],"content":"mod tp02;\r\nmod tp03;\r\nmod tp04;\r\nfn main() {\r\n\r\n}\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej01.rs"],"content":"// 1-Definir la función llamada es_par que recibe como parámetro un número entero y retorna\r\n// true si el número es par, false caso contrario\r\npub fn es_par(num: i32) -\u003e bool {\r\n  let resultado = num % 2 == 0;\r\n  resultado\r\n}\r\n\r\n\r\n#[test]\r\nfn test_es_par() {\r\n    assert_eq!(es_par(2), true);\r\n    assert_eq!(es_par(3), false);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej02.rs"],"content":"// 2- Definir la función llamada es_primo que recibe un número entero positivo mayor a 1 y\r\n// retorna true si es primo, false caso contrario.\r\n\r\npub fn es_primo(num: i32) -\u003e bool {\r\n  let mut es_primo = true;\r\n  if num \u003c= 1 {\r\n    es_primo = false;\r\n  }\r\n\r\n  for i in 2..num {\r\n    if num % i == 0 {\r\n      es_primo = false;\r\n      break;\r\n    }\r\n  }\r\n  es_primo\r\n}\r\n\r\n#[test]\r\nfn test_es_primo() {\r\n    assert_eq!(es_primo(2), true);\r\n    assert_eq!(es_primo(3), true);\r\n    assert_eq!(es_primo(4), false);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej03.rs"],"content":"// 3- Definir la función llamada suma_pares que recibe como parámetro un arreglo de\r\n// números enteros y retorna la suma de los números pares.\r\n\r\npub fn suma_pares(arr: \u0026[i32]) -\u003e i32 {\r\n  let mut suma = 0;\r\n  for elemento in arr{\r\n    if elemento % 2 == 0{\r\n      suma += elemento;\r\n    }\r\n  }\r\n  suma\r\n}\r\n\r\n#[test]\r\nfn test_suma_pares() {\r\n    let numeros = [1,2,3,4,5,6];\r\n    let suma = suma_pares(\u0026numeros);\r\n    assert_eq!(suma, 12);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej04.rs"],"content":"// 4- Definir la función llamada cantidad_impares que recibe como parámetro un arreglo de\r\n// números enteros y retorna la cantidad de números impares\r\n\r\npub fn cantidad_impares(arr: \u0026[i32]) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if elemento % 2 != 0 {\r\n      cantidad += 1;\r\n    }\r\n  }\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_impares() {\r\n  let numeros = [1, 2, 3, 4, 5, 6];\r\n  let cantidad = cantidad_impares(\u0026numeros);\r\n  assert_eq!(cantidad, 3);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej05.rs"],"content":"// 5-Defina la función llamada duplicar_valores que recibe un arreglo de números flotantes y\r\n// retorna un arreglo nuevo con los valores duplicados del parámetro\r\n\r\npub fn duplicar_valores(arr: \u0026[f32]) -\u003e [f32; 5] {\r\n  let mut nuevo_arr = [0.0;5];\r\n  for i in 0..arr.len() {\r\n    nuevo_arr[i] = arr[i]*2.00;\r\n  }\r\n  nuevo_arr\r\n}\r\n\r\n#[test]\r\nfn test_duplicar_valores() {\r\n  let numeros = [1.0, 2.0, 3.0, 4.0, 5.0];\r\n  let duplicados = duplicar_valores(\u0026numeros);\r\n  assert_eq!(duplicados, [2.0, 4.0, 6.0, 8.0, 10.0]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej06.rs"],"content":"// 6-Definir la función llamada longitud_de_cadenas que recibe un arreglo de String y retorna\r\n// un arreglo con la longitud de las cadenas del parámetro, correspondiéndose en posición del\r\n// arreglo\r\n\r\npub fn longitud_de_cadenas\u003cconst N: usize\u003e(arr: \u0026[String]) -\u003e [usize;N] {\r\n  let mut nuevo_arr = [0; N];\r\n  for i in 0..arr.len() {\r\n    nuevo_arr[i] = arr[i].len();\r\n  }\r\n  nuevo_arr\r\n}\r\n\r\n#[test]\r\nfn test_longitud_de_cadenas() {\r\n  let cadenas = [\"hola\".to_string(), \"mundo\".to_string(), \"como\".to_string(), \"estas\".to_string()];\r\n  let longitudes = longitud_de_cadenas(\u0026cadenas);\r\n  assert_eq!(longitudes, [4, 5, 4, 5]);\r\n  assert_ne!(longitudes, [4, 5, 4, 6]);\r\n}\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej07.rs"],"content":"// -Definir la función llamada cantidad_de_mayores que recibe como parámetro un arreglo\r\n// de números enteros y un número entero llamado límite. Esta función retorna la cantidad de\r\n// números mayores al límite que tiene el arreglo.\r\n\r\npub fn cantidad_de_mayores(arr: \u0026[i32], limite: i32) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if *elemento \u003e limite { // el asterisco es para desreferenciar y comparar con el limite, ya que el array es una referencia\r\n      cantidad += 1;\r\n    }\r\n  }\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_de_mayores() {\r\n  let numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n  let limite = 5;\r\n  let cantidad = cantidad_de_mayores(\u0026numeros, limite);\r\n  assert_eq!(cantidad, 5);\r\n  assert_ne!(cantidad, 4);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej08.rs"],"content":"// 8- Definir la función llamada sumar_arreglos que recibe 2 arreglos del mismo tamaño de\r\n// números flotantes y retorna un nuevo arreglo que contiene la suma de los elementos de los\r\n// arreglos pasados por parámetro, correspondiendose el resultado con cada posición de los\r\n// arreglos pasados por parámetro\r\n\r\npub fn sumar_arreglos\u003cconst N: usize\u003e(arr1: \u0026[f32], arr2: \u0026[f32]) -\u003e [f32; N] {\r\n  let mut nuevo_arr = [0.0; N];\r\n  for i in 0..arr1.len() {\r\n    nuevo_arr[i] = arr1[i] + arr2[i];\r\n  }\r\n  nuevo_arr\r\n}\r\n\r\n#[test]\r\nfn test_sumar_arreglos() {\r\n  let arr1 =[1.0, 2.0, 3.0, 4.0, 5.0];\r\n  let arr2 = [2.0, 3.0, 4.0, 5.0, 6.0];\r\n  let resultado = sumar_arreglos(\u0026arr1, \u0026arr2);\r\n  assert_eq!(resultado, [3.0, 5.0, 7.0, 9.0, 11.0]);\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej09.rs"],"content":"// 9-Definir la función llamada cantidad_en_rango que recibe 3 parámetros: 1 arreglo de\r\n// enteros, un número entero llamado inferior y otro número entero llamado superior. Esta\r\n// función retorna la cantidad de números del arreglo que están entre el rango de los\r\n// parámetros inferior y superior inclusive.\r\n\r\npub fn cantidad_en_rango(arr: \u0026[i32], inferior: i32, superior:i32) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if *elemento \u003e= inferior \u0026\u0026 *elemento \u003c=superior \r\n      {\r\n        cantidad += 1;\r\n      }\r\n  }\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_en_rango() {\r\n  let numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n  let inferior = 5;\r\n  let superior = 8;\r\n  let cantidad = cantidad_en_rango(\u0026numeros, inferior, superior);\r\n  assert_eq!(cantidad, 4);\r\n  assert_ne!(cantidad, 5);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej10.rs"],"content":"// 10-Definir la función llamada cantidad_de_cadenas_mayor_a que recibe como parámetros\r\n// un arreglo de String y un entero llamado límite. Esta función retorna la cantidad de Strings\r\n// del arreglo que son de longitud mayor al parámetro límite\r\n\r\n\r\npub fn cantidad_de_cadenas_mayor_a(arr: \u0026[String], limite: i32) -\u003e i32 {\r\n  let mut cantidad = 0;\r\n  for elemento in arr {\r\n    if elemento.len() \u003e limite as usize { // Convertir limite a usize para comparar con la longitud de la cadena// consultar.\r\n      cantidad += 1;\r\n    }\r\n  }\r\n\r\n  cantidad\r\n}\r\n\r\n#[test]\r\nfn test_cantidad_de_cadenas_mayor_a() {\r\n  let cadenas = [\"hola\".to_string(), \"mundo\".to_string(), \"como\".to_string(), \"estas\".to_string(), \"hoy\".to_string()];\r\n  let limite = 4;\r\n  let cantidad = cantidad_de_cadenas_mayor_a(\u0026cadenas, limite);\r\n  assert_eq!(cantidad, 2);\r\n  assert_ne!(cantidad, 3); // cambia el valor esperado para que falle el test\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej11.rs"],"content":"// 11-Definir la función llamada multiplicar_valores que recibe como parámetro un arreglo de\r\n// enteros y otro número entero llamado factor. Esta función multiplica los valores del arreglo\r\n// por el parámetro factor modificándolo.\r\n\r\npub fn multiplicar_valores(arr: \u0026mut [i32], factor: i32) {\r\n    for elemento in arr {\r\n        *elemento *= factor; // * significa que estamos desreferenciando el puntero para acceder al valor;\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_multiplicar_valores() {\r\n    let mut numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    let factor = 2;\r\n    multiplicar_valores(\u0026mut numeros, factor);\r\n    assert_eq!(numeros, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\r\n    assert_ne!(numeros, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej12.rs"],"content":"// 12-Definir una función llamada reemplazar_pares que recibe un arreglo de enteros y\r\n// reemplaza todos los números pares por -1.\r\n\r\npub fn reemplazar_pares(arr: \u0026mut [i32]) {\r\n    for elemento in arr {\r\n        if *elemento % 2 == 0 {\r\n            *elemento = -1;\r\n        }\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_reemplazar_pares() {\r\n    let mut numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    reemplazar_pares(\u0026mut numeros);\r\n    assert_eq!(numeros, [1, -1, 3, -1, 5, -1, 7, -1, 9, -1]);\r\n    assert_ne!(numeros, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej13.rs"],"content":"// 13-Definir una función llamada ordenar_nombres que recibe un arreglo de String y los\r\n// ordena en orden alfabético.\r\n\r\npub fn ordenar_nombres(arr: \u0026mut [String]) {\r\n    arr.sort();\r\n}\r\n#[test]\r\nfn test_ordenar_nombres() {\r\n    let mut nombres = [\"Juan\".to_string(), \"Ana\".to_string(), \"Pedro\".to_string(), \"Maria\".to_string(), \"Luis\".to_string()];\r\n    ordenar_nombres(\u0026mut nombres);\r\n    assert_eq!(nombres, [\"Ana\", \"Juan\", \"Luis\", \"Maria\", \"Pedro\"]);\r\n    assert_ne!(nombres, [\"Juan\", \"Ana\", \"Pedro\", \"Maria\", \"Luis\"]);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","ej14.rs"],"content":"// 14-Definir una función llamada incrementar que recibe como parámetro un número flotante\r\n// e incrementa en 1 su valor.\r\n\r\npub fn incrementar(numero :f32 ) -\u003e f32 {\r\n    numero + 1.0\r\n}\r\n\r\n#[test]\r\nfn test_incrementar() {\r\n    let numero = 5.0;\r\n    let resultado = incrementar(numero);\r\n    assert_eq!(resultado, 6.0);\r\n    assert_ne!(resultado, 5.0);\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp02","mod.rs"],"content":"// pub mod ej01;\r\n// pub mod ej02;\r\n// pub mod ej03;\r\n// pub mod ej04;\r\n// pub mod ej05;\r\n// pub mod ej06;\r\n// pub mod ej07;\r\n// pub mod ej08;\r\n// pub mod ej09;\r\n// pub mod ej10;\r\n// pub mod ej11;\r\n// pub mod ej12;\r\n// pub mod ej13;\r\n// pub mod ej14;","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej01.rs"],"content":"// 1- Escribir un programa que defina una estructura Persona que tenga campos para el\r\n// nombre, la edad y la dirección(que puede ser nulo al momento de la creación de una\r\n// persona). Para dicha estructura implemente los siguientes métodos:\r\n// ➢ new: que pasando los parámetros correspondientes, crea una Persona y la retorna.\r\n// ➢ to_string: que retorna un string con los datos de la persona concatenados sobre el\r\n// mensaje ejecutado por ej:\r\n// person.to_string() , donde person es una variable del tipo Persona.\r\n// ➢ obtener_edad: retorna la edad de la persona.\r\n// ➢ actualizar_direccion(nueva_direccion)\r\n\r\n\r\nstruct Persona {\r\n  nombre: String,\r\n  edad: u32,\r\n  direccion: Option\u003cString\u003e, // La dirección puede ser nula al momento de la creación de una persona.\r\n}\r\n\r\nimpl Persona {\r\n  fn new (nombre: String, edad: u32, direccion: Option\u003cString\u003e) -\u003e Persona{\r\n    Persona {\r\n      nombre,\r\n      edad,\r\n      direccion,\r\n    }\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n     let mut result: String = format!(\"nombre: {}, Edad: {}\", self.nombre, self.edad);\r\n     match \u0026self.direccion { //\u0026 es para tomar la referencia de la dirección\r\n        Some(dir) =\u003e result += \u0026format!(\", Direccion: {}\", dir),\r\n        None =\u003e result += \", Direccion: No especificada\",\r\n     }\r\n      result\r\n  }\r\n\r\n  fn obtener_edad(\u0026self) -\u003e u32 {\r\n    return self.edad\r\n  }\r\n\r\n  fn actualizar_direccion(\u0026mut self, nueva_direccion: String) {\r\n    self.direccion = Some(nueva_direccion);\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod persona_tests {\r\n  use super::Persona;\r\n  #[test]\r\n  fn test_new_persona(){\r\n    let persona = Persona::new(\r\n      \"Nicolas\".to_string(),\r\n      35,\r\n      Some(\"Calle 41 682\".to_string()),\r\n    );\r\n\r\n    assert_eq!(persona.nombre, \"Nicolas\".to_string());\r\n    assert_eq!(persona.edad, 35);\r\n    assert_eq!(persona.direccion, Some(\"Calle 41 682\".to_string()));\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_new_persona_sin_direccion() {\r\n    let persona = Persona::new(\r\n      \"Nicolas Carrica\".to_string(),\r\n      35,\r\n      None,\r\n    );\r\n    \r\n    assert_eq!(persona.nombre, \"Nicolas Carrica\");\r\n    assert_eq!(persona.edad, 35);\r\n    assert_eq!(persona.direccion, None);\r\n  }\r\n  #[test]\r\n  fn test_to_string_con_direccion() {\r\n    let persona = Persona::new(\r\n      \"Nico Carrica\".to_string(),\r\n      34,\r\n      Some(\"Calle 119 43\".to_string()),\r\n    );\r\n      \r\n    let salida = \"nombre: Nico Carrica, Edad: 34, Direccion: Calle 119 43\";\r\n    assert_eq!(persona.to_string(), salida);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_edad(){\r\n    let persona = Persona {\r\n      nombre: \"Nicolas\".to_string(),\r\n      edad: 34,\r\n      direccion: None,\r\n    };\r\n\r\n    let edad = persona.obtener_edad();\r\n    assert_eq!(edad,34)\r\n  }\r\n  #[test]\r\n  fn test_actualizar_direccion_none(){\r\n    let mut persona = Persona {\r\n      nombre: \"Nicolas\".to_string(),\r\n      edad: 34,\r\n      direccion: None,\r\n    };\r\n    persona.actualizar_direccion(\"Calle 119\".to_string());\r\n\r\n    assert_eq!(persona.direccion, Some(\"Calle 119\".to_string()));\r\n  }\r\n\r\n  #[test]\r\n  fn test_actualizar_direccion_existente(){\r\n    let mut persona = Persona {\r\n      nombre: \"Nicolas\".to_string(),\r\n      edad:34,\r\n      direccion: Some(\"Calle 41\".to_string()),\r\n    };\r\n\r\n    persona.actualizar_direccion(\"Calle 119\".to_string());\r\n    assert_eq!(persona.direccion, Some(\"Calle 119\".to_string()));\r\n  }\r\n\r\n\r\n \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej02.rs"],"content":"// 2- Escribir un programa que defina la estructura Rectángulo que tenga campos para la \r\n// longitud y el ancho. Para dicha estructura implemente los siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Rectángulo y lo \r\n// retorna. \r\n// ➢  calcular_area: calcular el área y la retorna. \r\n// ➢  calcular_perimetro: calcula el perímetro y lo retorna. \r\n// ➢  es_cuadrado: retorna true si es cuadrado, false caso contrario\r\n#[derive(Clone, Debug)]\r\nstruct Rectangulo {\r\n  longitud: f32,\r\n  ancho: f32,\r\n}\r\n\r\nimpl Rectangulo {\r\n  fn new (longitud: f32, ancho: f32) -\u003e Rectangulo{\r\n    Rectangulo { longitud, ancho}\r\n  }\r\n\r\n  fn calcular_area(\u0026self) -\u003e f32 {\r\n    return self.ancho*self.longitud;\r\n  }\r\n\r\n  fn calcular_perimetro(\u0026self) -\u003e f32 {\r\n    return (self.ancho*2.0) + (self.longitud*2.0);\r\n  }\r\n\r\n  fn es_cuadrado(\u0026self) -\u003e bool {\r\n    return self.ancho == self.longitud;\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_rectangulo{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new(){\r\n    let rect = Rectangulo::new(5.0, 3.0);\r\n    assert_eq!(rect.longitud, 5.0);\r\n    assert_eq!(rect.ancho, 3.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_area(){\r\n    let rect = Rectangulo::new(5.0,3.0);\r\n    assert_eq!(rect.calcular_area(),15.0);\r\n  }\r\n\r\n  //test para un triangulo sin lados, debe dar error\r\n  #[test]\r\n  fn test_calcular_area_sin_lados(){\r\n    let rect = Rectangulo::new(0.0,0.0);\r\n    assert_eq!(rect.calcular_area(),0.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_perimetro(){\r\n    let rect = Rectangulo::new(5.0, 3.0);\r\n    assert_eq!(rect.calcular_perimetro(), 16.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_es_cuadrado(){\r\n    let rect1 = Rectangulo::new(4.0,4.0);\r\n    let rect2 = Rectangulo::new(2.0,5.0);\r\n    assert_eq!(rect1.es_cuadrado(), true);\r\n    assert_eq!(rect2.es_cuadrado(), false);\r\n  }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej03.rs"],"content":"// 3- Escribir un programa que defina una estructura Fecha que tenga campos para el día, el \r\n// mes y el año. Para dicha estructura implemente los siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea una Fecha y la retorna. \r\n// ➢  es_fecha_valida: retorna true si es una fecha válida, false caso contrario.//tenga en \r\n// cuenta los años bisiestos también. \r\n// ➢  es_bisiesto: retorna true si el año de la fecha pertenece a un año bisiesto. \r\n// ➢  sumar_dias(dias): suma la cantidad de días a la fecha, modificándose \r\n// ➢  restar_dias(dias): resta la cantidad de días a la fecha, modificándose \r\n// ➢  es_mayor(una_fecha): que retorna true si la fecha que recibe el mensaje es mayor a \r\n// la fecha pasada por parámetro. \r\n\r\n#[derive(Debug, Clone)]\r\npub struct Fecha {\r\n    dia: u32,\r\n    mes: u32,\r\n    anio: u32,\r\n}\r\n\r\nimpl Fecha {\r\n  pub fn new(dia: u32, mes: u32, anio: u32) -\u003e Fecha {\r\n    Fecha { dia, mes, anio }\r\n  }\r\n\r\n  fn es_bisiesto(\u0026self) -\u003e bool {\r\n    let estado: bool = (self.anio % 4 == 0) \u0026\u0026 (self.anio % 100 != 0) || (self.anio % 400 == 0);\r\n    return estado;\r\n  }\r\n\r\n  //helper para contar los dias que tiene el mes;\r\n  fn cantidad_de_dias(\u0026self, mes:u32) -\u003e u32 {\r\n    let dias_del_mes: u32 = match mes {\r\n      1 | 3 | 5 | 7 | 8 | 10 | 12 =\u003e 31,\r\n      4 | 6 | 9 | 11 =\u003e 30,\r\n      2 =\u003e {\r\n        if self.es_bisiesto() {\r\n          29\r\n        } else {\r\n          28\r\n        }\r\n      }\r\n      _=\u003e 0,\r\n    };\r\n\r\n    dias_del_mes\r\n  }\r\n\r\n  pub fn es_fecha_valida(\u0026self) -\u003e bool {\r\n    let mut estado: bool = false;\r\n    if self.mes \u003e 0 \u0026\u0026 self.mes \u003c 13 \u0026\u0026 self.anio \u003e 0 {\r\n      let dias_del_mes: u32 = self.cantidad_de_dias(self.mes);\r\n      estado = dias_del_mes !=0 \u0026\u0026 (self.dia \u003e= 1 \u0026\u0026 self.dia \u003c= dias_del_mes);\r\n    }\r\n    estado\r\n  }\r\n\r\n  pub fn sumar_dias(\u0026mut self, dias: u32){\r\n    let mut dias_del_mes = self.cantidad_de_dias(self.mes);\r\n    self.dia += dias;\r\n\r\n     // Mientras el dia actual sea mayor que la cantidad de dias en el mes actual\r\n    while self.dia \u003e dias_del_mes{\r\n      // Se le restan la cantidad de dias al mes actual\r\n      self.dia -= dias_del_mes;\r\n      // avanza al siguiente mes\r\n      self.mes+=1;\r\n      // si pasamos el mes doce, se incrementa el año y se pasa al mes 1\r\n      if self.mes \u003e 12{\r\n        self.mes=1;\r\n        self.anio+=1;\r\n      }\r\n      // se actualizan los dias del nuevo mes\r\n      dias_del_mes = self.cantidad_de_dias(self.mes);\r\n    } \r\n  }\r\n\r\n  pub fn restar_dias(\u0026mut self, mut dias: u32){\r\n    // Mientras haya días para restar\r\n    while dias !=0 {\r\n      // Si la cantidad de dias a restar es mayor o igual que el dia actual\r\n      if dias \u003e= self.dia {\r\n        dias -= self.dia;\r\n        // Retrocedemos al mes anterior\r\n        self.mes -= 1;\r\n        // Si el mes es menor que 1, retrocedemos al año anterior\r\n        if self.mes \u003c 1{\r\n          self.mes = 12;\r\n          self.anio -= 1;\r\n        }\r\n        // Actualizamos la cantidad de dias en el nuevo mes\r\n        self.dia = self.cantidad_de_dias(self.mes);\r\n      } else {\r\n        // Si la cantidad de dias a restar es menor que el dia actual,\r\n        // simplemente restamos esa cantidad de días\r\n        self.dia -= dias;\r\n        dias = 0; // Ya no quedan dias por restar\r\n      }\r\n    }\r\n  }\r\n\r\n  pub fn es_mayor(\u0026self, otra_fecha: \u0026Fecha) -\u003e bool {\r\n    let mut mayor: bool = false;\r\n    if self.anio \u003e otra_fecha.anio {\r\n        mayor = true;\r\n    } else if self.anio == otra_fecha.anio \u0026\u0026 self.mes \u003e otra_fecha.mes {\r\n        mayor = true;\r\n    } else if self.anio == otra_fecha.anio\r\n        \u0026\u0026 self.mes == otra_fecha.mes\r\n        \u0026\u0026 self.dia \u003e otra_fecha.dia\r\n    {\r\n        mayor = true;\r\n    }\r\n    mayor\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  pub fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_fecha{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new(){\r\n    let fecha = Fecha::new(17,12,1990);\r\n    assert_eq!(fecha.dia, 17);\r\n    assert_eq!(fecha.mes, 12);\r\n    assert_eq!(fecha.anio, 1990);\r\n  }\r\n\r\n  #[test]\r\n  fn test_es_biciesto(){\r\n    let fecha1 = Fecha::new(1, 1, 2020); //divisible x4 y no por 100\r\n    assert_eq!(fecha1.es_bisiesto(), true);\r\n\r\n    let fecha2 = Fecha::new(1, 1, 1900); //divisible x 100, no por 400. No bisiesto.\r\n    assert_eq!(fecha2.es_bisiesto(), false);\r\n\r\n    let fecha3 = Fecha::new(1, 1, 2000); // divisible x 400. biciesto.\r\n    assert_eq!(fecha3.es_bisiesto(), true);\r\n\r\n    let fecha4 = Fecha::new(1, 1, 2023); // no divisible x4. No biciesto.\r\n    assert_eq!(fecha4.es_bisiesto(), false);\r\n  }\r\n\r\n  #[test]\r\n  fn test_cantidad_dias(){\r\n    let fecha = Fecha::new(1, 1, 2023);\r\n    assert_eq!(fecha.cantidad_de_dias(1), 31); // enero\r\n    assert_eq!(fecha.cantidad_de_dias(3), 31); // Marzo\r\n    assert_eq!(fecha.cantidad_de_dias(5), 31); // Mayo\r\n    assert_eq!(fecha.cantidad_de_dias(7), 31); // Julio\r\n    assert_eq!(fecha.cantidad_de_dias(8), 31); // Agosto\r\n    assert_eq!(fecha.cantidad_de_dias(10), 31); // Octubre\r\n    assert_eq!(fecha.cantidad_de_dias(12), 31); // Diciembre\r\n\r\n    assert_eq!(fecha.cantidad_de_dias(4), 30); // abril\r\n    assert_eq!(fecha.cantidad_de_dias(6), 30); // Junio\r\n    assert_eq!(fecha.cantidad_de_dias(9), 30); // Septiembre\r\n    assert_eq!(fecha.cantidad_de_dias(11), 30); // Noviembre\r\n\r\n    assert_eq!(fecha.cantidad_de_dias(2), 28); // Febrero\r\n\r\n    // Febrero en año bisiesto\r\n    let fecha3 = Fecha::new(1, 2, 2020);\r\n    assert_eq!(fecha3.cantidad_de_dias(2), 29);\r\n\r\n    // Mes inválido\r\n    assert_eq!(fecha.cantidad_de_dias(13), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_es_fecha_valida(){\r\n    let fecha1 = Fecha::new(15, 10, 2023);\r\n    assert_eq!(fecha1.es_fecha_valida(), true);\r\n\r\n    let fecha2 = Fecha::new(32, 1, 2023);\r\n    assert_eq!(fecha2.es_fecha_valida(), false);\r\n\r\n    let fecha3 = Fecha::new(1, 0, 2022);\r\n    assert!(!fecha3.es_fecha_valida());\r\n  }\r\n\r\n  #[test]\r\n  fn test_sumar_dias(){\r\n    let mut fecha1 = Fecha::new(15, 10, 2023);\r\n    fecha1.sumar_dias(5);\r\n    assert_eq!(fecha1.dia,20);\r\n    assert_eq!(fecha1.mes, 10);\r\n    assert_eq!(fecha1.anio, 2023);\r\n\r\n    // Sumar días para cambiar de mes\r\n    let mut fecha2 = Fecha::new(28, 2, 2023);\r\n    fecha2.sumar_dias(5);\r\n    assert_eq!(fecha2.dia, 5);\r\n    assert_eq!(fecha2.mes, 3);\r\n    assert_eq!(fecha2.anio, 2023);\r\n\r\n    // Sumar días para cambiar de año\r\n    let mut fecha3 = Fecha::new(30, 12, 2023);\r\n    fecha3.sumar_dias(5);\r\n    assert_eq!(fecha3.dia, 4);\r\n    assert_eq!(fecha3.mes, 1);\r\n    assert_eq!(fecha3.anio, 2024);\r\n\r\n    // Sumar muchos días (cruzando varios meses y años)\r\n    let mut fecha4 = Fecha::new(1, 1, 2023);\r\n    fecha4.sumar_dias(365 + 31 + 29);  // 1 año + enero y febrero de 2024 (año bisiesto)\r\n    assert_eq!(fecha4.dia, 1);\r\n    assert_eq!(fecha4.mes, 3);\r\n    assert_eq!(fecha4.anio, 2024);\r\n  }\r\n  \r\n  #[test]\r\n  fn test_restar_dias() {\r\n    // Restar días dentro del mismo mes\r\n    let mut fecha1 = Fecha::new(15, 10, 2023);\r\n    fecha1.restar_dias(5);\r\n    assert_eq!(fecha1.dia, 10);\r\n    assert_eq!(fecha1.mes, 10);\r\n    assert_eq!(fecha1.anio, 2023);\r\n\r\n    // Restar días para cambiar de mes\r\n    let mut fecha2 = Fecha::new(3, 3, 2023);\r\n    fecha2.restar_dias(5);\r\n    assert_eq!(fecha2.dia, 26);\r\n    assert_eq!(fecha2.mes, 2);\r\n    assert_eq!(fecha2.anio, 2023);\r\n\r\n    // Restar días para cambiar de año\r\n    let mut fecha3 = Fecha::new(2, 1, 2023);\r\n    fecha3.restar_dias(5);\r\n    assert_eq!(fecha3.dia, 28);\r\n    assert_eq!(fecha3.mes, 12);\r\n    assert_eq!(fecha3.anio, 2022);\r\n\r\n    // Restar muchos días (cruzando varios meses y años)\r\n    let mut fecha4 = Fecha::new(1, 3, 2024);  // 1 de marzo de 2024 (año bisiesto)\r\n    fecha4.restar_dias(365 + 31 + 29);  // 1 año + enero y febrero de 2024\r\n    assert_eq!(fecha4.dia, 1);\r\n    assert_eq!(fecha4.mes, 1);\r\n    assert_eq!(fecha4.anio, 2023);\r\n  }\r\n\r\n  #[test]\r\n    fn test_es_mayor() {\r\n      // Fechas con años diferentes\r\n      let fecha1 = Fecha::new(1, 1, 2023);\r\n      let fecha2 = Fecha::new(1, 1, 2022);\r\n      assert!(fecha1.es_mayor(\u0026fecha2));\r\n      assert!(!fecha2.es_mayor(\u0026fecha1));\r\n\r\n      // Fechas con mismo año pero diferentes meses\r\n      let fecha3 = Fecha::new(1, 2, 2023);\r\n      let fecha4 = Fecha::new(1, 1, 2023);\r\n      assert!(fecha3.es_mayor(\u0026fecha4));\r\n      assert!(!fecha4.es_mayor(\u0026fecha3));\r\n\r\n      // Fechas con mismo año y mes pero diferentes días\r\n      let fecha5 = Fecha::new(2, 1, 2023);\r\n      let fecha6 = Fecha::new(1, 1, 2023);\r\n      assert!(fecha5.es_mayor(\u0026fecha6));\r\n      assert!(!fecha6.es_mayor(\u0026fecha5));\r\n\r\n      // Fechas iguales\r\n      let fecha7 = Fecha::new(1, 1, 2023);\r\n      let fecha8 = Fecha::new(1, 1, 2023);\r\n      assert!(!fecha7.es_mayor(\u0026fecha8));\r\n      assert!(!fecha8.es_mayor(\u0026fecha7));\r\n    }\r\n\r\n\r\n}","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":25,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":26,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":31,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":32,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":33,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":34,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":36,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":39,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":48,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":49,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":50,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":54,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":57,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":64,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":66,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":68,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":79,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":81,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":82,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":84,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":86,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":91,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":95,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":96,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":101,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":102,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":103,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}}],"covered":50,"coverable":54},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej04.rs"],"content":"// 4- Escribir un programa que defina la estructura Triángulo que tenga campos para las \r\n// longitudes de sus tres lados. Para dicha estructura implemente los siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Triángulo y lo retorna. \r\n// ➢  determinar_tipo: retorna el tipo del triángulo, los tipos pueden ser equilátero, \r\n// isósceles o escaleno. \r\n// ➢  calcular_area: calcular el área y la retorna. \r\n// ➢  calcular_perimetro: calcula el perímetro y lo retorna.\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nenum Tipo {\r\n  Equilatero,\r\n  Isosceles,\r\n  Escaleno,\r\n}\r\n\r\nstruct Triangulo{\r\n  lado1: f32,\r\n  lado2: f32,\r\n  lado3: f32,\r\n}\r\n\r\nimpl Triangulo {\r\n  fn new(lado1: f32, lado2: f32, lado3:f32)-\u003e Triangulo {\r\n    Triangulo { lado1, lado2, lado3 }\r\n  }\r\n\r\n  \r\n  fn determinar_tipo(\u0026self) -\u003e Tipo {\r\n    if self.lado1==self.lado2 \u0026\u0026 self.lado2==self.lado3{\r\n      Tipo::Equilatero\r\n    }\r\n    else if self.lado1 == self.lado2 || self.lado1==self.lado3 || self.lado2==self.lado3{\r\n      Tipo::Isosceles\r\n    }\r\n    else {\r\n      Tipo::Escaleno\r\n    }\r\n  }\r\n\r\n  fn calcular_area(\u0026self) -\u003e f32 {\r\n    let semi_perimetro = (self.lado1 + self.lado2 + self.lado3) / 2.0;\r\n\r\n    let area = (semi_perimetro * (semi_perimetro - self.lado1) * (semi_perimetro - self.lado2) * (semi_perimetro - self.lado3)).sqrt();\r\n\r\n    return area;\r\n  }\r\n\r\n  fn calcular_perimetro(\u0026self) -\u003e f32 {\r\n    return self.lado1 + self.lado2 + self.lado3;\r\n  }\r\n}\r\n\r\n\r\n\r\n#[cfg(test)]\r\nmod test_triangulo {\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let triangulo = Triangulo::new(3.0, 4.0, 5.0);\r\n    assert_eq!(triangulo.lado1, 3.0);\r\n    assert_eq!(triangulo.lado2, 4.0);\r\n    assert_eq!(triangulo.lado3, 5.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_determinar_tipo(){\r\n    let triangulo1 = Triangulo::new(5.0, 5.0, 5.0);\r\n     assert!(matches!(triangulo1.determinar_tipo(), Tipo::Equilatero));\r\n\r\n    let triangulo2 = Triangulo::new(5.0, 5.0, 8.0);\r\n    assert!(matches!(triangulo2.determinar_tipo(), Tipo::Isosceles));\r\n\r\n    let triangulo3 = Triangulo::new(5.0, 3.0, 8.0);\r\n    assert!(matches!(triangulo3.determinar_tipo(), Tipo::Escaleno));\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_area(){\r\n    let triangulo = Triangulo::new(3.0, 4.0, 5.0);\r\n    assert_eq!(triangulo.calcular_area(), 6.0)\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_perimetro(){\r\n    let triangulo = Triangulo::new(3.0, 4.0, 5.0);\r\n    assert_eq!(triangulo.calcular_perimetro(), 12.0);\r\n  }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej05.rs"],"content":"// 5- Escribir un programa que defina una estructura Producto que tenga campos para el \r\n// nombre, el precio bruto y un número identificatorio. Para dicha estructura implemente los \r\n// siguientes métodos: \r\n \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Producto y lo retorna. \r\n// ➢  calcular_impuestos(porcentaje_de_impuestos): retorna el valor de impuestos sobre \r\n// el precio bruto \r\n// ➢  aplicar_descuento(porcentaje_de_descuento): retorna el valor del porcentaje de \r\n// descuento sobre el precio bruto \r\n// ➢  calcular_precio_total(porcentaje_de_impuestos, porcentaje_descuento): retorna el \r\n// precio total a pagar aplicando impuesto y descuento. Tenga en cuenta que los \r\n// parámetros son opcionales.\r\n\r\nstruct Producto {\r\n  nombre: String,\r\n  precio: f32,\r\n  id: u32,\r\n}\r\n\r\nimpl Producto {\r\n  fn new(nombre: String, precio: f32, id: u32) -\u003e Producto {\r\n    Producto{\r\n      nombre,\r\n      precio,\r\n      id\r\n    }\r\n  }\r\n\r\n  fn calcular_impuestos(\u0026self, porcentaje_de_impuestos: f32) -\u003e f32 {\r\n    let valor_impuestos: f32 = (self.precio * porcentaje_de_impuestos)/100.0;\r\n    valor_impuestos\r\n  }\r\n\r\n  fn aplicar_descuento(\u0026self, porcentaje_de_descuento: f32) -\u003e f32 {\r\n    return (self.precio * porcentaje_de_descuento)/100.0;\r\n  }\r\n\r\n  fn calcular_precio_total(\r\n    \u0026self, \r\n    porcentaje_de_impuestos: Option\u003cf32\u003e, \r\n    porcentaje_de_descuento: Option\u003cf32\u003e\r\n  ) -\u003e f32 {\r\n    let mut precio_total: f32 = self.precio;\r\n    if let Some(porcentaje) = porcentaje_de_impuestos {\r\n      precio_total += self.calcular_impuestos(porcentaje);\r\n    } \r\n    if let Some(porcentaje) = porcentaje_de_descuento {\r\n      precio_total-= self.aplicar_descuento(porcentaje);\r\n    }\r\n\r\n    return precio_total;\r\n  }\r\n\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod producto_tests {\r\n  use super::*;\r\n  #[test]\r\n  fn test_new() {\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n    assert_eq!(producto.nombre, \"Laptop\");\r\n    assert_eq!(producto.precio, 1000.0);\r\n    assert_eq!(producto.id, 12345);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_impuestos(){\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n\r\n    let impuestos = producto.calcular_impuestos(21.0);\r\n    assert_eq!(impuestos, 210.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_aplicar_descuento(){\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n\r\n    let descuento = producto.aplicar_descuento(10.0);\r\n    assert_eq!(descuento, 100.0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_precio_total(){\r\n    let producto = Producto::new(String::from(\"Laptop\"), 1000.0, 12345);\r\n\r\n    let precio_total = producto.calcular_precio_total(Some(21.0), Some(10.0));\r\n    assert_eq!(precio_total, 1110.0);\r\n\r\n    let precio_solo_impuesto = producto.calcular_precio_total(Some(21.0), None);\r\n    assert_eq!(precio_solo_impuesto, 1210.0);\r\n  }\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej06 - copia.rs"],"content":"// Escribir un programa que defina una estructura Estudiante que tenga campos para el \r\n// nombre, el número de identificación y las calificaciones de exámenes. De cada Examen se \r\n// conoce el nombre de la materia y la nota. Para dichas estructuras implemente los siguientes \r\n// métodos: \r\n \r\n// ❖  Examen: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Examen y lo \r\n// retorna. \r\n// ❖  Estudiante: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Estudiante y lo \r\n// retorna. \r\n// ➢  obtener_promedio: retorna el promedio de las notas. \r\n// ➢  obtener_calificacion_mas_alta: retorna la nota más alta. \r\n// ➢  obtener_calificacion_mas_baja: retorna la nota más baja. \r\n \r\n// Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n\r\nstruct Examen {\r\n  nombre_de_materia: String,\r\n  nota: f32,\r\n}\r\n\r\nimpl Examen {\r\n  fn new (nombre_de_materia: String, nota: f32) -\u003e Examen{\r\n    Examen {\r\n      nombre_de_materia,\r\n      nota,\r\n    }\r\n  }\r\n} \r\nstruct Estudiante{\r\n  nombre_estudiante: String,\r\n  id: u32,\r\n  calificaciones: Vec\u003cExamen\u003e\r\n}\r\n\r\nstruct Informe {\r\n  nombre_estudiante: String,\r\n  examenes_rendidos: u32,\r\n  promedio_notas: f32,\r\n  nota_mas_alta: f32,\r\n  materia_mas_alta: String,\r\n  nota_mas_baja: f32,\r\n  materia_mas_baja: String,\r\n}\r\n\r\nimpl Informe {\r\n  fn new(nombre_estudiante: String, examenes_rendidos: u32, promedio_notas: f32, nota_mas_alta: f32, materia_mas_alta: String, nota_mas_baja: f32, materia_mas_baja: String) -\u003e Informe{\r\n    Informe {\r\n      nombre_estudiante,\r\n      examenes_rendidos,\r\n      promedio_notas,\r\n      nota_mas_alta,\r\n      materia_mas_alta,\r\n      nota_mas_baja,\r\n      materia_mas_baja\r\n    }\r\n\r\n  }\r\n}\r\n\r\nimpl Estudiante{\r\n  fn new(nombre_estudiante: String, id: u32, calificaciones: Vec\u003cExamen\u003e)-\u003e Estudiante {\r\n    Estudiante{\r\n      nombre_estudiante,\r\n      id,\r\n      calificaciones,\r\n    }\r\n  }\r\n\r\n  fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut suma: f32 = 0.0;\r\n    for examen in \u0026self.calificaciones{\r\n      suma+=examen.nota;\r\n    }\r\n    let dim_f = self.calificaciones.len();\r\n    Some(suma/dim_f as f32)\r\n  }\r\n\r\n  fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    \r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut max:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e max {\r\n        max = examen.nota;\r\n      }\r\n    }\r\n    return Some(max);\r\n  }\r\n\r\n  fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut min:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003c min {\r\n        min = examen.nota;\r\n      }\r\n    }\r\n    return Some(min);\r\n  }\r\n  \r\n  fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None\r\n    }\r\n    let mut nota_min: f32 = self.calificaciones[0].nota;\r\n    let mut nota_max: f32 = self.calificaciones[0].nota;\r\n    \r\n    let mut informe_est = Informe::new(\"\".to_string(), 0, 0.0, 0.0, \"\".to_string(), 0.0, \"\".to_string());\r\n    informe_est.nombre_estudiante = self.nombre_estudiante.clone();\r\n    informe_est.examenes_rendidos = self.calificaciones.len() as u32;\r\n    match {\r\n      self.obtener_promedio()\r\n    } {\r\n      Some(promedio) =\u003e informe_est.promedio_notas = promedio,\r\n      None =\u003e return None\r\n    }\r\n\r\n      for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e nota_max {\r\n        nota_max = examen.nota;\r\n        informe_est.nota_mas_alta = examen.nota;\r\n        informe_est.materia_mas_alta = examen.nombre_de_materia.clone()\r\n      }\r\n      if examen.nota \u003c nota_min {\r\n        nota_min = examen.nota;\r\n        informe_est.nota_mas_baja = examen.nota;\r\n        informe_est.materia_mas_baja = examen.nombre_de_materia.clone()\r\n      }\r\n    }\r\n\r\n    return Some(informe_est);\r\n\r\n    // In\r\n\r\n  }\r\n    \r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod estudiante_tests{\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones,\r\n    );\r\n\r\n    assert_eq!(estudiante.nombre_estudiante, \"Nicolas\");\r\n    assert_eq!(estudiante.id, 25458);\r\n    assert_eq!(estudiante.calificaciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_promedio(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_promedio(), Some(7.0));\r\n\r\n    //caso vector vacio\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_promedio(),None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_alta(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 8.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(8.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_alta(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_baja(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 5.0),\r\n      Examen::new(\"Programcion\".to_string(), 9.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(5.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_baja(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    let informe = estudiante.generar_informe();\r\n    \r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej06.rs"],"content":"// Escribir un programa que defina una estructura Estudiante que tenga campos para el \r\n// nombre, el número de identificación y las calificaciones de exámenes. De cada Examen se \r\n// conoce el nombre de la materia y la nota. Para dichas estructuras implemente los siguientes \r\n// métodos: \r\n \r\n// ❖  Examen: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Examen y lo \r\n// retorna. \r\n// ❖  Estudiante: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Estudiante y lo \r\n// retorna. \r\n// ➢  obtener_promedio: retorna el promedio de las notas. \r\n// ➢  obtener_calificacion_mas_alta: retorna la nota más alta. \r\n// ➢  obtener_calificacion_mas_baja: retorna la nota más baja. \r\n \r\n// Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n\r\nstruct Examen {\r\n  nombre_de_materia: String,\r\n  nota: f32,\r\n}\r\n\r\nimpl Examen {\r\n  fn new (nombre_de_materia: String, nota: f32) -\u003e Examen{\r\n    Examen {\r\n      nombre_de_materia,\r\n      nota,\r\n    }\r\n  }\r\n} \r\nstruct Estudiante{\r\n  nombre_estudiante: String,\r\n  id: u32,\r\n  calificaciones: Vec\u003cExamen\u003e\r\n}\r\n\r\nstruct Informe {\r\n  nombre_estudiante: String,\r\n  examenes_rendidos: u32,\r\n  promedio_notas: f32,\r\n  nota_mas_alta: f32,\r\n  materia_mas_alta: String,\r\n  nota_mas_baja: f32,\r\n  materia_mas_baja: String,\r\n}\r\n\r\nimpl Informe {\r\n  fn new(nombre_estudiante: String, examenes_rendidos: u32, promedio_notas: f32, nota_mas_alta: f32, materia_mas_alta: String, nota_mas_baja: f32, materia_mas_baja: String) -\u003e Informe{\r\n    Informe {\r\n      nombre_estudiante,\r\n      examenes_rendidos,\r\n      promedio_notas,\r\n      nota_mas_alta,\r\n      materia_mas_alta,\r\n      nota_mas_baja,\r\n      materia_mas_baja\r\n    }\r\n\r\n  }\r\n}\r\n\r\nimpl Estudiante{\r\n  fn new(nombre_estudiante: String, id: u32, calificaciones: Vec\u003cExamen\u003e)-\u003e Estudiante {\r\n    Estudiante{\r\n      nombre_estudiante,\r\n      id,\r\n      calificaciones,\r\n    }\r\n  }\r\n\r\n  fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut suma: f32 = 0.0;\r\n    for examen in \u0026self.calificaciones{\r\n      suma+=examen.nota;\r\n    }\r\n    let dim_f = self.calificaciones.len();\r\n    Some(suma/dim_f as f32)\r\n  }\r\n\r\n  fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    \r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut max:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e max {\r\n        max = examen.nota;\r\n      }\r\n    }\r\n    return Some(max);\r\n  }\r\n\r\n  fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut min:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003c min {\r\n        min = examen.nota;\r\n      }\r\n    }\r\n    return Some(min);\r\n  }\r\n  \r\n  fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None\r\n    }\r\n    let mut nota_min: f32 = self.calificaciones[0].nota;\r\n    let mut nota_max: f32 = self.calificaciones[0].nota;\r\n    \r\n    let mut informe_est = Informe::new(\"\".to_string(), 0, 0.0, 0.0, \"\".to_string(), 0.0, \"\".to_string());\r\n    informe_est.nombre_estudiante = self.nombre_estudiante.clone();\r\n    informe_est.examenes_rendidos = self.calificaciones.len() as u32;\r\n    match {\r\n      self.obtener_promedio()\r\n    } {\r\n      Some(promedio) =\u003e informe_est.promedio_notas = promedio,\r\n      None =\u003e return None\r\n    }\r\n\r\n      for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e nota_max {\r\n        nota_max = examen.nota;\r\n        informe_est.nota_mas_alta = examen.nota;\r\n        informe_est.materia_mas_alta = examen.nombre_de_materia.clone()\r\n      }\r\n      if examen.nota \u003c nota_min {\r\n        nota_min = examen.nota;\r\n        informe_est.nota_mas_baja = examen.nota;\r\n        informe_est.materia_mas_baja = examen.nombre_de_materia.clone()\r\n      }\r\n    }\r\n\r\n    return Some(informe_est);\r\n\r\n    // In\r\n\r\n  }\r\n    \r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod estudiante_tests{\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones,\r\n    );\r\n\r\n    assert_eq!(estudiante.nombre_estudiante, \"Nicolas\");\r\n    assert_eq!(estudiante.id, 25458);\r\n    assert_eq!(estudiante.calificaciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_promedio(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_promedio(), Some(7.0));\r\n\r\n    //caso vector vacio\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_promedio(),None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_alta(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 8.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(8.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_alta(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_baja(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 5.0),\r\n      Examen::new(\"Programcion\".to_string(), 9.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(5.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_baja(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    let informe = estudiante.generar_informe();\r\n\r\n    assert!(informe.is_some());\r\n    \r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej07.rs"],"content":"// 7- Defina una estructura llamada ConcesionarioAuto donde se conoce el nombre, la \r\n// dirección y tiene una capacidad máxima para albergar X cantidad de autos. De los autos se \r\n// conocen los campos de la marca, modelo, año, precio bruto y  color que pueden ser:rojo, \r\n// verde, azul, amarillo, blanco o negro. \r\n \r\n// Para dichas estructuras implemente los siguientes métodos: \r\n// ❖      ConcesionarioAuto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un \r\n// ConcesionarioAuto y lo retorna. \r\n// ➢  agregar_auto(auto): agrega un auto a la lista de autos que tiene sin superar \r\n// la máxima cantidad para albergarlos y retorna true, en caso de que lo supere \r\n// no lo agrega y retorna false. \r\n// ➢  eliminar_auto(auto): elimina un auto de la lista de autos. \r\n// ➢  buscar_auto(auto): busca un auto y si lo encuentra lo retorna. \r\n// ❖      Auto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Auto y lo \r\n// retorna. \r\n// ➢  calcular_precio: retorna el precio del auto aplicando los siguientes criterios: \r\n// ■  si es de color primario le aplica un recargo del 25%, sino le aplica un \r\n// descuento del 10%. \r\n// ■  si la marca es BMW le aplica un recargo del 15%- \r\n// ■  si el año es menor a 2000 le aplica un descuento del 5%.\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Auto{\r\n  marca: String,\r\n  modelo: String,\r\n  anio: u32,\r\n  precio: f32,\r\n  color: Color,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum Color {\r\n  Rojo,\r\n  Verde,\r\n  Azul,\r\n  Amarillo,\r\n  Blanco,\r\n  Negro,\r\n\r\n }\r\nstruct ConcesionarioAuto {\r\n  nombre: String,\r\n  direccion: String,\r\n  autos: Vec\u003cAuto\u003e,\r\n  capacidad_maxima: usize,\r\n}\r\n\r\nimpl Auto {\r\n  fn new(marca: String, modelo: String, anio: u32, precio: f32, color: Color) -\u003e Auto{\r\n    Auto {\r\n      marca,\r\n      modelo,\r\n      anio,\r\n      precio,\r\n      color\r\n    }\r\n  }\r\n\r\n  fn calcular_precio(\u0026self) -\u003e f32 {\r\n    let mut precio_adcional = match self.color {\r\n      Color::Rojo =\u003e self.precio *1.25,\r\n      Color::Amarillo =\u003e self.precio *1.25,\r\n      Color::Azul =\u003e self.precio *1.25,\r\n      _ =\u003e self.precio *0.9,\r\n        \r\n    };\r\n\r\n    if self.marca == \"BMW\".to_string() {\r\n      precio_adcional+=self.precio*0.15;\r\n    }\r\n\r\n    if self.anio \u003c 2000 {\r\n      precio_adcional-=self.precio*0.05;\r\n    }\r\n\r\n    return precio_adcional;\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl ConcesionarioAuto {\r\n  fn new(nombre: String, direccion: String, capacidad_maxima: usize) -\u003e ConcesionarioAuto{\r\n    ConcesionarioAuto { \r\n      nombre, \r\n      direccion, \r\n      capacidad_maxima,\r\n      //autos: Vec::new(),\r\n      autos:Vec::with_capacity(capacidad_maxima as usize),\r\n      \r\n    }\r\n  }\r\n\r\n  fn agregar_auto(\u0026mut self, auto: Auto) -\u003e bool {\r\n    if self.autos.len() \u003c self.capacidad_maxima {\r\n      self.autos.push(auto);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn eliminar_auto(\u0026mut self, auto: \u0026Auto) -\u003e bool {\r\n    // Usamos una referencia (\u0026Auto) en lugar del valor completo para no copiar todo el Auto\r\n    let posicion = self.autos.iter().position(|a| a.eq(auto)); // |a| a == auto: Es una closure \r\n\r\n    //position devuelve un option/ entonces debo verificar si hay un some \r\n    //si posicion contiene un valor (Some), extrae ese valor y llámalo indice\r\n    if let Some(indice) = posicion {\r\n      self.autos.remove(indice);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\r\n    self.autos.iter().find(|\u0026a| a.eq(auto))\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new_auto(){\r\n    let auto = Auto::new(\r\n      \"Toyota\".to_string(), \r\n      \"Corolla\".to_string(), \r\n      2023, \r\n      10000.0,\r\n      Color::Rojo,\r\n    );\r\n    assert_eq!(auto.marca, \"Toyota\");\r\n    assert_eq!(auto.modelo, \"Corolla\");\r\n    assert_eq!(auto.anio, 2023);\r\n    assert_eq!(auto.precio, 10000.0);\r\n    assert!(matches!(\u0026auto.color, Color::Rojo));\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_precio(){\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n    // Precio inicial: 10000.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final esperado: 12500.0\r\n    assert_eq!(auto1.calcular_precio(),12500.0);\r\n\r\n    // Auto BMW, color no primario (Blanco), año antiguo\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n  \r\n    // Precio inicial: 20000.0\r\n    // Recargo por BMW: 20000.0 * 0.15 = 3000.0\r\n    // Descuento por año \u003c 2000: 20000.0 * 0.05 = 1000.0\r\n    // Descuento por color no primario: 20000.0 * 0.10 = 2000.0\r\n    // Precio final esperado: 20000.0 + 3000.0 - 1000.0 - 2000.0 = 20000.0\r\n    assert_eq!(auto2.calcular_precio(), 20000.0);\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_calculo_precio_incorrecto() {\r\n    // Auto BMW de color primario (Azul) y año 1990\r\n    let auto = Auto::new(\r\n      String::from(\"BMW\"),\r\n      String::from(\"Serie 3\"),\r\n      1990,\r\n      10000.0,\r\n      Color::Azul\r\n    );\r\n  \r\n    // Precio base: 10000.0\r\n    // Recargo por BMW: 10000.0 * 0.15 = 1500.0\r\n    // Descuento por año \u003c 2000: 10000.0 * 0.05 = 500.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final correcto: 10000.0 + 1500.0 - 500.0 + 2500.0 = 13500.0\r\n  \r\n    // Este test fallará porque el valor esperado es incorrecto\r\n    assert_eq!(auto.calcular_precio(), 12000.0); // Valor incorrecto\r\n  }\r\n\r\n  #[test]\r\n  fn test_new_concesionario(){\r\n    let concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    assert_eq!(concesionario.nombre, \"Mi Concesionario\");\r\n    assert_eq!(concesionario.direccion, \"Calle Falsa 123\");\r\n    assert_eq!(concesionario.capacidad_maxima, 10);\r\n    assert_eq!(concesionario.autos.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_consecionario(){\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n    assert_eq!(concesionario.agregar_auto(auto1.clone()), true); // para evitar el owner ship\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert_eq!(concesionario.agregar_auto(auto2.clone()), true);\r\n    assert_eq!(concesionario.autos.len(), 2);\r\n\r\n    assert_eq!(concesionario.eliminar_auto(\u0026auto1), true);\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert!(concesionario.buscar_auto(\u0026auto1).is_none()); // devuelve un option la funcion, entonces usamos is_none()\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_acceso_fuera_de_indice() {\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"AutoMundo\"),\r\n      String::from(\"Av. Principal 123\"),\r\n      2\r\n    );\r\n        \r\n    let auto = Auto::new(\r\n      String::from(\"Ford\"),\r\n      String::from(\"Focus\"),\r\n      2020,\r\n      15000.0,\r\n      Color::Azul\r\n    );\r\n        \r\n    concesionario.agregar_auto(auto);\r\n    let _auto_inexistente = \u0026concesionario.autos[5]; // Índice fuera de rango\r\n    }\r\n\r\n    \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej07v2.rs"],"content":"// 7- Defina una estructura llamada ConcesionarioAuto donde se conoce el nombre, la \r\n// dirección y tiene una capacidad máxima para albergar X cantidad de autos. De los autos se \r\n// conocen los campos de la marca, modelo, año, precio bruto y  color que pueden ser:rojo, \r\n// verde, azul, amarillo, blanco o negro. \r\n \r\n// Para dichas estructuras implemente los siguientes métodos: \r\n// ❖      ConcesionarioAuto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un \r\n// ConcesionarioAuto y lo retorna. \r\n// ➢  agregar_auto(auto): agrega un auto a la lista de autos que tiene sin superar \r\n// la máxima cantidad para albergarlos y retorna true, en caso de que lo supere \r\n// no lo agrega y retorna false. \r\n// ➢  eliminar_auto(auto): elimina un auto de la lista de autos. \r\n// ➢  buscar_auto(auto): busca un auto y si lo encuentra lo retorna. \r\n// ❖      Auto: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Auto y lo \r\n// retorna. \r\n// ➢  calcular_precio: retorna el precio del auto aplicando los siguientes criterios: \r\n// ■  si es de color primario le aplica un recargo del 25%, sino le aplica un \r\n// descuento del 10%. \r\n// ■  si la marca es BMW le aplica un recargo del 15%- \r\n// ■  si el año es menor a 2000 le aplica un descuento del 5%.\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Auto{\r\n  marca: String,\r\n  modelo: String,\r\n  anio: u32,\r\n  precio: f32,\r\n  color: Color,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum Color {\r\n  Rojo,\r\n  Verde,\r\n  Azul,\r\n  Amarillo,\r\n  Blanco,\r\n  Negro,\r\n\r\n }\r\nstruct ConcesionarioAuto {\r\n  nombre: String,\r\n  direccion: String,\r\n  autos: Vec\u003cAuto\u003e,\r\n  capacidad_maxima: usize,\r\n}\r\n\r\nimpl Auto {\r\n  fn new(marca: String, modelo: String, anio: u32, precio: f32, color: Color) -\u003e Auto{\r\n    Auto {\r\n      marca,\r\n      modelo,\r\n      anio,\r\n      precio,\r\n      color\r\n    }\r\n  }\r\n\r\n\r\n  fn calcular_precio(\u0026self) -\u003e f32 {\r\n    let mut precio_adcional = match self.color {\r\n      Color::Rojo =\u003e self.precio *1.25,\r\n      Color::Amarillo =\u003e self.precio *1.25,\r\n      Color::Azul =\u003e self.precio *1.25,\r\n      _ =\u003e self.precio *0.9,\r\n        \r\n    };\r\n\r\n    if self.marca == \"BMW\".to_string() {\r\n      precio_adcional+=self.precio*0.15;\r\n    }\r\n\r\n    if self.anio \u003c 2000 {\r\n      precio_adcional-=self.precio*0.05;\r\n    }\r\n\r\n    return precio_adcional;\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl ConcesionarioAuto {\r\n  fn new(nombre: String, direccion: String, capacidad_maxima: usize) -\u003e ConcesionarioAuto{\r\n    ConcesionarioAuto { \r\n      nombre, \r\n      direccion, \r\n      autos: Vec::new(),\r\n      capacidad_maxima,\r\n    }\r\n  }\r\n\r\n  fn agregar_auto(\u0026mut self, auto: Auto) -\u003e bool {\r\n    if self.autos.len() \u003c self.capacidad_maxima {\r\n      self.autos.push(auto);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn eliminar_auto(\u0026mut self, auto: \u0026Auto) -\u003e bool {\r\n    // Usamos una referencia (\u0026Auto) en lugar del valor completo para no copiar todo el Auto\r\n    let mut posicion = 0;\r\n    for i in 0..self.autos.len() {\r\n      if self.autos[i].eq(auto) {\r\n        posicion = i;\r\n        break;\r\n      }\r\n    }\r\n    if posicion \u003c self.autos.len() {\r\n      self.autos.remove(posicion);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\r\n    //self.autos.iter().find(|\u0026a| a== auto)\r\n    for i in 0..self.autos.len() {\r\n      if self.autos[i].eq(auto) {\r\n        return Some(\u0026self.autos[i]);\r\n      }\r\n    }\r\n    None\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test{\r\n  use super::*;\r\n\r\n  #[test]\r\n  fn test_new_auto(){\r\n    let auto = Auto::new(\r\n      \"Toyota\".to_string(), \r\n      \"Corolla\".to_string(), \r\n      2023, \r\n      10000.0,\r\n      Color::Rojo,\r\n    );\r\n    assert_eq!(auto.marca, \"Toyota\");\r\n    assert_eq!(auto.modelo, \"Corolla\");\r\n    assert_eq!(auto.anio, 2023);\r\n    assert_eq!(auto.precio, 10000.0);\r\n    assert!(matches!(\u0026auto.color, Color::Rojo));\r\n  }\r\n\r\n  #[test]\r\n  fn test_calcular_precio(){\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n    // Precio inicial: 10000.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final esperado: 12500.0\r\n    assert_eq!(auto1.calcular_precio(),12500.0);\r\n\r\n    // Auto BMW, color no primario (Blanco), año antiguo\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n  \r\n    // Precio inicial: 20000.0\r\n    // Recargo por BMW: 20000.0 * 0.15 = 3000.0\r\n    // Descuento por año \u003c 2000: 20000.0 * 0.05 = 1000.0\r\n    // Descuento por color no primario: 20000.0 * 0.10 = 2000.0\r\n    // Precio final esperado: 20000.0 + 3000.0 - 1000.0 - 2000.0 = 20000.0\r\n    assert_eq!(auto2.calcular_precio(), 20000.0);\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_calculo_precio_incorrecto() {\r\n    // Auto BMW de color primario (Azul) y año 1990\r\n    let auto = Auto::new(\r\n      String::from(\"BMW\"),\r\n      String::from(\"Serie 3\"),\r\n      1990,\r\n      10000.0,\r\n      Color::Azul\r\n    );\r\n  \r\n    // Precio base: 10000.0\r\n    // Recargo por BMW: 10000.0 * 0.15 = 1500.0\r\n    // Descuento por año \u003c 2000: 10000.0 * 0.05 = 500.0\r\n    // Recargo por color primario: 10000.0 * 0.25 = 2500.0\r\n    // Precio final correcto: 10000.0 + 1500.0 - 500.0 + 2500.0 = 13500.0\r\n  \r\n    // Este test fallará porque el valor esperado es incorrecto\r\n    assert_eq!(auto.calcular_precio(), 12000.0); // Valor incorrecto\r\n  }\r\n\r\n  #[test]\r\n  fn test_new_concesionario(){\r\n    let concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    assert_eq!(concesionario.nombre, \"Mi Concesionario\");\r\n    assert_eq!(concesionario.direccion, \"Calle Falsa 123\");\r\n    assert_eq!(concesionario.capacidad_maxima, 10);\r\n    assert_eq!(concesionario.autos.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_consecionario(){\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"Mi Concesionario\"), \r\n      String::from(\"Calle Falsa 123\"), \r\n      10\r\n    );\r\n    let auto1 = Auto::new(\r\n      String::from(\"Toyota\"), \r\n      String::from(\"Corolla\"), \r\n      2023, \r\n      10000.0, \r\n      Color::Rojo\r\n    );\r\n\r\n    let auto2 = Auto::new(\r\n      String::from(\"BMW\"), \r\n      String::from(\"X5\"), \r\n      1999, \r\n      20000.0, \r\n      Color::Blanco\r\n    );\r\n    assert_eq!(concesionario.agregar_auto(auto1.clone()), true); // para evitar el owner ship\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert_eq!(concesionario.agregar_auto(auto2.clone()), true);\r\n    assert_eq!(concesionario.autos.len(), 2);\r\n\r\n    assert_eq!(concesionario.eliminar_auto(\u0026auto1), true);\r\n    assert_eq!(concesionario.autos.len(), 1);\r\n\r\n    assert!(concesionario.buscar_auto(\u0026auto1).is_none()); // devuelve un option la funcion, entonces usamos is_none()\r\n  }\r\n\r\n  #[test]\r\n  #[should_panic]\r\n  fn test_acceso_fuera_de_indice() {\r\n    let mut concesionario = ConcesionarioAuto::new(\r\n      String::from(\"AutoMundo\"),\r\n      String::from(\"Av. Principal 123\"),\r\n      2\r\n    );\r\n        \r\n    let auto = Auto::new(\r\n      String::from(\"Ford\"),\r\n      String::from(\"Focus\"),\r\n      2020,\r\n      15000.0,\r\n      Color::Azul\r\n    );\r\n        \r\n    concesionario.agregar_auto(auto);\r\n    let _auto_inexistente = \u0026concesionario.autos[5]; // Índice fuera de rango\r\n    }\r\n\r\n    \r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej08.rs"],"content":"// 8- Defina la estructura Cancion con campos para el título, el artista y el género. El género \r\n// puede ser rock, pop, rap,  jazz, otros. Luego modele una playlist. La playlist está compuesta \r\n// por una lista de canciones y un nombre, y se permiten hacer las siguientes acciones sobre \r\n// ella: \r\n// ➔  agregar canción. \r\n// ➔  eliminar canción. \r\n// ➔  mover canción // mueve la canción a una determinada posición de la playlist. \r\n// ➔  buscar canción por nombre. \r\n// ➔  obtener las canciones de un determinado género. \r\n// ➔  obtener las canciones de un determinado artista. \r\n// ➔  modificar título de la playlist. \r\n// ➔  eliminar todas las canciones\r\n\r\n#[derive(Debug, Clone)]\r\nenum Genero {\r\n  Rock,\r\n  Pop,\r\n  Rap,\r\n  Jazz,\r\n  Otros,\r\n}\r\n\r\n// impl Genero {\r\n//   fn to_string(\u0026self) -\u003e String {\r\n//     match self {\r\n//       Genero::Rock =\u003e \"Rock\".to_string(),\r\n//       Genero::Pop =\u003e \"Pop\".to_string(),\r\n//       Genero::Rap =\u003e \"Rap\".to_string(),\r\n//       Genero::Jazz =\u003e \"Jazz\".to_string(),\r\n//       Genero::Otros =\u003e \"Otros\".to_string(),\r\n//     }\r\n//   }\r\n// }\r\nimpl Genero {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Cancion {\r\n  titulo: String,\r\n  artista: String,\r\n  genero: Genero,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct Playlist {\r\n  canciones: Vec\u003cCancion\u003e,\r\n  nombre: String,\r\n}\r\n\r\n\r\n\r\nimpl Cancion {\r\n  fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\r\n    Cancion {\r\n      titulo,\r\n      artista,\r\n      genero,\r\n    }\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl Playlist {\r\n  fn new(nombre: String) -\u003e Playlist {\r\n    Playlist {\r\n      canciones: Vec::new(),\r\n      nombre,\r\n    }\r\n  }\r\n\r\n  fn agregar_cancion(\u0026mut self, cancion: Cancion) {\r\n    self.canciones.push(cancion);\r\n  }\r\n\r\n  fn eliminar_cancion(\u0026mut self, titulo: \u0026str) -\u003e bool {\r\n    let posicion = self.encontrar_pos_cancion(titulo);\r\n    if let Some(pos) = posicion {\r\n      self.canciones.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_pos_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003cusize\u003e {\r\n    self.canciones.iter().position(|c| c.titulo.to_lowercase() == titulo.to_lowercase())\r\n  }\r\n\r\n  fn mover_cancion(\u0026mut self, titulo: \u0026str, nueva_posicion: usize) -\u003e bool {\r\n    if nueva_posicion \u003e= self.canciones.len() {\r\n      return false;\r\n    }\r\n\r\n    let posicion_actual = self.encontrar_pos_cancion(titulo);\r\n    if let Some (pos) = posicion_actual {\r\n      if pos == nueva_posicion {\r\n        return true; // no hacer nada\r\n      }\r\n\r\n      let cancion = self.canciones.remove(pos);\r\n      self.canciones.insert(nueva_posicion, cancion);\r\n      return true;\r\n    } else {\r\n      return false\r\n    }  \r\n  }\r\n\r\n  fn buscar_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003c\u0026Cancion\u003e {\r\n    self.canciones.iter().find(|\u0026c| c.titulo.to_lowercase() == titulo.to_lowercase())\r\n  }\r\n\r\n  fn obtener_canciones_por_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e { //\u0026Cancion para no tomar la propiedad\r\n    self.canciones.iter()\r\n    .filter(|c| c.genero.eq(genero)) // filter coleccion las canciones\r\n    .collect()// collect convierte el iterator en un vector\r\n  }\r\n\r\n  fn obtener_canciones_por_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n    self.canciones.iter()\r\n    .filter(|c| c.artista.to_lowercase() == artista.to_lowercase())\r\n    .collect()\r\n  }\r\n\r\n  fn modificar_titulo(\u0026mut self, nuevo_titulo: \u0026str) {\r\n    self.nombre = nuevo_titulo.to_string();\r\n  }\r\n\r\n  fn eliminar_todas_las_canciones(\u0026mut self) {\r\n    self.canciones.clear();\r\n  }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n\r\nuse super::*;\r\n\r\n  fn crear_playlist_test() -\u003e Playlist {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Champangne Supernova\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Blank Space\".to_string(),\r\n      \"Taylor Swift\".to_string(),\r\n      Genero::Pop\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Stand by me\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_crear_playlist() {\r\n    let playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    assert_eq!(playlist.nombre, \"Mi Playlist\");\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_agregar_cancion() {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    let cancion = Cancion::new(\r\n      \"Live forever\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    );\r\n\r\n    playlist.agregar_cancion(cancion.clone());\r\n    assert_eq!(playlist.canciones.len(), 1);\r\n    assert!(playlist.canciones[0].eq(\u0026cancion));\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_existente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Blank Space\");\r\n    assert_eq!(resultado, true);\r\n    assert_eq!(playlist.canciones.len(), 2);\r\n    assert!(playlist.buscar_cancion(\"Blank Space\").is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Cancion Inexistente\");\r\n    assert_eq!(resultado, false);\r\n    assert_eq!(playlist.canciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_caso_normal() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n    // Mover \"Stand by me\" (índice 2) a la posición 0\r\n    let result = playlist.mover_cancion(\"Stand by me\", 0);\r\n        \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Stand by me\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_misma_posicion() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Mover \"Blank Space\" (índice 1) a la posición 1 (no debería cambiar)\r\n    let result = playlist.mover_cancion(\"Blank Space\", 1);\r\n    \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Stand by me\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_posicion_invalida() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Intentar mover a una posición fuera de rango\r\n    let result = playlist.mover_cancion(\"Blank Space\", 10);\r\n    \r\n    assert!(!result);\r\n    // Verificar que el orden no cambió\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    let result = playlist.mover_cancion(\"Canción Inexistente\", 0);\r\n    \r\n    assert!(!result);\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_existente_case_insensitive() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    // Buscar con diferente capitalización\r\n    let cancion = playlist.buscar_cancion(\"blank Space\");\r\n      \r\n    assert!(cancion.is_some());\r\n    assert_eq!(cancion.unwrap().titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_inexistente() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    let cancion = playlist.buscar_cancion(\"Canción Inexistente\");\r\n      \r\n    assert!(cancion.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_genero() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n     // Agregamos otra canción de rock\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"We Will Rock You\".to_string(),\r\n      \"Queen\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n        \r\n    let canciones_rock = playlist.obtener_canciones_por_genero(\u0026Genero::Rock);\r\n        \r\n    assert_eq!(canciones_rock.len(), 3);\r\n    assert_eq!(canciones_rock[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_rock[1].titulo, \"Stand by me\");\r\n    assert_eq!(canciones_rock[2].titulo, \"We Will Rock You\");\r\n        \r\n    // Género sin canciones\r\n    let canciones_jazz = playlist.obtener_canciones_por_genero(\u0026Genero::Jazz);\r\n    assert_eq!(canciones_jazz.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_artista() {\r\n    let playlist = crear_playlist_test();\r\n        \r\n    let canciones_oasis = playlist.obtener_canciones_por_artista(\"Oasis\");\r\n        \r\n    assert_eq!(canciones_oasis.len(), 2);\r\n    assert_eq!(canciones_oasis[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_oasis[1].titulo, \"Stand by me\");\r\n\r\n    // Artista sin Canciones\r\n    let canciones_lipa = playlist.obtener_canciones_por_artista(\"Dua Lipa\");\r\n    assert_eq!(canciones_lipa.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_titulo() {\r\n    let mut playlist = crear_playlist_test();\r\n    playlist.modificar_titulo(\"Mi Playlist Modificada\");\r\n    assert_eq!(playlist.nombre, \"Mi Playlist Modificada\");\r\n  }\r\n\r\n  // Tests para playlist vacía\r\n  #[test]\r\n  fn test_operaciones_en_playlist_vacia() {\r\n    let mut playlist = Playlist::new(\"Playlist Vacía\".to_string());\r\n      \r\n    // Intentar eliminar de una playlist vacía\r\n    let result = playlist.eliminar_cancion(\"Cualquier Canción\");\r\n    assert!(!result);\r\n      \r\n      // Intentar mover en una playlist vacía\r\n    let result = playlist.mover_cancion(\"Cualquier Canción\", 0);\r\n    assert!(!result);\r\n      \r\n    // Buscar en una playlist vacía\r\n    assert!(playlist.buscar_cancion(\"Cualquier Canción\").is_none());\r\n      \r\n    // Filtrar por género en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_genero(\u0026Genero::Rock).len(), 0);\r\n      \r\n    // Filtrar por artista en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_artista(\"Cualquier Artista\").len(), 0);\r\n      \r\n    // Eliminar todas las canciones de una playlist vacía\r\n    playlist.eliminar_todas_las_canciones();\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej08v2.rs"],"content":"// 8- Defina la estructura Cancion con campos para el título, el artista y el género. El género \r\n// puede ser rock, pop, rap,  jazz, otros. Luego modele una playlist. La playlist está compuesta \r\n// por una lista de canciones y un nombre, y se permiten hacer las siguientes acciones sobre \r\n// ella: \r\n// ➔  agregar canción. \r\n// ➔  eliminar canción. \r\n// ➔  mover canción // mueve la canción a una determinada posición de la playlist. \r\n// ➔  buscar canción por nombre. \r\n// ➔  obtener las canciones de un determinado género. \r\n// ➔  obtener las canciones de un determinado artista. \r\n// ➔  modificar título de la playlist. \r\n// ➔  eliminar todas las canciones\r\n\r\n#[derive(Debug, Clone)]\r\nenum Genero {\r\n  Rock,\r\n  Pop,\r\n  Rap,\r\n  Jazz,\r\n  Otros,\r\n}\r\n\r\nimpl Genero {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Cancion {\r\n  titulo: String,\r\n  artista: String,\r\n  genero: Genero,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct Playlist {\r\n  canciones: Vec\u003cCancion\u003e,\r\n  nombre: String,\r\n}\r\n\r\nimpl Cancion {\r\n  fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\r\n    Cancion {\r\n      titulo,\r\n      artista,\r\n      genero,\r\n    }\r\n  }\r\n\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\nimpl Playlist {\r\n  fn new(nombre: String) -\u003e Playlist {\r\n    Playlist {\r\n      canciones: Vec::new(),\r\n      nombre,\r\n    }\r\n  }\r\n\r\n  fn agregar_cancion(\u0026mut self, cancion: Cancion) {\r\n    self.canciones.push(cancion);\r\n  }\r\n\r\n  fn eliminar_cancion(\u0026mut self, titulo: \u0026str) -\u003e bool {\r\n    let posicion = self.encontrar_pos_cancion(titulo);\r\n    if let Some(pos) = posicion {\r\n      self.canciones.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_pos_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003cusize\u003e {\r\n    for i in 0..self.canciones.len() {\r\n      if self.canciones[i].titulo.to_lowercase() == titulo.to_lowercase() {\r\n        return Some(i);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn mover_cancion(\u0026mut self, titulo: \u0026str, nueva_posicion: usize) -\u003e bool {\r\n    if nueva_posicion \u003e= self.canciones.len() {\r\n      return false;\r\n    }\r\n\r\n    let posicion_actual = self.encontrar_pos_cancion(titulo);\r\n    if let Some (pos) = posicion_actual {\r\n      if pos == nueva_posicion {\r\n        return true; // no hacer nada\r\n      }\r\n\r\n      let cancion = self.canciones.remove(pos);\r\n      self.canciones.insert(nueva_posicion, cancion);\r\n      return true;\r\n    } else {\r\n      return false\r\n    }  \r\n  }\r\n\r\n  fn buscar_cancion(\u0026self, titulo: \u0026str) -\u003e Option\u003c\u0026Cancion\u003e {\r\n    for i in 0..self.canciones.len() {\r\n      if self.canciones[i].titulo.to_lowercase() == titulo.to_lowercase() {\r\n        return Some(\u0026self.canciones[i]);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn obtener_canciones_por_genero(\u0026self, genero: \u0026Genero) -\u003e Vec\u003c\u0026Cancion\u003e { //\u0026Cancion para no tomar la propiedad\r\n    let mut canciones_filtradas = Vec::new();\r\n    \r\n    for cancion in \u0026self.canciones {\r\n      if cancion.genero.eq(genero) {\r\n        canciones_filtradas.push(cancion);\r\n      }\r\n    }\r\n    \r\n    canciones_filtradas\r\n  }\r\n\r\n  fn obtener_canciones_por_artista(\u0026self, artista: \u0026str) -\u003e Vec\u003c\u0026Cancion\u003e {\r\n    let mut canciones_filtradas = Vec::new();\r\n    \r\n    for cancion in \u0026self.canciones {\r\n      if cancion.artista.to_lowercase() == artista.to_lowercase() {\r\n        canciones_filtradas.push(cancion);\r\n      }\r\n    }\r\n    \r\n    canciones_filtradas\r\n  }\r\n\r\n  fn modificar_titulo(\u0026mut self, nuevo_titulo: \u0026str) {\r\n    self.nombre = nuevo_titulo.to_string();\r\n  }\r\n\r\n  fn eliminar_todas_las_canciones(\u0026mut self) {\r\n    self.canciones.clear();\r\n  }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\nuse super::*;\r\n\r\n  fn crear_playlist_test() -\u003e Playlist {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Champangne Supernova\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Blank Space\".to_string(),\r\n      \"Taylor Swift\".to_string(),\r\n      Genero::Pop\r\n    ));\r\n\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"Stand by me\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n\r\n    playlist\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_crear_playlist() {\r\n    let playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    assert_eq!(playlist.nombre, \"Mi Playlist\");\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_agregar_cancion() {\r\n    let mut playlist = Playlist::new(\"Mi Playlist\".to_string());\r\n    let cancion = Cancion::new(\r\n      \"Live forever\".to_string(),\r\n      \"Oasis\".to_string(),\r\n      Genero::Rock\r\n    );\r\n\r\n    playlist.agregar_cancion(cancion.clone());\r\n    assert_eq!(playlist.canciones.len(), 1);\r\n    assert!(playlist.canciones[0].eq(\u0026cancion));\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_existente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Blank Space\");\r\n    assert_eq!(resultado, true);\r\n    assert_eq!(playlist.canciones.len(), 2);\r\n    assert!(playlist.buscar_cancion(\"Blank Space\").is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn eliminar_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    let resultado = playlist.eliminar_cancion(\"Cancion Inexistente\");\r\n    assert_eq!(resultado, false);\r\n    assert_eq!(playlist.canciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_caso_normal() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n    // Mover \"Stand by me\" (índice 2) a la posición 0\r\n    let result = playlist.mover_cancion(\"Stand by me\", 0);\r\n        \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Stand by me\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_misma_posicion() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Mover \"Blank Space\" (índice 1) a la posición 1 (no debería cambiar)\r\n    let result = playlist.mover_cancion(\"Blank Space\", 1);\r\n    \r\n    assert!(result);\r\n    assert_eq!(playlist.canciones[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n    assert_eq!(playlist.canciones[2].titulo, \"Stand by me\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_posicion_invalida() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    // Intentar mover a una posición fuera de rango\r\n    let result = playlist.mover_cancion(\"Blank Space\", 10);\r\n    \r\n    assert!(!result);\r\n    // Verificar que el orden no cambió\r\n    assert_eq!(playlist.canciones[1].titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_mover_cancion_inexistente() {\r\n    let mut playlist = crear_playlist_test();\r\n    \r\n    let result = playlist.mover_cancion(\"Canción Inexistente\", 0);\r\n    \r\n    assert!(!result);\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_existente_case_insensitive() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    // Buscar con diferente capitalización\r\n    let cancion = playlist.buscar_cancion(\"blank Space\");\r\n      \r\n    assert!(cancion.is_some());\r\n    assert_eq!(cancion.unwrap().titulo, \"Blank Space\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_cancion_inexistente() {\r\n    let playlist = crear_playlist_test();\r\n      \r\n    let cancion = playlist.buscar_cancion(\"Canción Inexistente\");\r\n      \r\n    assert!(cancion.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_genero() {\r\n    let mut playlist = crear_playlist_test();\r\n        \r\n     // Agregamos otra canción de rock\r\n    playlist.agregar_cancion(Cancion::new(\r\n      \"We Will Rock You\".to_string(),\r\n      \"Queen\".to_string(),\r\n      Genero::Rock\r\n    ));\r\n        \r\n    let canciones_rock = playlist.obtener_canciones_por_genero(\u0026Genero::Rock);\r\n        \r\n    assert_eq!(canciones_rock.len(), 3);\r\n    assert_eq!(canciones_rock[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_rock[1].titulo, \"Stand by me\");\r\n    assert_eq!(canciones_rock[2].titulo, \"We Will Rock You\");\r\n        \r\n    // Género sin canciones\r\n    let canciones_jazz = playlist.obtener_canciones_por_genero(\u0026Genero::Jazz);\r\n    assert_eq!(canciones_jazz.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_canciones_por_artista() {\r\n    let playlist = crear_playlist_test();\r\n        \r\n    let canciones_oasis = playlist.obtener_canciones_por_artista(\"Oasis\");\r\n        \r\n    assert_eq!(canciones_oasis.len(), 2);\r\n    assert_eq!(canciones_oasis[0].titulo, \"Champangne Supernova\");\r\n    assert_eq!(canciones_oasis[1].titulo, \"Stand by me\");\r\n\r\n    // Artista sin Canciones\r\n    let canciones_lipa = playlist.obtener_canciones_por_artista(\"Dua Lipa\");\r\n    assert_eq!(canciones_lipa.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_titulo() {\r\n    let mut playlist = crear_playlist_test();\r\n    playlist.modificar_titulo(\"Mi Playlist Modificada\");\r\n    assert_eq!(playlist.nombre, \"Mi Playlist Modificada\");\r\n  }\r\n\r\n  // Tests para playlist vacía\r\n  #[test]\r\n  fn test_operaciones_en_playlist_vacia() {\r\n    let mut playlist = Playlist::new(\"Playlist Vacía\".to_string());\r\n      \r\n    // Intentar eliminar de una playlist vacía\r\n    let result = playlist.eliminar_cancion(\"Cualquier Canción\");\r\n    assert!(!result);\r\n      \r\n      // Intentar mover en una playlist vacía\r\n    let result = playlist.mover_cancion(\"Cualquier Canción\", 0);\r\n    assert!(!result);\r\n      \r\n    // Buscar en una playlist vacía\r\n    assert!(playlist.buscar_cancion(\"Cualquier Canción\").is_none());\r\n      \r\n    // Filtrar por género en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_genero(\u0026Genero::Rock).len(), 0);\r\n      \r\n    // Filtrar por artista en una playlist vacía\r\n    assert_eq!(playlist.obtener_canciones_por_artista(\"Cualquier Artista\").len(), 0);\r\n      \r\n    // Eliminar todas las canciones de una playlist vacía\r\n    playlist.eliminar_todas_las_canciones();\r\n    assert_eq!(playlist.canciones.len(), 0);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej09.rs"],"content":"use std::collections::VecDeque;\r\n\r\n// 9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de \r\n// pacientes para cada veterinaria, de la veterinaria se conoce el nombre, la dirección y un id. \r\n// Para la atención de mascotas se requiere administrar una cola de atención. De la mascota \r\n// se conoce el nombre, la edad, el tipo de animal(perro, gato, caballo, otros) y su dueño. Del \r\n// dueño se conoce el nombre, la dirección y un teléfono de contacto. Luego de la atención se \r\n// desea tener un registro de las atenciones realizadas guardando los datos de la mascota, el \r\n// diagnóstico final, tratamiento y fecha de la próxima visita si es que se requiere. \r\n// Dado todo lo mencionado anteriormente implemente los métodos para realizar las \r\n// siguientes acciones: \r\n// ➔  crear una veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención de la veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención pero que sea la siguiente \r\n// en atender porque tiene la máxima prioridad. \r\n// ➔  atender la próxima mascota de la cola. \r\n// ➔  eliminar una mascota específica de la cola de atención dado que se retira. \r\n// ➔  registrar una atención. \r\n// ➔  buscar una atención dado el nombre de la mascota, el nombre del dueño y el \r\n// teléfono. \r\n// ➔  modificar el diagnóstico de una determinada atención. \r\n// ➔  modificar la fecha de la próxima visita de una determinada atención. \r\n// ➔  eliminar una determinada atención. \r\n \r\n// Nota: para la fecha utilice lo implementado en el punto 3\r\nuse crate::tp03::ej03::Fecha;\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nenum TipoAnimal {\r\n  Perro,\r\n  Gato,\r\n  Caballo,\r\n  Otros(String),\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Duenio {\r\n  nombre: String,\r\n  direccion: String,\r\n  telefono: u32,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Mascota {\r\n  nombre: String,\r\n  edad: u32,\r\n  tipo: TipoAnimal,\r\n  duenio: Duenio,\r\n}\r\n\r\nimpl Mascota {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Atencion {\r\n  mascota: Mascota,\r\n  diagnostico: String,\r\n  tratamiento: String,\r\n  proxima_visita:Option\u003cFecha\u003e,\r\n}\r\nstruct Veterinaria {\r\n  nombre_vet: String,\r\n  direccion: String,\r\n  id: u32,\r\n  cola: VecDeque\u003cMascota\u003e,\r\n  atenciones : Vec\u003cAtencion\u003e\r\n}\r\n\r\nimpl Veterinaria {\r\n  fn new(nombre_vet: String, direccion: String, id: u32)-\u003e Self{\r\n    Veterinaria {\r\n      nombre_vet,\r\n      direccion,\r\n      id,\r\n      cola: VecDeque::new(),\r\n      atenciones: Vec::new()\r\n    }\r\n  }\r\n\r\n  fn agregar_mascota(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_back(mascota);\r\n  }\r\n\r\n  fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_front(mascota);\r\n  }\r\n\r\n  fn atender_proxima_mascota(\u0026mut self)-\u003e Option\u003cMascota\u003e{\r\n    self.cola.pop_front()\r\n  }\r\n\r\n  fn eliminar_mascota(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e bool{\r\n\r\n    let posicion = self.encontrar_mascota(nombre_mascota, nombre_duenio);\r\n    if let Some(pos) = posicion {\r\n      self.cola.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_mascota(\u0026self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e Option\u003cusize\u003e{\r\n    self.cola.iter().position(|m| m.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 m.nombre.to_lowercase() == nombre_mascota.to_lowercase())\r\n  }\r\n\r\n  fn registrar_atencion(\u0026mut self, atencion: Atencion){\r\n    self.atenciones.push(atencion);\r\n  }\r\n\r\n  fn buscar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32)-\u003e Option\u003c\u0026mut Atencion\u003e{\r\n    self.atenciones.iter_mut().find(|a| a.mascota.duenio.telefono == telefono_duenio \u0026\u0026 a.mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 a.mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase())\r\n  }\r\n\r\n  fn modificar_diagnostico(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, diagnostico: \u0026str){\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio){\r\n      atencion.diagnostico = diagnostico.to_string();\r\n    }\r\n  }\r\n  \r\n  fn modificar_fecha_proxima_visita(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, nueva_fecha: Option\u003cFecha\u003e) {\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio) {\r\n        if let Some(f) =\u0026nueva_fecha{\r\n          if f.es_fecha_valida(){\r\n            atencion.proxima_visita =Some(f.clone());\r\n          }\r\n        } else {\r\n          atencion.proxima_visita = None;\r\n        }\r\n    }\r\n  }\r\n\r\n  fn eliminar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32) -\u003e bool {\r\n    if let Some(pos) = self.atenciones.iter().position(|a|  //podria haber hecho esto con una funcion auxiliar que busque la pos de la atencion como lo hice con la mascota.\r\n        a.mascota.duenio.telefono == telefono_duenio \u0026\u0026\r\n        a.mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026\r\n        a.mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase()\r\n    ) {\r\n        self.atenciones.remove(pos);\r\n        true\r\n    } else {\r\n        false\r\n    }\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\nuse super::*;\r\n  use crate::tp03::ej03::Fecha;\r\n\r\n  fn crear_mascota(nombre: \u0026str,nombre_duenio: \u0026str, telefono_duenio:u32 )-\u003e Mascota{\r\n    Mascota {\r\n      nombre: nombre.to_string(),\r\n      edad: 3,\r\n      tipo: TipoAnimal::Perro,\r\n      duenio : Duenio {\r\n        nombre: nombre_duenio.to_string(),\r\n        direccion: \"Una direccion\".to_string(),\r\n        telefono: telefono_duenio\r\n      }\r\n    }\r\n  }\r\n\r\n  fn crear_atencion(mascota: Mascota) -\u003e Atencion{\r\n    Atencion {\r\n      mascota,\r\n      diagnostico: \"Un diagnostico\".to_string(),\r\n      tratamiento: \"Un tratamiento\".to_string(),\r\n      proxima_visita: Some(Fecha::new(17,12,2023))\r\n    }\r\n  }\r\n\r\n  fn crear_veterinaria() -\u003e Veterinaria{\r\n    Veterinaria::new(\"Mi veterinaria\".to_string(), \"Mi direccion\".to_string(), 1)\r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    \r\n    let atendida = vet.atender_proxima_mascota();\r\n\r\n    // Verificar que atendida sea Some y luego comparar el contenido manualmente\r\n    assert!(atendida.is_some());\r\n    if let Some(m) = atendida {\r\n      assert!(m.eq(\u0026mascota));\r\n    }\r\n    \r\n    assert_eq!(vet.cola.len(), 0);\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota_prioridad(){\r\n    let mut vet = crear_veterinaria();\r\n    let normal = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    let prioridad = crear_mascota(\"Tato\", \"Florencia\", 12556);\r\n    vet.agregar_mascota_prioridad(prioridad.clone());\r\n    vet.agregar_mascota(normal.clone());\r\n    \r\n    let primero = vet.atender_proxima_mascota();\r\n\r\n    assert!(primero.is_some());\r\n    if let Some(m) = primero {\r\n      assert!(m.eq(\u0026prioridad));\r\n      assert!(!m.eq(\u0026normal));\r\n    }\r\n\r\n    assert_eq!(vet.cola.len(), 1);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota_no_existente(){\r\n    let mut vet = crear_veterinaria(); // veterina con 0 mascotas\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, false);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_registrar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone()); // se pone clone para que no se borre la mascota\r\n    vet.registrar_atencion(atencion);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    let encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert!(encontrada.is_some());\r\n\r\n    //atencion que no existe\r\n    let no_encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 123456);\r\n    assert!(no_encontrada.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_diagnostico(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n    vet.modificar_diagnostico(\"Sombra\", \"Carlos\", 4585, \"Curado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n\r\n    // se pasan mal los nombres en la funcion y debe fallar\r\n    vet.modificar_diagnostico(\"Sombraaaa\", \"Carlos\", 4585, \"Diagnóstico mal aplicado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_fecha_proxima_visita(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(15,01,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_some());\r\n  \r\n\r\n    // Suponiendo que no se pasa fecha  \r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, None);\r\n    assert!(vet.atenciones[0].proxima_visita.is_none());\r\n\r\n    //suponiendo fecha invalida\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(32,13,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_none()); // debería fallar\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let mascota2 = crear_mascota(\"Apo\", \"Nicolas\", 458555);\r\n    \r\n    let atencion = crear_atencion(mascota.clone());\r\n    let atencion2 = crear_atencion(mascota2.clone());\r\n   \r\n    vet.registrar_atencion(atencion);\r\n    vet.registrar_atencion(atencion2);\r\n\r\n    let eliminada = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    let eliminada_inexistente = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada_inexistente, false);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej09v2.rs"],"content":"use std::collections::VecDeque;\r\n\r\n// 9.-Dada una cadena de veterinarias se desea implementar un sistema de atención de \r\n// pacientes para cada veterinaria, de la veterinaria se conoce el nombre, la dirección y un id. \r\n// Para la atención de mascotas se requiere administrar una cola de atención. De la mascota \r\n// se conoce el nombre, la edad, el tipo de animal(perro, gato, caballo, otros) y su dueño. Del \r\n// dueño se conoce el nombre, la dirección y un teléfono de contacto. Luego de la atención se \r\n// desea tener un registro de las atenciones realizadas guardando los datos de la mascota, el \r\n// diagnóstico final, tratamiento y fecha de la próxima visita si es que se requiere. \r\n// Dado todo lo mencionado anteriormente implemente los métodos para realizar las \r\n// siguientes acciones: \r\n// ➔  crear una veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención de la veterinaria. \r\n// ➔  agregar una nueva mascota a la cola de atención pero que sea la siguiente \r\n// en atender porque tiene la máxima prioridad. \r\n// ➔  atender la próxima mascota de la cola. \r\n// ➔  eliminar una mascota específica de la cola de atención dado que se retira. \r\n// ➔  registrar una atención. \r\n// ➔  buscar una atención dado el nombre de la mascota, el nombre del dueño y el \r\n// teléfono. \r\n// ➔  modificar el diagnóstico de una determinada atención. \r\n// ➔  modificar la fecha de la próxima visita de una determinada atención. \r\n// ➔  eliminar una determinada atención. \r\n \r\n// Nota: para la fecha utilice lo implementado en el punto 3\r\nuse crate::tp03::ej03::Fecha;\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nenum TipoAnimal {\r\n  Perro,\r\n  Gato,\r\n  Caballo,\r\n  Otros(String),\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Duenio {\r\n  nombre: String,\r\n  direccion: String,\r\n  telefono: u32,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Mascota {\r\n  nombre: String,\r\n  edad: u32,\r\n  tipo: TipoAnimal,\r\n  duenio: Duenio,\r\n}\r\n\r\nimpl Mascota {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Atencion {\r\n  mascota: Mascota,\r\n  diagnostico: String,\r\n  tratamiento: String,\r\n  proxima_visita:Option\u003cFecha\u003e,\r\n}\r\nstruct Veterinaria {\r\n  nombre_vet: String,\r\n  direccion: String,\r\n  id: u32,\r\n  cola: VecDeque\u003cMascota\u003e,\r\n  atenciones : Vec\u003cAtencion\u003e\r\n}\r\n\r\nimpl Veterinaria {\r\n  fn new(nombre_vet: String, direccion: String, id: u32)-\u003e Self{\r\n    Veterinaria {\r\n      nombre_vet,\r\n      direccion,\r\n      id,\r\n      cola: VecDeque::new(),\r\n      atenciones: Vec::new()\r\n    }\r\n  }\r\n\r\n  fn agregar_mascota(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_back(mascota);\r\n  }\r\n\r\n  fn agregar_mascota_prioridad(\u0026mut self, mascota: Mascota){\r\n    self.cola.push_front(mascota);\r\n  }\r\n\r\n  fn atender_proxima_mascota(\u0026mut self)-\u003e Option\u003cMascota\u003e{\r\n    self.cola.pop_front()\r\n  }\r\n\r\n  fn eliminar_mascota(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e bool{\r\n\r\n    let posicion = self.encontrar_mascota(nombre_mascota, nombre_duenio);\r\n    if let Some(pos) = posicion {\r\n      self.cola.remove(pos);\r\n      true\r\n    } else {\r\n      false\r\n    }\r\n  }\r\n\r\n  fn encontrar_mascota(\u0026self, nombre_mascota: \u0026str, nombre_duenio: \u0026str)-\u003e Option\u003cusize\u003e{\r\n    for i in 0..self.cola.len() {\r\n      if self.cola[i].duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 self.cola[i].nombre.to_lowercase() == nombre_mascota.to_lowercase() {\r\n        return Some(i);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn registrar_atencion(\u0026mut self, atencion: Atencion){\r\n    self.atenciones.push(atencion);\r\n  }\r\n\r\n  fn buscar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32)-\u003e Option\u003c\u0026mut Atencion\u003e{\r\n    for i in 0..self.atenciones.len() {\r\n      if self.atenciones[i].mascota.duenio.telefono == telefono_duenio \u0026\u0026\r\n        self.atenciones[i].mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026\r\n        self.atenciones[i].mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase() {\r\n          return Some(\u0026mut self.atenciones[i]);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn modificar_diagnostico(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, diagnostico: \u0026str){\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio){\r\n      atencion.diagnostico = diagnostico.to_string();\r\n    }\r\n  }\r\n  \r\n  fn modificar_fecha_proxima_visita(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32, nueva_fecha: Option\u003cFecha\u003e) {\r\n    if let Some(atencion) = self.buscar_atencion(nombre_mascota, nombre_duenio, telefono_duenio) {\r\n        if let Some(f) =\u0026nueva_fecha{\r\n          if f.es_fecha_valida(){\r\n            atencion.proxima_visita =Some(f.clone());\r\n          }\r\n        } else {\r\n          atencion.proxima_visita = None;\r\n        }\r\n    }\r\n  }\r\n\r\n  fn eliminar_atencion(\u0026mut self, nombre_mascota: \u0026str, nombre_duenio: \u0026str, telefono_duenio: u32) -\u003e bool {\r\n    for i in 0..self.atenciones.len() {\r\n      if self.atenciones[i].mascota.duenio.telefono == telefono_duenio \u0026\u0026\r\n        self.atenciones[i].mascota.duenio.nombre.to_lowercase() == nombre_duenio.to_lowercase() \u0026\u0026 \r\n        self.atenciones[i].mascota.nombre.to_lowercase() == nombre_mascota.to_lowercase(){\r\n        self.atenciones.remove(i);\r\n          return true\r\n      }\r\n    } \r\n    false\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n\r\nuse super::*;\r\n  use crate::tp03::ej03::Fecha;\r\n\r\n  fn crear_mascota(nombre: \u0026str,nombre_duenio: \u0026str, telefono_duenio:u32 )-\u003e Mascota{\r\n    Mascota {\r\n      nombre: nombre.to_string(),\r\n      edad: 3,\r\n      tipo: TipoAnimal::Perro,\r\n      duenio : Duenio {\r\n        nombre: nombre_duenio.to_string(),\r\n        direccion: \"Una direccion\".to_string(),\r\n        telefono: telefono_duenio\r\n      }\r\n    }\r\n  }\r\n\r\n  fn crear_atencion(mascota: Mascota) -\u003e Atencion{\r\n    Atencion {\r\n      mascota,\r\n      diagnostico: \"Un diagnostico\".to_string(),\r\n      tratamiento: \"Un tratamiento\".to_string(),\r\n      proxima_visita: Some(Fecha::new(17,12,2023))\r\n    }\r\n  }\r\n\r\n  fn crear_veterinaria() -\u003e Veterinaria{\r\n    Veterinaria::new(\"Mi veterinaria\".to_string(), \"Mi direccion\".to_string(), 1)\r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    \r\n    let atendida = vet.atender_proxima_mascota();\r\n\r\n    // Verificar que atendida sea Some y luego comparar el contenido manualmente\r\n    assert!(atendida.is_some());\r\n    if let Some(m) = atendida {\r\n      assert!(m.eq(\u0026mascota));\r\n    }\r\n    \r\n    assert_eq!(vet.cola.len(), 0);\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_atender_mascota_prioridad(){\r\n    let mut vet = crear_veterinaria();\r\n    let normal = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    let prioridad = crear_mascota(\"Tato\", \"Florencia\", 12556);\r\n    vet.agregar_mascota_prioridad(prioridad.clone());\r\n    vet.agregar_mascota(normal.clone());\r\n    \r\n    let primero = vet.atender_proxima_mascota();\r\n\r\n    assert!(primero.is_some());\r\n    if let Some(m) = primero {\r\n      assert!(m.eq(\u0026prioridad));\r\n      assert!(!m.eq(\u0026normal));\r\n    }\r\n\r\n    assert_eq!(vet.cola.len(), 1);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Apo\", \"Nicolas\", 123456);\r\n    vet.agregar_mascota(mascota.clone());\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_mascota_no_existente(){\r\n    let mut vet = crear_veterinaria(); // veterina con 0 mascotas\r\n    let eliminada = vet.eliminar_mascota(\"Apo\", \"Nicolas\");\r\n    assert_eq!(eliminada, false);\r\n    assert_eq!(vet.cola.len(), 0);\r\n  }\r\n\r\n  #[test]\r\n  fn test_registrar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone()); // se pone clone para que no se borre la mascota\r\n    vet.registrar_atencion(atencion);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    \r\n  }\r\n\r\n  #[test]\r\n  fn test_buscar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    let encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert!(encontrada.is_some());\r\n\r\n    //atencion que no existe\r\n    let no_encontrada = vet.buscar_atencion(\"Sombra\", \"Carlos\", 123456);\r\n    assert!(no_encontrada.is_none());\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_diagnostico(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n    vet.modificar_diagnostico(\"Sombra\", \"Carlos\", 4585, \"Curado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n\r\n    // se pasan mal los nombres en la funcion y debe fallar\r\n    vet.modificar_diagnostico(\"Sombraaaa\", \"Carlos\", 4585, \"Diagnóstico mal aplicado\");\r\n    assert_eq!(vet.atenciones[0].diagnostico, \"Curado\");\r\n  }\r\n\r\n  #[test]\r\n  fn test_modificar_fecha_proxima_visita(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let atencion = crear_atencion(mascota.clone());\r\n    vet.registrar_atencion(atencion);\r\n\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(15,01,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_some());\r\n\r\n    // Suponiendo que no se pasa fecha  \r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, None);\r\n    assert!(vet.atenciones[0].proxima_visita.is_none());\r\n\r\n    //suponiendo fecha invalida\r\n    vet.modificar_fecha_proxima_visita(\"Sombra\", \"Carlos\", 4585, Some(Fecha::new(32,13,2024)));\r\n    assert!(vet.atenciones[0].proxima_visita.is_none());\r\n    \r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_eliminar_atencion(){\r\n    let mut vet = crear_veterinaria();\r\n    let mascota = crear_mascota(\"Sombra\", \"Carlos\", 4585);\r\n    let mascota2 = crear_mascota(\"Apo\", \"Nicolas\", 458555);\r\n    \r\n    let atencion = crear_atencion(mascota.clone());\r\n    let atencion2 = crear_atencion(mascota2.clone());\r\n   \r\n    vet.registrar_atencion(atencion);\r\n    vet.registrar_atencion(atencion2);\r\n\r\n    let eliminada = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada, true);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n\r\n    let eliminada_inexistente = vet.eliminar_atencion(\"Sombra\", \"Carlos\", 4585);\r\n    assert_eq!(eliminada_inexistente, false);\r\n    assert_eq!(vet.atenciones.len(), 1);\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","ej10.rs"],"content":"// 10-Para una biblioteca se desea implementar un sistema de préstamos de libros. De la \r\n// biblioteca se conoce el nombre y la dirección, las copias de los libros a disposición para \r\n// prestar y los préstamos efectuados. Los libros a disposición es un registro donde se indica \r\n// la cantidad de ejemplares que tiene a disposición para prestar de determinado libro. De \r\n// cada libro se conoce el isbn, el título, autor, número de páginas, género(novela, infantil, \r\n// técnico, otros). Para registrar un préstamo se requiere el libro, el cliente, la fecha de \r\n// vencimiento del préstamo, la fecha de devolución y el estado que puede ser devuelto o en \r\n// préstamo. Del cliente se conoce el nombre, teléfono y dirección de correo electrónico. \r\n// Implemente los métodos necesarios para realizar las siguientes acciones\r\n// ➔  obtener cantidad de copias: dado un determinado libro retorna la cantidad de \r\n// copias a disposición que hay para prestar de dicho libro. \r\n// ➔  decrementar cantidad de copias a disposición; dado un libro decrementa en 1 \r\n// la cantidad de copias de libros a disposición para prestar. \r\n// ➔  incrementar cantidad de copias a disposición: dado un libro incrementa en 1 \r\n// la cantidad de copias del libro a disposición para ser prestado. \r\n// ➔  contar préstamos de un cliente: devuelve la cantidad de préstamos en estado \r\n// “en préstamo” de un determinado cliente. \r\n// ➔  realizar un préstamo de un libro para un cliente: crea un préstamo de un libro \r\n// para un determinado cliente cumpliendo con lo siguiente  \r\n// ◆  el cliente no tenga más de 5 préstamos en el estado “en préstamo” \r\n// ◆   haya al menos una copia disponible en el registro de copias a \r\n// disposición. \r\n//  De ser así descuenta 1 en el registro de “copias a disposición” y \r\n// retorna true, si no cumple con alguna de las condiciones retorna false. \r\n// ➔  ver préstamos a vencer el los próximos días: retorna una lista de préstamos a \r\n// vencer el los próximos días, el valor de días es pasado por parámetro. \r\n// ➔  ver los préstamos vencidos: retorna una lista de préstamos en el estado “en \r\n// préstamos” donde la fecha de vencimiento es menor a la fecha actual. \r\n// ➔  buscar préstamo: dado un libro y un cliente busca un préstamo y lo retorna si \r\n// existe. \r\n// ➔  devolver libro: dado un libro y un cliente se busca el préstamo y se cambia al \r\n// estado “devuelto”, se registra la fecha de devolución y se incrementa la \r\n// cantidad de libros en 1 del libro devuelto en el registro de copias a \r\n// disposición. \r\n \r\n// Nota: para la fecha utilice lo implementado en el punto 3. \r\n\r\nuse super::ej03::Fecha;\r\nuse chrono::prelude::*;\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Cliente {\r\n  nombre: String,\r\n  telefono: u32,\r\n  correo_electronico: String,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum Genero {\r\n  Novela,\r\n  Infantil,\r\n  Tecnico,\r\n  Otros(String),\r\n}\r\n    \r\n#[derive(Debug, Clone)]\r\nstruct Libro {\r\n  isbn: u32,\r\n  titulo: String,\r\n  autor: String,\r\n  num_paginas: u32,\r\n  genero: Genero,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nenum EstadoPrestamo {\r\n  EnPrestamo,\r\n  Devuelto,\r\n}\r\n\r\nimpl EstadoPrestamo{ // clase 3 pag 23\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn es_igual(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct CopiaDisponible {\r\n    libro: Libro,\r\n    cantidad: u32,\r\n}\r\n#[derive(Debug, Clone)]\r\nstruct Prestamo {\r\n  libro: Libro,\r\n  cliente: Cliente,\r\n  fecha_vencimiento: Fecha,\r\n  fecha_devolucion: Option\u003cFecha\u003e,\r\n  estado: EstadoPrestamo,\r\n}\r\n\r\nimpl Prestamo {\r\n  fn to_string(\u0026self) -\u003e String {\r\n    format!(\"{:?}\", self)\r\n  }\r\n\r\n  fn es_igual(\u0026self, other: \u0026Self) -\u003e bool {\r\n    self.to_string().eq(\u0026other.to_string())\r\n  }\r\n}\r\n\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Biblioteca {\r\n  nombre: String,\r\n  direccion: String,\r\n  copias_disponibles: Vec\u003cCopiaDisponible\u003e,\r\n  prestamos: Vec\u003cPrestamo\u003e,\r\n}\r\n\r\nimpl Biblioteca {\r\n  fn new(nombre: String, direccion: String) -\u003e Self {\r\n    Biblioteca {\r\n      nombre,\r\n      direccion,\r\n      copias_disponibles: Vec::new(),\r\n      prestamos: Vec::new(),\r\n    }\r\n  }\r\n\r\n  fn obtener_cantidad_copias(\u0026self, libro: \u0026Libro) -\u003e Option\u003cu32\u003e {\r\n    if self.copias_disponibles.is_empty() {\r\n      return None;\r\n    }\r\n    let mut cantidad: u32 = 0;\r\n    for copia_disponible in \u0026self.copias_disponibles {\r\n      if copia_disponible.libro.isbn == libro.isbn {\r\n        cantidad += copia_disponible.cantidad;\r\n      }\r\n    }\r\n    Some(cantidad)\r\n  }\r\n\r\n  fn decrementar_cantidad_copias(\u0026mut self, libro: \u0026Libro)-\u003e Option\u003cbool\u003e{\r\n    if self.copias_disponibles.is_empty() {\r\n      return None;\r\n    }\r\n\r\n    for copia_disponible in \u0026mut self.copias_disponibles {\r\n      if copia_disponible.libro.isbn == libro.isbn {\r\n        if copia_disponible.cantidad == 0 {\r\n          return None;\r\n        }\r\n        else {\r\n          copia_disponible.cantidad -= 1;\r\n          return Some(true);\r\n        }        \r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn incrementar_cantidad_copias(\u0026mut self, libro: \u0026Libro)-\u003e Option\u003cbool\u003e{\r\n    if self.copias_disponibles.is_empty() {\r\n      return None;\r\n    }\r\n\r\n    for copia_disponible in \u0026mut self.copias_disponibles {\r\n      if copia_disponible.libro.isbn == libro.isbn {\r\n        copia_disponible.cantidad += 1;\r\n        return Some(true);\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn contar_prestamos_cliente(\u0026mut self, cliente: \u0026Cliente) -\u003e Option\u003cu32\u003e {\r\n    if self.prestamos.is_empty() {\r\n      return None;\r\n    }\r\n    let mut cantidad: u32 = 0;\r\n    for prestamo in \u0026self.prestamos {\r\n      if (prestamo.cliente.nombre == cliente.nombre) \u0026\u0026 (prestamo.estado.es_igual(\u0026EstadoPrestamo::EnPrestamo)) {\r\n        cantidad += 1;\r\n      }\r\n    }\r\n    Some(cantidad)\r\n  }\r\n\r\n  fn realizar_prestamo(\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente, fecha_vencimiento: Fecha) -\u003e bool {\r\n    // si tiene menos de 5 prestamos y hay al menos una copia disponible se puede realizar el prestamo\r\n    if self.contar_prestamos_cliente(cliente) \u003e= Some(5) || self.obtener_cantidad_copias(libro) \u003c Some(1) {\r\n      return false\r\n    }\r\n    else {\r\n      self.prestamos.push(Prestamo {\r\n        libro: libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_vencimiento,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo\r\n      });\r\n      self.decrementar_cantidad_copias(libro);\r\n      return true\r\n    }\r\n  }\r\n\r\n  fn ver_prestamos_a_vencer(\u0026self, dias: u32) -\u003e Vec\u003cPrestamo\u003e {\r\n    let mut prestamos_a_vencer: Vec\u003cPrestamo\u003e = Vec::new();\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32); // fecha actual usando la libreria chrono\r\n    for prestamo in \u0026self.prestamos {\r\n      let mut fecha_vencimiento = prestamo.fecha_vencimiento.clone();\r\n      fecha_vencimiento.sumar_dias(dias);\r\n      if prestamo.fecha_vencimiento.es_mayor(\u0026hoy) \u0026\u0026 prestamo.estado.es_igual(\u0026EstadoPrestamo::EnPrestamo) {\r\n        prestamos_a_vencer.push(prestamo.clone());\r\n      }\r\n    }\r\n    return prestamos_a_vencer;\r\n  }\r\n\r\n  fn ver_prestamos_vencidos(\u0026self) -\u003e Vec\u003cPrestamo\u003e {\r\n    let mut prestamos_vencidos: Vec\u003cPrestamo\u003e = Vec::new();\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32); // fecha actual usando la libreria chrono\r\n    for prestamo in \u0026self.prestamos {\r\n      if !(prestamo.fecha_vencimiento.es_mayor(\u0026hoy)) \u0026\u0026 prestamo.estado.es_igual(\u0026EstadoPrestamo::EnPrestamo) {\r\n        prestamos_vencidos.push(prestamo.clone());\r\n      }\r\n    }\r\n    return prestamos_vencidos;\r\n  }\r\n\r\n  fn buscar_prestamo(\u0026self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Option\u003cPrestamo\u003e { \r\n    for prestamo in \u0026 self.prestamos {\r\n      if prestamo.libro.isbn == libro.isbn \u0026\u0026 prestamo.cliente.nombre == cliente.nombre {\r\n        return Some(prestamo.clone());\r\n      }\r\n    }\r\n    None\r\n  }\r\n\r\n  fn devolver_prestamo(\u0026mut self, libro:\u0026Libro, cliente:\u0026Cliente) -\u003e bool {\r\n    for prestamo in \u0026mut self.prestamos {\r\n      if prestamo.libro.isbn == libro.isbn \u0026\u0026 prestamo.cliente.nombre == cliente.nombre {\r\n        prestamo.estado = EstadoPrestamo::Devuelto;\r\n        let now = Local::now();\r\n        let hoy = Fecha::new(now.day(), now.month(), now.year() as u32); // fecha actual usando la libreria chrono\r\n        prestamo.fecha_devolucion = Some(hoy);\r\n        self.incrementar_cantidad_copias(\u0026libro);\r\n        return true;\r\n      }\r\n    }\r\n    false\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n  use super::*;\r\n  use crate::tp03::ej03::Fecha;\r\n\r\n  fn crear_bibioteca_prueba() -\u003e Biblioteca {\r\n    let mut biblioteca = Biblioteca::new(\r\n      \"Bilioteca PrUeba\".to_string(),\r\n      \"calle Prueba 112\".to_string()\r\n    );\r\n\r\n    let libro1 = Libro {\r\n      isbn: 1234,\r\n      titulo:\"El Pricipito\".to_string(),\r\n      autor:\"Antoine de Saint-Exupery\".to_string(),\r\n      num_paginas: 100,\r\n      genero: Genero::Infantil\r\n    };\r\n\r\n    let libro2 = Libro {\r\n      isbn: 4567,\r\n      titulo:\"100 anios de soledad\".to_string(),\r\n      autor:\"Gabriel Garcia Marquez\".to_string(),\r\n      num_paginas: 350,\r\n      genero: Genero::Novela\r\n    };\r\n\r\n    let libro3 = Libro {\r\n      isbn: 7890,\r\n      titulo:\"Harry Potter\".to_string(),\r\n      autor:\"J.K. Rowling\".to_string(),\r\n      num_paginas: 450,\r\n      genero: Genero::Novela\r\n    };\r\n\r\n    biblioteca.copias_disponibles.push(CopiaDisponible { \r\n      libro: libro1,\r\n      cantidad: 3\r\n    });\r\n\r\n    biblioteca.copias_disponibles.push(CopiaDisponible { \r\n      libro: libro2,\r\n      cantidad: 5\r\n    });\r\n\r\n    biblioteca.copias_disponibles.push(CopiaDisponible { \r\n      libro: libro3,\r\n      cantidad: 0 //un libro sin copias\r\n    });\r\n\r\n    return biblioteca;\r\n\r\n  }\r\n\r\n\r\n  fn crear_cliente_prueba(nombre:\u0026str) -\u003e Cliente {\r\n    Cliente {\r\n      nombre: nombre.to_string(),\r\n      telefono: 1522215,\r\n      correo_electronico: format!(\"{}@example.com\", nombre.to_lowercase()),\r\n    }\r\n  }\r\n\r\n  #[test]\r\n  fn obtener_cantidad_copias_test(){\r\n    let biblioteca = crear_bibioteca_prueba();\r\n\r\n    //libro con copias\r\n    let cantidad = biblioteca.obtener_cantidad_copias(\u0026biblioteca.copias_disponibles[0].libro);\r\n    assert_eq!(cantidad, Some(3));\r\n\r\n    //libro sin copias\r\n    let cantidad2 = biblioteca.obtener_cantidad_copias(\u0026biblioteca.copias_disponibles[2].libro);\r\n    assert_eq!(cantidad2, Some(0));\r\n\r\n    // libro que no existe\r\n    let libro_inexistente = Libro {\r\n      isbn: 0001,\r\n      titulo: String::from(\"Un Libro\"),\r\n      autor: \"Un Autor\".to_string(),\r\n      num_paginas: 0,\r\n      genero: Genero::Otros(\"Desconocido\".to_string())\r\n    };\r\n\r\n    let cantidad3 = biblioteca.obtener_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(cantidad3, Some(0));\r\n\r\n    // caso para una biblioteca vacia\r\n\r\n    let biblioteca_vacia = Biblioteca::new(\"Vacia\".to_string(), \"Mi casa\".to_string());\r\n    let cantidad4 = biblioteca_vacia.obtener_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(cantidad4, None);\r\n  }\r\n\r\n  #[test]\r\n  fn decrementar_cantidad_copias_test(){\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n\r\n    // caso normal, con unlibro que tiene copias\r\n    let libro = \u0026biblioteca.copias_disponibles[0].libro.clone();\r\n    let result = biblioteca.decrementar_cantidad_copias(libro);\r\n    assert_eq!(result, Some(true));\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, 2);\r\n\r\n    // caso libro sin copias;\r\n    let libro2 = \u0026biblioteca.copias_disponibles[2].libro.clone();\r\n    let result = biblioteca.decrementar_cantidad_copias(libro2);\r\n    assert_eq!(result, None);\r\n    assert_eq!(biblioteca.copias_disponibles[2].cantidad, 0);\r\n\r\n    // prueba con un libro que no existe;\r\n    let libro_inexistente: Libro = Libro {\r\n      isbn: 0001,\r\n      titulo: String::from(\"Un Libro\"),\r\n      autor: \"Un Autor\".to_string(),\r\n      num_paginas: 0,\r\n      genero: Genero::Otros(\"Desconocido\".to_string())\r\n    };\r\n\r\n    let result = biblioteca.decrementar_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(result, None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_incrementar_cantidad_copias(){\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    // caso normal, con unlibro que tiene copias\r\n    let libro = \u0026biblioteca.copias_disponibles[0].libro.clone();\r\n    let result = biblioteca.incrementar_cantidad_copias(libro);\r\n    assert_eq!(result, Some(true));\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, 4);\r\n\r\n    // caso libro sin copuas\r\n    let libro2 = \u0026biblioteca.copias_disponibles[2].libro.clone();\r\n    let result = biblioteca.incrementar_cantidad_copias(libro2);\r\n    assert_eq!(result, Some(true));\r\n    assert_eq!(biblioteca.copias_disponibles[2].cantidad, 1);\r\n\r\n    // prueba con un libro que no existe;\r\n    let libro_inexistente: Libro = Libro {\r\n      isbn: 0001,\r\n      titulo: String::from(\"Un Libro\"),\r\n      autor: \"Un Autor\".to_string(),\r\n      num_paginas: 0,\r\n      genero: Genero::Otros(\"Desconocido\".to_string())\r\n    };\r\n\r\n    let result = biblioteca.incrementar_cantidad_copias(\u0026libro_inexistente);\r\n    assert_eq!(result, None);\r\n\r\n  }\r\n\r\n  #[test]\r\n  fn test_contar_prestamos_cliente() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Roman\");\r\n    let cliente2 = crear_cliente_prueba(\"Flor\");\r\n        \r\n    // Caso de biblioteca sin préstamos\r\n    let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\r\n    assert_eq!(cantidad, None);\r\n        \r\n    // Preparar algunos prestamos\r\n    let prestamo1 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    let prestamo2 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[1].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(20, 5, 2025),\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n      \r\n    let prestamo3 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(10, 5, 2025),\r\n      fecha_devolucion: Some(Fecha::new(5, 5, 2025)),\r\n      estado: EstadoPrestamo::Devuelto, // Este no deberia contarse\r\n    };\r\n      \r\n    biblioteca.prestamos.push(prestamo1);\r\n    biblioteca.prestamos.push(prestamo2);\r\n    biblioteca.prestamos.push(prestamo3);\r\n      \r\n    // Caso normal: cliente con pretamos\r\n    let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\r\n    assert_eq!(cantidad, Some(2));\r\n      \r\n    // Caso de cliente sin prestamos\r\n    let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente2);\r\n    assert_eq!(cantidad, Some(0));\r\n  }\r\n\r\n  #[test]\r\n  fn test_realizar_prestamo() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Juan\");\r\n        \r\n    // Caso normal: realizar prestamo exitoso\r\n    let fecha_vencimiento = Fecha::new(15, 5, 2025);\r\n    let resultado = biblioteca.realizar_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente, fecha_vencimiento.clone());\r\n    assert_eq!(resultado, true);\r\n    assert_eq!(biblioteca.prestamos.len(), 1);\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, 2); \r\n        \r\n    // Caso de error: intentar prestar libro sin copias disponibles\r\n    let resultado = biblioteca.realizar_prestamo(\u0026biblioteca.copias_disponibles[2].libro.clone(), \u0026cliente, fecha_vencimiento.clone());\r\n    assert_eq!(resultado, false); \r\n        \r\n    // Caso limite: cliente con 5 préstamos activos\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Pedro\");\r\n        \r\n    // Crear 5 préstamos activos\r\n    for _ in 0..5 {\r\n      let prestamo = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n       };\r\n      biblioteca.prestamos.push(prestamo);\r\n    }\r\n        \r\n    // Intentar hacer el sexto préstamo\r\n    let resultado = biblioteca.realizar_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente, fecha_vencimiento);\r\n    assert_eq!(resultado, false); // Debería fallar, pero con la lógica actual sería true\r\n  }\r\n\r\n  #[test]\r\n  fn test_ver_prestamos_a_vencer() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Juan\");\r\n        \r\n    // FECHA\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32);\r\n\r\n    let mut fecha1 = hoy.clone();\r\n    fecha1.sumar_dias(1);\r\n    \r\n    let mut fecha2 =hoy.clone();\r\n    fecha2.sumar_dias(10);\r\n        \r\n    // Crear préstamos con diferentes fechas de vencimiento\r\n    let prestamo1 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: fecha1,\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    let prestamo2 = Prestamo {\r\n      libro: biblioteca.copias_disponibles[1].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: fecha2,\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    biblioteca.prestamos.push(prestamo1);\r\n    biblioteca.prestamos.push(prestamo2);\r\n        \r\n    // Caso normal: prestamos a vencer\r\n    let prestamos_a_vencer = biblioteca.ver_prestamos_a_vencer(5);\r\n    assert_eq!(prestamos_a_vencer.len(), 2);\r\n  }\r\n    \r\n  #[test]\r\n  fn test_ver_prestamos_vencidos() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Pedro\");\r\n\r\n    let now = Local::now();\r\n    let hoy = Fecha::new(now.day(), now.month(), now.year() as u32);\r\n\r\n    // Préstamo vencido ayer\r\n    let mut fecha_ayer = hoy.clone();\r\n    fecha_ayer.restar_dias(1);\r\n\r\n    let prestamo_vencido = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_ayer,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n\r\n    // Préstamo vencido ayer PERO SE DEVOLVIO\r\n    let mut fecha_ayer = hoy.clone();\r\n    fecha_ayer.restar_dias(1);\r\n\r\n    let prestamo_vencido_devuelto = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_ayer,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::Devuelto,\r\n    };\r\n\r\n    // Préstamo que vence mañana (todavía no vencido)\r\n    let mut fecha_manana = hoy.clone();\r\n    fecha_manana.sumar_dias(1);\r\n\r\n    let prestamo_a_vencer = Prestamo {\r\n        libro: biblioteca.copias_disponibles[2].libro.clone(),\r\n        cliente: cliente.clone(),\r\n        fecha_vencimiento: fecha_manana,\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n\r\n    biblioteca.prestamos.push(prestamo_vencido);\r\n    biblioteca.prestamos.push(prestamo_a_vencer);\r\n    biblioteca.prestamos.push(prestamo_vencido_devuelto);\r\n\r\n    let resultado = biblioteca.ver_prestamos_vencidos();\r\n    assert_eq!(resultado.len(), 1);\r\n    \r\n  }\r\n    \r\n  #[test]\r\n  fn test_buscar_prestamo() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente1 = crear_cliente_prueba(\"Juan\");\r\n    let cliente2 = crear_cliente_prueba(\"Ana\");\r\n        \r\n    // Crear algunos préstamos\r\n    let prestamo1 = Prestamo {\r\n        libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n        cliente: cliente1.clone(),\r\n        fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    let prestamo2 = Prestamo {\r\n        libro: biblioteca.copias_disponibles[1].libro.clone(),\r\n        cliente: cliente1.clone(),\r\n        fecha_vencimiento: Fecha::new(20, 5, 2025),\r\n        fecha_devolucion: None,\r\n        estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    biblioteca.prestamos.push(prestamo1.clone());\r\n    biblioteca.prestamos.push(prestamo2.clone());\r\n        \r\n    // Caso normal: buscar préstamo existente\r\n    let resultado = biblioteca.buscar_prestamo(\u0026biblioteca.copias_disponibles[0].libro, \u0026cliente1);\r\n    assert!(resultado.is_some());\r\n    assert!(resultado.unwrap().es_igual(\u0026prestamo1));\r\n        \r\n    // Caso de error: buscar préstamo con libro existente pero cliente diferente\r\n    let resultado = biblioteca.buscar_prestamo(\u0026biblioteca.copias_disponibles[0].libro, \u0026cliente2);\r\n    assert!(resultado.is_none());\r\n        \r\n    // Caso de error: buscar préstamo con libro inexistente\r\n    let libro_inexistente = Libro {\r\n        isbn: 1111111111,\r\n        titulo: String::from(\"Libro Inexistente\"),\r\n        autor: String::from(\"Autor Desconocido\"),\r\n        num_paginas: 100,\r\n        genero: Genero::Otros(String::from(\"Desconocido\")),\r\n    };\r\n    let resultado = biblioteca.buscar_prestamo(\u0026libro_inexistente, \u0026cliente1);\r\n    assert!(resultado.is_none());\r\n  }\r\n    \r\n\r\n  #[test]\r\n  fn test_devolver_prestamo() {\r\n    let mut biblioteca = crear_bibioteca_prueba();\r\n    let cliente = crear_cliente_prueba(\"Juan\");\r\n    \r\n    // Preparar el estado inicial\r\n    let cantidad_inicial = biblioteca.copias_disponibles[0].cantidad;\r\n        \r\n    // Crear un prestamo\r\n    let prestamo = Prestamo {\r\n      libro: biblioteca.copias_disponibles[0].libro.clone(),\r\n      cliente: cliente.clone(),\r\n      fecha_vencimiento: Fecha::new(15, 5, 2025),\r\n      fecha_devolucion: None,\r\n      estado: EstadoPrestamo::EnPrestamo,\r\n    };\r\n        \r\n    biblioteca.prestamos.push(prestamo);\r\n        \r\n    // Caso normal: devolver préstamo exitosamente\r\n    let resultado = biblioteca.devolver_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente);\r\n    assert_eq!(resultado, true);\r\n        \r\n    // Verificar que la cantidad de copias disponibles aumentó\r\n    assert_eq!(biblioteca.copias_disponibles[0].cantidad, cantidad_inicial + 1);\r\n    \r\n    // Verificar que el estado del préstamo cambió a Devuelto\r\n    if let Some(prestamo_actualizado) = biblioteca.buscar_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente) { \r\n      assert!(prestamo_actualizado.estado.es_igual(\u0026EstadoPrestamo::Devuelto));\r\n      assert!(prestamo_actualizado.fecha_devolucion.is_some());\r\n    } else {\r\n      panic!(\"No se encontró el préstamo después de devolverlo\");\r\n    }\r\n        \r\n    // Caso de error: intentar devolver un préstamo ya devuelto\r\n    let resultado = biblioteca.devolver_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente);\r\n    assert_eq!(resultado, true); // Debería ser false si se comprueba que ya está devuelto\r\n        \r\n    // Caso de error: intentar devolver un préstamo inexistente\r\n    let libro_inexistente = Libro {\r\n        isbn: 1111111111,\r\n        titulo: String::from(\"Libro Inexistente\"),\r\n        autor: String::from(\"Autor Desconocido\"),\r\n        num_paginas: 100,\r\n        genero: Genero::Otros(String::from(\"Desconocido\")),\r\n    };\r\n    let resultado = biblioteca.devolver_prestamo(\u0026libro_inexistente, \u0026cliente);\r\n    assert_eq!(resultado, false);\r\n        \r\n    let cliente_inexistente = crear_cliente_prueba(\"Inexistente\");\r\n    let resultado = biblioteca.devolver_prestamo(\u0026biblioteca.copias_disponibles[0].libro.clone(), \u0026cliente_inexistente);\r\n    assert_eq!(resultado, false);\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","mod.rs"],"content":"// pub mod ej01;\r\n// pub mod ej02;\r\n pub mod ej03;\r\n// pub mod ej04;\r\n// pub mod ej05;\r\n// pub mod ej06;\r\n// pub mod nicolas_carrica_v2;\r\n// pub mod ej07;\r\n// pub mod ej07v2;\r\n// //pub mod ej08;\r\n// pub mod ej08v2;\r\n// //pub mod ej09;\r\n// pub mod ej09v2;\r\n// pub mod ej10;","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp03","nicolas_carrica_v2.rs"],"content":"// Escribir un programa que defina una estructura Estudiante que tenga campos para el \r\n// nombre, el número de identificación y las calificaciones de exámenes. De cada Examen se \r\n// conoce el nombre de la materia y la nota. Para dichas estructuras implemente los siguientes \r\n// métodos: \r\n \r\n// ❖  Examen: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Examen y lo \r\n// retorna. \r\n// ❖  Estudiante: \r\n// ➢  new: que pasando los parámetros correspondientes, crea un Estudiante y lo \r\n// retorna. \r\n// ➢  obtener_promedio: retorna el promedio de las notas. \r\n// ➢  obtener_calificacion_mas_alta: retorna la nota más alta. \r\n// ➢  obtener_calificacion_mas_baja: retorna la nota más baja. \r\n \r\n// Nota: Tenga en cuenta que el Estudiante puede tener entre 0 y n notas de examen.\r\n\r\nstruct Examen {\r\n  nombre_de_materia: String,\r\n  nota: f32,\r\n}\r\n\r\nimpl Examen {\r\n  fn new (nombre_de_materia: String, nota: f32) -\u003e Examen{\r\n    Examen {\r\n      nombre_de_materia,\r\n      nota,\r\n    }\r\n  }\r\n} \r\nstruct Estudiante{\r\n  nombre_estudiante: String,\r\n  id: u32,\r\n  calificaciones: Vec\u003cExamen\u003e\r\n}\r\n\r\nstruct Informe {\r\n  id_estudiante: u32,\r\n  nombre_estudiante: String,\r\n  examenes_rendidos: u32,\r\n  promedio_notas: f32,\r\n  nota_mas_alta: f32,\r\n  materia_mas_alta: String,\r\n  nota_mas_baja: f32,\r\n  materia_mas_baja: String,\r\n}\r\n\r\nimpl Informe {\r\n  fn new(id_estudiante: u32, nombre_estudiante: String, examenes_rendidos: u32, promedio_notas: f32, nota_mas_alta: f32, materia_mas_alta: String, nota_mas_baja: f32, materia_mas_baja: String) -\u003e Informe{\r\n    Informe {\r\n      id_estudiante,\r\n      nombre_estudiante,\r\n      examenes_rendidos,\r\n      promedio_notas,\r\n      nota_mas_alta,\r\n      materia_mas_alta,\r\n      nota_mas_baja,\r\n      materia_mas_baja\r\n    }\r\n\r\n  }\r\n}\r\n\r\nimpl Estudiante{\r\n  fn new(nombre_estudiante: String, id: u32, calificaciones: Vec\u003cExamen\u003e)-\u003e Estudiante {\r\n    Estudiante{\r\n      nombre_estudiante,\r\n      id,\r\n      calificaciones,\r\n    }\r\n  }\r\n\r\n  fn obtener_promedio(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut suma: f32 = 0.0;\r\n    for examen in \u0026self.calificaciones{\r\n      suma+=examen.nota;\r\n    }\r\n    let dim_f = self.calificaciones.len();\r\n    Some(suma/dim_f as f32)\r\n  }\r\n\r\n  fn obtener_calificacion_mas_alta(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    \r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut max:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e max {\r\n        max = examen.nota;\r\n      }\r\n    }\r\n    return Some(max);\r\n  }\r\n\r\n  fn obtener_calificacion_mas_baja(\u0026self) -\u003e Option\u003cf32\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None;\r\n    }\r\n    let mut min:f32 = self.calificaciones[0].nota;\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003c min {\r\n        min = examen.nota;\r\n      }\r\n    }\r\n    return Some(min);\r\n  }\r\n  \r\n  fn generar_informe(\u0026self) -\u003e Option\u003cInforme\u003e {\r\n    if self.calificaciones.is_empty() {\r\n      return None\r\n    }\r\n\r\n    let promedio = match self.obtener_promedio() {\r\n      Some(valor) =\u003e valor,\r\n      None =\u003e return None\r\n    };\r\n\r\n    \r\n    let mut nota_min: f32 = self.calificaciones[0].nota;\r\n    let mut nota_max: f32 = self.calificaciones[0].nota;\r\n\r\n    let mut nombre_materia_max = self.calificaciones[0].nombre_de_materia.clone();\r\n    let mut nombre_materia_min = self.calificaciones[0].nombre_de_materia.clone();\r\n  \r\n\r\n    for examen in \u0026self.calificaciones{\r\n      if examen.nota \u003e nota_max {\r\n        nota_max = examen.nota;\r\n        nombre_materia_max = examen.nombre_de_materia.clone();\r\n      }\r\n      if examen.nota \u003c nota_min {\r\n        nota_min = examen.nota;\r\n        nombre_materia_min = examen.nombre_de_materia.clone();\r\n      }\r\n    }\r\n\r\n    let informe_est = Informe::new(\r\n      self.id,\r\n      self.nombre_estudiante.clone(),\r\n      self.calificaciones.len() as u32,\r\n      promedio,\r\n      nota_max,\r\n      nombre_materia_max,\r\n      nota_min,\r\n      nombre_materia_min\r\n    );\r\n    \r\n\r\n    return Some(informe_est);\r\n    // Agegue el id del estsudiante al informe, me lo habia comido en el examen.\r\n    // en lugar de iniciar el informe con datos vacios y luego asignarlos, inicie el informe con los datos correspondientes luego de obtenerlos.\r\n    // termine de agregar los test al final\r\n  }\r\n    \r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod estudiante_tests{\r\n  use super::*;\r\n  #[test]\r\n  fn test_new(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones,\r\n    );\r\n\r\n    assert_eq!(estudiante.nombre_estudiante, \"Nicolas\");\r\n    assert_eq!(estudiante.id, 25458);\r\n    assert_eq!(estudiante.calificaciones.len(), 3);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_promedio(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_promedio(), Some(7.0));\r\n\r\n    //caso vector vacio\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_promedio(),None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_alta(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 8.0),\r\n      Examen::new(\"Programcion\".to_string(), 7.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_alta(), Some(8.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_alta(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_obtener_calificacion_mas_baja(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 5.0),\r\n      Examen::new(\"Programcion\".to_string(), 9.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    assert_eq!(estudiante.obtener_calificacion_mas_baja(), Some(5.0));\r\n\r\n    let est2 = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      67890,\r\n      Vec::new()\r\n    );\r\n    assert_eq!(est2.obtener_calificacion_mas_baja(), None);\r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe(){\r\n    let calificaciones = vec! [\r\n      Examen::new(\"Matematica\".to_string(), 7.0),\r\n      Examen::new(\"Programcion\".to_string(), 8.0),\r\n      Examen::new(\"Ingles\".to_string(), 7.0),\r\n      Examen::new(\"Seminario Rust\".to_string(), 6.0)\r\n    ];\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    match estudiante.generar_informe(){\r\n      Some(informe) =\u003e {\r\n        assert_eq!(informe.nota_mas_alta, 8.0);\r\n        assert_eq!(informe.nota_mas_baja, 6.0);\r\n        assert_eq!(informe.nombre_estudiante, \"Nicolas\");\r\n        assert_eq!(informe.id_estudiante, 25458);\r\n        assert_eq!(informe.materia_mas_alta, \"Programcion\");\r\n        assert_eq!(informe.materia_mas_baja, \"Seminario Rust\");\r\n        assert_eq!(informe.promedio_notas, 7.0);\r\n        assert_eq!(informe.examenes_rendidos, 4);\r\n      }\r\n      None =\u003e panic!(\"Este informe debería ser None\")\r\n    }\r\n     \r\n  }\r\n\r\n  #[test]\r\n  fn test_generar_informe_vacio(){\r\n    let calificaciones = Vec::new();\r\n    let estudiante = Estudiante::new(\r\n      \"Nicolas\".to_string(),\r\n      25458, \r\n      calificaciones\r\n    );\r\n\r\n    let informe_vacio = estudiante.generar_informe();\r\n    assert!(informe_vacio.is_none());\r\n  }\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej01.rs"],"content":"// 1- Escriba una función que reciba un vector de números enteros y retorna la cantidad de \r\n// números primos. Cree un trait para la determinación del número primo e impleméntelo \r\n// según corresponda. Utilice la función iter sobre el vector y aplique un closure para \r\n// resolverlo.\r\n\r\ntrait EsPrimo {\r\n    fn es_primo(\u0026self) -\u003e bool;\r\n}\r\n\r\nimpl EsPrimo for i32 {\r\n    fn es_primo(\u0026self) -\u003e bool {\r\n        if *self \u003c= 1 {\r\n            return false\r\n        }\r\n\r\n        for n in 2..(self/2) + 1 {\r\n            if self % n == 0 {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        true\r\n    }\r\n}\r\n\r\nfn cantidad_primos\u003cT\u003e(numeros: \u0026Vec\u003cT\u003e) -\u003e i32 where T: EsPrimo {\r\n    let mut cantidad = 0;\r\n    numeros.iter().for_each(|n| {\r\n        if n.es_primo() {\r\n            cantidad += 1;\r\n        }\r\n    });\r\n\r\n    cantidad\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_cantidad_primos_vacia() {\r\n        let vector: Vec\u003ci32\u003e = Vec::new();\r\n        assert_eq!(cantidad_primos(\u0026vector), 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_cantidad_primos_mixto() {\r\n        let vector = vec![1, 2, 4, 6, 7, 9];\r\n        assert_eq!(cantidad_primos(\u0026vector), 2);\r\n    }\r\n}","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":12,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":17,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":29,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":13,"coverable":13},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej02.rs"],"content":"// 2- Dado el siguiente struct: \r\n \r\n// struct Persona\u003c'a\u003e{ \r\n//     nombre:\u0026'a str, \r\n//     apellido:\u0026'a str, \r\n//     direccion:\u0026'a str, \r\n//     ciudad:\u0026'a str, \r\n//     salario:f64, \r\n//     edad:u8,  \r\n// } \r\n \r\n// a- Escriba una función que reciba un vector de personas y otro parámetro que indica un \r\n// salario y retorna un listado de personas donde el salario es mayor al parámetro recibido. \r\n \r\n// b- Escriba una función que reciba un vector de personas, edad y el nombre de una  ciudad, \r\n// y retorna las personas mayores al parámetro edad y que viven en el valor del parámetro \r\n// ciudad. \r\n \r\n// c- Escriba una función que reciba un vector de personas y un nombre de una ciudad y \r\n// retorna true si todas las personas viven en la ciudad pasada por parámetro, false caso \r\n// contrario. \r\n \r\n// d- Escriba una función que reciba un vector de personas y un nombre de una ciudad y \r\n// retorna true si al menos vive una persona en la ciudad pasada por parámetro,, false caso \r\n// contrario.\r\n\r\n// e- Escriba una función que reciba un arreglo de personas y una persona y retorna true si la \r\n// persona existe en el arreglo, false caso contrario \r\n \r\n \r\n// f -Escriba una función que reciba un arreglo de personas y retorna un arreglo con las \r\n// edades de las personas. \r\n \r\n// g - Escriba una función que reciba un arreglo de personas y retorna la persona con el menor \r\n// salario y la persona con el mayor salario, en caso de que haya más de una persona en cada \r\n// categoría desempatar por la edad más grande. \r\n \r\n// Nota: Implemente todos los métodos y traits que considere para resolver los ejercicios. \r\n// Todos los ejercicios deben resolverse con iterator y closure. \r\n#[derive(Debug, PartialEq, Clone)]\r\nstruct Persona\u003c'a\u003e {\r\n    nombre: \u0026'a str,\r\n    apellido: \u0026'a str,\r\n    direccion: \u0026'a str,\r\n    ciudad: \u0026'a str,\r\n    salario: f64,\r\n    edad: u8,\r\n}\r\n\r\nimpl\u003c'a\u003e Persona\u003c'a\u003e {\r\n    fn new(\r\n        nombre: \u0026'a str,\r\n        apellido: \u0026'a str,\r\n        direccion: \u0026'a str,\r\n        ciudad: \u0026'a str,\r\n        salario: f64,\r\n        edad: u8,\r\n    ) -\u003e Persona\u003c'a\u003e {\r\n        Persona {\r\n            nombre,\r\n            apellido,\r\n            direccion,\r\n            ciudad,\r\n            salario,\r\n            edad,\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nfn personas_salario_mayor\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, salario: f64) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e {\r\n    personas\r\n        .iter()\r\n        .filter(|persona| persona.salario \u003e salario)\r\n        .collect()\r\n}\r\n\r\nfn personas_mayor_edad_ciudad\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, edad: u8, ciudad: \u0026'a str) -\u003e Vec\u003c\u0026'a Persona\u003c'a\u003e\u003e {\r\n    personas\r\n        .iter()\r\n        .filter(|persona| persona.edad \u003e edad \u0026\u0026 persona.ciudad == ciudad)\r\n        .collect()\r\n}\r\n\r\nfn personas_en_ciudad\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, ciudad: \u0026'a str) -\u003e bool {\r\n    personas.iter().all(|persona| persona.ciudad == ciudad)\r\n}\r\n\r\nfn alguna_persona_en_ciudad\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e, ciudad: \u0026'a str) -\u003e bool {\r\n    personas.iter().any(|persona| persona.ciudad == ciudad)\r\n}\r\n\r\nfn existe_persona\u003c'a\u003e(personas: \u0026'a [Persona\u003c'a\u003e], persona: \u0026Persona\u003c'a\u003e) -\u003e bool {\r\n    personas.iter().any(|p| p == persona)\r\n}\r\n\r\nfn edades_personas\u003cconst N: usize\u003e(personas: \u0026[Persona; N]) -\u003e Option\u003c[u8; N]\u003e {\r\n    personas\r\n        .iter()\r\n        .map(|persona| persona.edad)\r\n        .collect::\u003cVec\u003cu8\u003e\u003e()\r\n        .try_into()\r\n        .ok()\r\n}\r\n\r\nfn persona_mayor_y_menor_salario\u003c'a\u003e(personas: \u0026'a Vec\u003cPersona\u003e) -\u003e Option\u003c[\u0026'a Persona\u003c'a\u003e; 2]\u003e {\r\n    let minimo = personas.iter().min_by(|per1, per2|{\r\n        per1.salario\r\n        .partial_cmp(\u0026per2.salario)\r\n        .expect(\"Comparacion no posible\")// si es none paniquea\r\n        .then_with(|| {\r\n            per2.edad\r\n            .partial_cmp(\u0026per1.edad)// desempata por edad;\r\n            .expect(\"Comparacion de edad no fue posible\")\r\n        })        \r\n    });\r\n\r\n    let maximo = personas.iter().max_by(|per1, per2|{\r\n        per1.salario\r\n        .partial_cmp(\u0026per2.salario)\r\n        .expect(\"Comparacion no posible\")// si es none paniquea\r\n        .then_with(|| {\r\n            per1.edad\r\n            .partial_cmp(\u0026per2.edad)// desempata por edad;\r\n            .expect(\"Comparacion de edad no fue posible\")\r\n        })        \r\n    });\r\n\r\n    if let (Some(min), Some(max)) = (minimo, maximo) {\r\n        Some([min, max])\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    fn crear_persona\u003c'a\u003e(\r\n    nombre: \u0026'a str,\r\n    apellido: \u0026'a str,\r\n    direccion: \u0026'a str,\r\n    ciudad: \u0026'a str,\r\n    salario: f64,\r\n    edad: u8,\r\n    ) -\u003e Persona\u003c'a\u003e {\r\n        Persona::new(nombre, apellido, direccion, ciudad, salario, edad)\r\n    }\r\n\r\n    #[test]\r\n    fn test_persona_mayor_y_menor_salario() {\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n            crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28),\r\n        ];\r\n        let personas_mayor_y_menor = persona_mayor_y_menor_salario(\u0026personas);\r\n        assert_eq!(personas_mayor_y_menor, Some([\u0026personas[2], \u0026personas[1]]));\r\n\r\n        // vector personas vacio:\r\n        personas.clear();\r\n        assert_eq!(persona_mayor_y_menor_salario(\u0026personas), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_personas_salario_mayor(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n            crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28),\r\n        ];\r\n        let personas_mayor = personas_salario_mayor(\u0026personas, 5000.0);\r\n        assert_eq!(personas_mayor, vec![\u0026personas[1], \u0026personas[3]]);\r\n\r\n        // vector personas vacio:\r\n        personas.clear();\r\n        assert_eq!(personas_salario_mayor(\u0026personas, 0.0).len(),0);\r\n\r\n\r\n    }\r\n\r\n    #[test]\r\n    fn test_persona_mayor_y_menor_salario_con_empate() {\r\n        let personas = vec![\r\n            crear_persona(\"Nico\", \"Carri\", \"Calle 8\", \"La Plata\", 4000.0, 30), // menor salario, edad mayor\r\n            crear_persona(\"Flori\", \"Ore\", \"Calle 3\", \"La Plata\", 4000.0, 20), // menor salario, edad menor\r\n            crear_persona(\"Marce\", \"Pin\", \"Calle 119\", \"La Plata\", 7000.0, 28), // mayor salario, edad menor\r\n            crear_persona(\"Sanchez\", \"Kunfu\", \"Calle 154\", \"La Plata\", 7000.0, 35), // mayor salario, edad mayor\r\n        ];\r\n\r\n        let resultado = persona_mayor_y_menor_salario(\u0026personas);\r\n\r\n        // Menor salario: Nico vs Flori -\u003e Nico (edad mayor)\r\n        // Mayor salario: Marce vs Sanchez -\u003e Sanchez (edad mayor)\r\n        assert_eq!(resultado, Some([\u0026personas[0], \u0026personas[3]]));\r\n    }\r\n\r\n    #[test]\r\n    fn tes_personas_mayor_edad(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n            crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28),\r\n        ];\r\n        let vector = personas_mayor_edad_ciudad(\u0026personas, 25, \"Ciudad A\");\r\n        \r\n        assert_eq!(vector.len(),1);\r\n        assert_eq!(vector, vec![\u0026personas[1]]);\r\n\r\n        // vector personas vacio:\r\n        personas.clear();\r\n        assert_eq!(personas_mayor_edad_ciudad(\u0026personas, 0, \"Ciudad A\").len(),0);\r\n    }\r\n\r\n    \r\n\r\n    #[test]\r\n    fn test_personas_en_ciudad(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n        ];\r\n        let mut existe = personas_en_ciudad(\u0026personas, \"Ciudad A\");\r\n        assert_eq!(existe, true);\r\n\r\n        let p1 = crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20);\r\n        let p2 =  crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28);\r\n\r\n        personas.push(p1);\r\n        personas.push(p2);\r\n\r\n        existe = personas_en_ciudad(\u0026personas, \"Ciudad A\");\r\n        assert_eq!(existe, false);\r\n\r\n    }\r\n\r\n    #[test]\r\n    fn test_alguna_persona_en_ciudad(){\r\n        let mut personas = vec![\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n        ];\r\n        let mut existe = alguna_persona_en_ciudad(\u0026personas, \"Ciudad A\");\r\n        assert_eq!(existe, true);\r\n\r\n        let p1 = crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20);\r\n        let p2 =  crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28);\r\n\r\n        personas.push(p1);\r\n        personas.push(p2);\r\n\r\n        existe = alguna_persona_en_ciudad(\u0026personas, \"Ciudad B\");\r\n        assert_eq!(existe, true);\r\n\r\n        personas.clear();\r\n        existe = alguna_persona_en_ciudad(\u0026personas, \"Ciudad B\");\r\n        assert_eq!(existe, false);\r\n    }\r\n\r\n    #[test]\r\n    fn test_existe_persona(){\r\n        let p1 = crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25);\r\n        let p2 =  crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 5500.0, 28);\r\n        let p3 =  crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20);\r\n        let p4 =  crear_persona(\"Ana\", \"Garcia\", \"Calle 012\", \"Ciudad B\", 5500.0, 28);\r\n        let personas = vec![p1.clone(),p2.clone(),p3.clone(),p4.clone()];\r\n\r\n        let existe = existe_persona(\u0026personas, \u0026p1);\r\n        assert_eq!(existe, true);\r\n\r\n        let personas_vacias: Vec\u003cPersona\u003e = vec![];\r\n        let existe2 = existe_persona(\u0026personas_vacias, \u0026p1);\r\n        assert_eq!(existe2, false);\r\n    }\r\n\r\n    #[test]\r\n    fn test_edades_personas(){\r\n        let personas = [\r\n            crear_persona(\"Juan\", \"Perez\", \"Calle 123\", \"Ciudad A\", 5000.0, 25),\r\n            crear_persona(\"Maria\", \"Gonzalez\", \"Calle 456\", \"Ciudad A\", 6000.0, 30),\r\n            crear_persona(\"Pedro\", \"Lopez\", \"Calle 789\", \"Ciudad B\", 4000.0, 20),\r\n        ];\r\n        let edades = edades_personas(\u0026personas);\r\n        assert_eq!(edades, Some([25, 30, 20]));();\r\n\r\n        let personas_vacias:[Persona; 0] = [];\r\n        let edades2 = edades_personas(\u0026personas_vacias);\r\n        assert_eq!(edades2, Some([]));\r\n\r\n    }\r\n\r\n\r\n}\r\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":74,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":81,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":86,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":89,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":90,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":100,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":108,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":109,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":110,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":111,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":119,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":120,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":121,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":122,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":29,"coverable":36},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","ej03.rs"],"content":"// 3 -La plataforma de streaming \"StreamingRust\" ofrece distintos tipos de suscripciones \r\n// (Basic, Clasic, Super) a sus usuarios. Cada suscripción tiene un costo mensual y una \r\n// duración de meses y una fecha de inicio, además los usuarios pueden pagar por sus \r\n// suscripciones con distintos medios de pago que son Efectivo, MercadoPago, Tarjeta de \r\n// Crédito, Transferencia Bancaria, Cripto. Cada medio de pago tiene sus datos \r\n// correspondientes a excepción de Efectivo. \r\n// Los usuarios solo pueden tener una suscripción activa a la vez. \r\n \r\n// Implemente las estructuras, funciones asociadas y traits necesarios para resolver las \r\n// siguientes acciones: \r\n \r\n// ➢  Crear un usuario con una determinada suscripción y medio de pago. \r\n// ➢  Dado un usuario hacer un upgrade sobre la suscripción. Es decir si está a Basic \r\n// pasa a Clasic y si está en Clasic pasa a Super. \r\n// ➢  Dado un determinado usuario, hacer un downgrade sobre una suscripción, si la \r\n// suscripción es del tipo Basic al hacerlo se cancelará la suscripción. \r\n// ➢  Dado un usuario cancelar la suscripción. \r\n// ➢  Saber el medio de pago que es más utilizado por los usuarios sobre las \r\n// suscripciones activas \r\n// ➢  Saber cual es la suscripción más contratada por los usuarios sobre las suscripciones \r\n// activas. \r\n// ➢  Saber cuál fue el medio de pago más utilizado. \r\n// ➢  Saber cuál fue la suscripción más contratada.\r\nuse std::collections::HashMap;\r\n\r\nuse crate::tp03::ej03::Fecha;\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\r\nenum MedioDePago {\r\n    Efectivo,\r\n    MercadoPago {cvu: String},\r\n    TarjetaDeCredito {numero: String, cvv: String},\r\n    TransferenciaBancaria {cbu: String},\r\n    Cripto {direccion: String},\r\n}\r\n\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\r\nenum TipoSuscripcion {\r\n    Basic,\r\n    Clasic,\r\n    Super,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct Suscripcion {\r\n    tipo: TipoSuscripcion,\r\n    costo_mensual: f32,\r\n    meses: u8,\r\n    inicio: Fecha,\r\n}\r\nstruct Usuario {\r\n    id: u32,\r\n    suscripcion: Option\u003cSuscripcion\u003e,\r\n    pago: MedioDePago,\r\n}\r\n\r\nimpl Usuario { // preferi implementar esto en un struc de usuario, luego desde la plataforma al llamar al usuario aplicarle los metedos corresponditnes.\r\n    fn new(id: u32, suscripcion: Option\u003cSuscripcion\u003e, pago: MedioDePago) -\u003e Self {\r\n        Usuario {\r\n            id,\r\n            suscripcion,\r\n            pago,\r\n        }\r\n    }\r\n\r\n    fn upgrade(\u0026mut self) {\r\n        if let Some(ref mut susc) = self.suscripcion {\r\n            susc.tipo = match susc.tipo {\r\n                TipoSuscripcion::Basic =\u003e TipoSuscripcion::Clasic,\r\n                TipoSuscripcion::Clasic =\u003e TipoSuscripcion::Super,\r\n                TipoSuscripcion::Super =\u003e TipoSuscripcion::Super,\r\n            };\r\n        }\r\n    }\r\n\r\n    fn downgrade(\u0026mut self) {\r\n        if let Some(ref mut susc) = self.suscripcion {\r\n            susc.tipo = match susc.tipo {\r\n                TipoSuscripcion::Super =\u003e TipoSuscripcion::Clasic,\r\n                TipoSuscripcion::Clasic =\u003e TipoSuscripcion::Basic,\r\n                TipoSuscripcion::Basic =\u003e {\r\n                    self.suscripcion = None;\r\n                    return;\r\n                },\r\n            };\r\n        }    \r\n    }\r\n\r\n    fn cancelar_suscripcion(\u0026mut self) {\r\n        self.suscripcion = None;\r\n    }\r\n}\r\n\r\nstruct Plataforma {\r\n    usuarios: Vec\u003cUsuario\u003e,\r\n}\r\n\r\n\r\nimpl Plataforma {\r\n    fn new() -\u003e Self {\r\n        Plataforma {\r\n            usuarios: Vec::new(),\r\n        }\r\n    }\r\n// el uso de hashmap es para poder contar la cantidad de veces que aparece un elemento en un vector.\r\n    fn medio_pago_mas_usado_activo(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        let mut contador = HashMap::new();\r\n        for usuario in \u0026self.usuarios {\r\n            if usuario.suscripcion.is_some() {\r\n                *contador.entry(usuario.pago.clone()).or_insert(0) += 1;\r\n            }\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n    fn suscripcion_activa_mas_contradada(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        let mut contador = HashMap::new();\r\n        for usuario in \u0026self.usuarios {\r\n            if let Some(susc) = \u0026usuario.suscripcion {\r\n                *contador.entry(susc.tipo.clone()).or_insert(0) += 1;\r\n            }\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n    fn medio_pago_mas_usado_total(\u0026self) -\u003e Option\u003cMedioDePago\u003e {\r\n        let mut contador = HashMap::new();\r\n        for user in \u0026self.usuarios {\r\n            *contador.entry(user.pago.clone()).or_insert(0) += 1;\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n    fn suscripcion_mas_contratada_total(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\r\n        let mut contador = HashMap::new();\r\n        for user in \u0026self.usuarios {\r\n            if let Some(s) = \u0026user.suscripcion {\r\n                *contador.entry(s.tipo.clone()).or_insert(0) += 1;\r\n            }\r\n        }\r\n        contador.into_iter().max_by_key(|(_, v)| *v).map(|(k, _)| k)\r\n    }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    fn suscripcion_basic() -\u003e Suscripcion {\r\n        Suscripcion {\r\n            tipo: TipoSuscripcion::Basic,\r\n            costo_mensual: 1000.0,\r\n            meses: 3,\r\n            inicio: Fecha::new(22, 05, 2025),\r\n        }\r\n    }\r\n\r\n    fn suscripcion_clasic() -\u003e Suscripcion {\r\n        Suscripcion {\r\n            tipo: TipoSuscripcion::Clasic,\r\n            costo_mensual: 2000.0,\r\n            meses: 6,\r\n            inicio: Fecha::new(22, 05, 2025),\r\n        }\r\n    }\r\n\r\n    fn suscripcion_super() -\u003e Suscripcion {\r\n        Suscripcion {\r\n            tipo: TipoSuscripcion::Super,\r\n            costo_mensual: 3000.0,\r\n            meses: 12,\r\n            inicio: Fecha::new(22, 05, 2025),\r\n        }\r\n    }\r\n\r\n    fn crear_usuario(id: u32, suscripcion: Option\u003cSuscripcion\u003e, pago: MedioDePago) -\u003e Usuario {\r\n        Usuario::new(id, suscripcion, pago)\r\n    }\r\n\r\n    #[test]\r\n    fn test_upgrade() {\r\n        let mut usuario = crear_usuario(1, Some(suscripcion_basic()), MedioDePago::Efectivo);\r\n        usuario.upgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Clasic);\r\n        }\r\n\r\n        usuario.upgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Super);\r\n        }\r\n\r\n        usuario.upgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Super);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_downgrade() {\r\n        let mut usuario = crear_usuario(1, Some(suscripcion_super()), MedioDePago::Efectivo);\r\n        usuario.downgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Clasic);\r\n        }\r\n\r\n        usuario.downgrade();\r\n        \r\n        if let Some(sub) = \u0026usuario.suscripcion {\r\n            assert_eq!(sub.tipo, TipoSuscripcion::Basic);\r\n        }\r\n\r\n        usuario.downgrade();\r\n        \r\n        assert!(usuario.suscripcion.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cancelar_suscripcion() {\r\n        let mut usuario = crear_usuario(1, Some(suscripcion_super()), MedioDePago::Efectivo);\r\n        usuario.cancelar_suscripcion();\r\n        \r\n        assert!(usuario.suscripcion.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn testar_plataforma(){\r\n        let mut plataforma = Plataforma::new();\r\n        plataforma.usuarios.push(crear_usuario(1, Some(suscripcion_basic()), MedioDePago::Efectivo));\r\n        plataforma.usuarios.push(crear_usuario(2, Some(suscripcion_clasic()), MedioDePago::TarjetaDeCredito { numero: \"123\".into(), cvv: \"123\".into() }));\r\n        plataforma.usuarios.push(crear_usuario(3, Some(suscripcion_super()), MedioDePago::Efectivo));\r\n        plataforma.usuarios.push(crear_usuario(4, Some(suscripcion_basic()), MedioDePago::Efectivo));\r\n        plataforma.usuarios.push(crear_usuario(5, Some(suscripcion_basic()), MedioDePago::MercadoPago { cvu: \"123\".into() }));\r\n\r\n        plataforma.usuarios[4].cancelar_suscripcion();\r\n\r\n        if let Some(mpago) = plataforma.medio_pago_mas_usado_activo() {\r\n            assert_eq!(mpago, MedioDePago::Efectivo);\r\n        }\r\n\r\n        if let Some(tipo) = plataforma.suscripcion_activa_mas_contradada(){\r\n            assert_eq!(tipo, TipoSuscripcion::Basic);\r\n        }\r\n\r\n        if let Some(mpago) = plataforma.medio_pago_mas_usado_total() {\r\n            assert_eq!(mpago, MedioDePago::Efectivo);\r\n        }\r\n\r\n        if let Some(tipo) = plataforma.suscripcion_mas_contratada_total(){\r\n            assert_eq!(tipo, TipoSuscripcion::Basic);\r\n        }\r\n\r\n    }\r\n\r\n    #[test]\r\n    fn test_plataforma_vacia(){\r\n        let plataforma = Plataforma::new();\r\n\r\n        assert!(plataforma.medio_pago_mas_usado_activo().is_none());\r\n        assert!(plataforma.suscripcion_activa_mas_contradada().is_none());\r\n        assert!(plataforma.medio_pago_mas_usado_total().is_none());\r\n        assert!(plataforma.suscripcion_mas_contratada_total().is_none());\r\n    }\r\n\r\n\r\n}\r\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":66,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":107,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":112,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":115,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":116,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":117,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":122,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":130,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":133,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":135,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":136,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":720575940379279360}}],"covered":36,"coverable":36},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","src","tp04","mod.rs"],"content":"pub mod ej01;\r\npub mod ej02;\r\npub mod ej03;","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","target","debug","build","mime_guess-e755a22b2c113b22","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","nicoc","OneDrive","Desktop","Nicolas","Facultad","Semestre-3","RUST","Practica","tps","target","debug","build","mime_guess-f48582c81a56f999","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>